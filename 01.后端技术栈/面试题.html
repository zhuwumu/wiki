<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>笔记整理</title>
    <meta name="description" content="日常笔记整理">
    <meta name="generator" content="VitePress v1.5.0">
    <link rel="preload stylesheet" href="/wiki/assets/style.CuvkYKrP.css" as="style">
    <link rel="preload stylesheet" href="/wiki/vp-icons.css" as="style">
    
    <script type="module" src="/wiki/assets/app.CrdO0i-S.js"></script>
    <link rel="preload" href="/wiki/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/wiki/assets/chunks/theme.B47kHrva.js">
    <link rel="modulepreload" href="/wiki/assets/chunks/framework.DNN_1AUP.js">
    <link rel="modulepreload" href="/wiki/assets/chunks/1699669677755.B4FROfId.js">
    <link rel="modulepreload" href="/wiki/assets/01.后端技术栈_面试题.md.BvcFAGp_.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/wiki/" data-v-1168a8e4><!--[--><!--]--><!----><span data-v-1168a8e4>笔记整理</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-6aa21345 data-v-dc692963><span id="main-nav-aria-label" class="visually-hidden" data-v-dc692963> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/wiki/" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>Home</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/wiki/01.%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/Java.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>后端技术栈</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/wiki/markdown-examples.html" tabindex="0" data-v-dc692963 data-v-e56f3d57><!--[--><span data-v-e56f3d57>Examples</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-bd121fe5><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-17a5e62e><button data-v-17a5e62e>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 collapsible has-active" data-v-c40bc020 data-v-b7550ba0><div class="item" role="button" tabindex="0" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><h2 class="text" data-v-b7550ba0>后端技术栈</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-b7550ba0><span class="vpi-chevron-right caret-icon" data-v-b7550ba0></span></div></div><div class="items" data-v-b7550ba0><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/wiki/01.%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/Java.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>JAVA</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/wiki/01.%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/SpringBoot.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>SpringBoot</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/wiki/01.%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%9E%B6%E6%9E%84300%E8%AE%B2.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>架构300讲</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/wiki/01.%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/%E9%9D%A2%E8%AF%95%E9%A2%98.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>面试题</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0" data-v-c40bc020 data-v-b7550ba0><div class="item" role="button" tabindex="0" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><h2 class="text" data-v-b7550ba0>Examples</h2><!----></div><div class="items" data-v-b7550ba0><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/wiki/markdown-examples.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>Markdown Examples</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b7550ba0 data-v-b7550ba0><div class="item" data-v-b7550ba0><div class="indicator" data-v-b7550ba0></div><a class="VPLink link link" href="/wiki/api-examples.html" data-v-b7550ba0><!--[--><p class="text" data-v-b7550ba0>Runtime API Examples</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>On this page</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _wiki_01_%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88_%E9%9D%A2%E8%AF%95%E9%A2%98" data-v-39a288b8><div><blockquote></blockquote><p><img src="/wiki/images/Java/1699669677755.png" alt=""></p><h2 id="java基础" tabindex="-1">Java基础 <a class="header-anchor" href="#java基础" aria-label="Permalink to &quot;Java基础&quot;">​</a></h2><ol><li><h4 id="string-str-new-string-abc-创建了几个对象-为什么" tabindex="-1">String str = new String(&quot;abc&quot;);创建了几个对象，为什么？ <a class="header-anchor" href="#string-str-new-string-abc-创建了几个对象-为什么" aria-label="Permalink to &quot;String str = new String(&quot;abc&quot;);创建了几个对象，为什么？&quot;">​</a></h4><p>2个，&quot;abc&quot;本身创建在方法区的常量池，通过new又创建在堆中。</p><p><img src="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1703307877243.png" alt="1703307877243"></p><p><img src="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1.jpg" alt=""></p></li><li><h4 id="string可以被继承么" tabindex="-1">String可以被继承么？ <a class="header-anchor" href="#string可以被继承么" aria-label="Permalink to &quot;String可以被继承么？&quot;">​</a></h4><p>String是final的，不能被继承</p></li><li><h4 id="java类加载机制-到底能不能自己自定义java-lang-string类" tabindex="-1">java类加载机制：到底能不能自己自定义java.lang.String类 <a class="header-anchor" href="#java类加载机制-到底能不能自己自定义java-lang-string类" aria-label="Permalink to &quot;java类加载机制：到底能不能自己自定义java.lang.String类&quot;">​</a></h4><blockquote><p><a href="https://blog.csdn.net/liubenlong007/article/details/88574544" target="_blank" rel="noreferrer">https://blog.csdn.net/liubenlong007/article/details/88574544</a></p></blockquote><ul><li>不可以加载自定义的java.开头的任何类。JDK8+以上直接报警</li><li>因为JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写loadClass搜索类的算法。</li><li>如果不想打破双亲委派模型，那么只需要重写findClass方法即可。</li><li>如果想打破双亲委派模型，那么就重写整个loadClass方法。</li></ul></li><li><h4 id="main方法的作用域是什么-能否改变" tabindex="-1">main方法的作用域是什么，能否改变 <a class="header-anchor" href="#main方法的作用域是什么-能否改变" aria-label="Permalink to &quot;main方法的作用域是什么，能否改变&quot;">​</a></h4><p>public，不能改变。main()方法是虚拟机在调用。Java虚拟机需要调用类的main()方法，Java虚拟机和main()方法不在同一个类中，所以访问权限必须是public</p></li><li><h4 id="main-方法为什么是静态的-能不能改为非静态" tabindex="-1">main 方法为什么是静态的？能不能改为非静态？ <a class="header-anchor" href="#main-方法为什么是静态的-能不能改为非静态" aria-label="Permalink to &quot;main 方法为什么是静态的？能不能改为非静态？&quot;">​</a></h4><ul><li>JVM调用main()方法时不必创建对象，所以方法必须是public。如果为非静态，需要实例化他的类，在实例化时还得调用构造函数，如果这个类的构造函数有参数，那么届时就会出现歧义。</li><li></li></ul></li><li><h4 id="main-方法如何传递参数-传递参数的类型是什么-能不能改变该参数类型" tabindex="-1">main 方法如何传递参数？传递参数的类型是什么？能不能改变该参数类型？ <a class="header-anchor" href="#main-方法如何传递参数-传递参数的类型是什么-能不能改变该参数类型" aria-label="Permalink to &quot;main 方法如何传递参数？传递参数的类型是什么？能不能改变该参数类型？&quot;">​</a></h4><ul><li><p>String[]数组。不能改变，该数组中保存着执行java命令时传递给所运行的类的参数，接受参数。</p></li><li><p>Java应用程序是可以通过命令行接受参数传入的</p></li></ul></li><li><h4 id="main方法的返回值是void。因为它是入口-不需要任何返回值。" tabindex="-1">main方法的返回值是void。因为它是入口，不需要任何返回值。 <a class="header-anchor" href="#main方法的返回值是void。因为它是入口-不需要任何返回值。" aria-label="Permalink to &quot;main方法的返回值是void。因为它是入口，不需要任何返回值。&quot;">​</a></h4></li><li></li></ol><h3 id="匿名内部类、静态内部类" tabindex="-1">匿名内部类、静态内部类 <a class="header-anchor" href="#匿名内部类、静态内部类" aria-label="Permalink to &quot;匿名内部类、静态内部类&quot;">​</a></h3><h3 id="spring的bean有无状态" tabindex="-1">Spring的Bean有无状态 <a class="header-anchor" href="#spring的bean有无状态" aria-label="Permalink to &quot;Spring的Bean有无状态&quot;">​</a></h3><h3 id="threadlocal" tabindex="-1">ThreadLocal <a class="header-anchor" href="#threadlocal" aria-label="Permalink to &quot;ThreadLocal&quot;">​</a></h3><p>存储多线程之间的局部变量，空间换时间，内部threadlocalMap维护。 在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。</p><h3 id="事务失效的情况" tabindex="-1">事务失效的情况 <a class="header-anchor" href="#事务失效的情况" aria-label="Permalink to &quot;事务失效的情况&quot;">​</a></h3><ul><li>1、方法不是public。spring要求被代理方法必须是public的</li><li>2、方法用final修饰。Spring事务底层使用了aop，也就是通过jdk或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。final的方法，在它的代理类中，无法重写该方法，无法添加事务功能。</li><li>3、方法内部调用。内部调用其实是通过this来调用的。如果要解决，就将这个service通过Autowired本身进行注入。</li><li>4、未被Spring管理</li><li>5、多线程调用。Spring的事务是通过数据库连接来实现的。当前线程中保存了一个map&lt;数据源，数据库连接&gt;。线程间的数据是隔离的，如果用多线程去调用另一个方法的话，就会产生多分ThreadLocal，从而产生多个数据库连接，数据库也就不一样了。同一个事务，是指同一个数据库连接，只有拥有同一个数据库连接，才能同时提交和回滚。</li><li>6、表不支持事务</li><li>7、未开启事务。Spring是需要通过xml去配置的。Springboot是默认开启事务的。</li><li><strong>事务未回滚</strong></li><li>8、错误的传播特性</li><li>9、自己吞了异常，开发者在代码中手动try...catch了异常</li><li>10、手动抛了别的异常</li><li>11、自定义了回滚异常</li><li>12、嵌套事务回滚多了。</li></ul><h2 id="集合" tabindex="-1">集合 <a class="header-anchor" href="#集合" aria-label="Permalink to &quot;集合&quot;">​</a></h2><ol><li><h4 id="容器包含map和collection。collection包含list、set-元素不重复-、queue" tabindex="-1">容器包含map和collection。collection包含list、set(元素不重复)、queue <a class="header-anchor" href="#容器包含map和collection。collection包含list、set-元素不重复-、queue" aria-label="Permalink to &quot;容器包含map和collection。collection包含list、set(元素不重复)、queue&quot;">​</a></h4><p><img src="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1703318795730.png" alt="1703318795730"></p></li><li><h4 id="list遍历删除-不能直接使用remove-要使用iterator。原因是会导致-modcount-不准确" tabindex="-1">List遍历删除，不能直接使用remove，要使用iterator。原因是会导致 modCount 不准确 <a class="header-anchor" href="#list遍历删除-不能直接使用remove-要使用iterator。原因是会导致-modcount-不准确" aria-label="Permalink to &quot;List遍历删除，不能直接使用remove，要使用iterator。原因是会导致 modCount 不准确&quot;">​</a></h4></li><li><h4 id="list线程安全" tabindex="-1">List线程安全 <a class="header-anchor" href="#list线程安全" aria-label="Permalink to &quot;List线程安全&quot;">​</a></h4><ul><li><code>CopyOnWriteArrayList</code>读不加锁，写加锁并且复制副本，内存偏大，适合读多写少场景，比如缓存。</li><li><code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code>读写都加锁，适合读写均匀的场景。</li></ul></li><li></li></ol><h2 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h2><ol><li><h4 id="线程的状态" tabindex="-1">线程的状态 <a class="header-anchor" href="#线程的状态" aria-label="Permalink to &quot;线程的状态&quot;">​</a></h4><p>新建（new）、可运行（Runnable）、阻塞（Blocking）、等待（限期等待、无限期等待）、终止（terminated）</p><p><img src="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1703317342878.png" alt="1703317342878"></p></li><li><h4 id="lock和synchronized的区别" tabindex="-1">Lock和Synchronized的区别 <a class="header-anchor" href="#lock和synchronized的区别" aria-label="Permalink to &quot;Lock和Synchronized的区别&quot;">​</a></h4><blockquote><p><a href="https://www.zhihu.com/question/554622035/answer/2989085239" target="_blank" rel="noreferrer">https://www.zhihu.com/question/554622035/answer/2989085239</a></p></blockquote><ul><li><p>Synchronized通过使用<strong>内置锁</strong>、<strong>与对象关联的锁</strong>、<strong>可重入性</strong>、<strong>内存屏障</strong>等机制来实现线程的同步和锁的管理，以保证对共享资源的访问具有互斥性和可见性。</p></li><li><p>Lock使用<strong>条件变量</strong>（condition）来实现线程的等待和通知。 Condition接口提供了await()、signal()和signalAll()等方法，用于线程之间的等待和通知，从而避免了Object类中wait()和notify()方法可能出现的信号丢失问题。 比Synchronized提供了灵活性和扩展性。</p></li><li><p>Lock可以中断和设置超时</p></li><li><p>Lock可以获取锁的状态。</p></li><li><p>ReentrantLock()可重入锁。</p></li><li></li></ul></li><li><h4 id="synchronized的注意事项" tabindex="-1">Synchronized的注意事项 <a class="header-anchor" href="#synchronized的注意事项" aria-label="Permalink to &quot;Synchronized的注意事项&quot;">​</a></h4><ul><li>方法锁形式：Synchronized修饰<strong>普通方法</strong>，锁对象默认为this，实例对象。</li><li>Synchronized代码块默认是this，可以指定锁对象为class对象。</li><li>Synchronized修饰<strong>静态方法</strong>，默认的锁就是当前所在的class类，所以无论哪个线程去访问它，需要的锁都只有一把。</li><li>锁对象不能为空，因为锁的信息都保存在对象里头</li><li>作用域不易过大，影响程序执行速度，控制范围过大，编写代码也容易出错。有时也可以通过扩大作用域，提升性能，如StringBuffer</li><li>避免死锁</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错。</li></ul></li><li><h4 id="在-java-中-wait-和-sleep-方法的不同" tabindex="-1">在 java 中 wait 和 sleep 方法的不同？ <a class="header-anchor" href="#在-java-中-wait-和-sleep-方法的不同" aria-label="Permalink to &quot;在 java 中 wait 和 sleep 方法的不同？&quot;">​</a></h4><p>wait会释放锁，sleep会一直持有锁。wait通常用于线程间交互，sleep通常用于暂停执行。</p></li><li><h4 id="阻塞队列成员" tabindex="-1">阻塞队列成员 <a class="header-anchor" href="#阻塞队列成员" aria-label="Permalink to &quot;阻塞队列成员&quot;">​</a></h4><table tabindex="0"><thead><tr><th><strong>队列</strong></th><th><strong>有界性</strong></th><th><strong>锁</strong></th><th><strong>数据结构</strong></th><th>备注</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>bounded（有界）</td><td>加锁</td><td>arrayList</td><td>满了，会根据maximumPoolSize的值增加线程数量，如果增加了还是处理不过来，则会使用拒绝策略RejectedExecutionHandler，默认是AbortPolicy</td></tr><tr><td>LinkedBlockingQueue</td><td>optionally-bounded（可选-有界）</td><td>加锁</td><td>linkedList</td><td>无界队列，可以认为是一个无穷大的队列，可以无限存放任务。</td></tr><tr><td>PriorityBlockingQueue(优先)</td><td>unbounded（无界）</td><td>加锁</td><td>heap</td><td></td></tr><tr><td>DelayQueue</td><td>unbounded</td><td>加锁</td><td>heap</td><td>队列中元素顺序是按到期时间排序的，而非进入队列的顺序。最优的消费者线程的个数与任务启动的时间间隔好像存在这样的关系：单个任务处理时间的最大值　/ 相邻任务的启动时间最小间隔　＝　最优线程数，如果最优线程数是小数，则取整数后加１，比如1.3的话，那么最优线程数应该是2。</td></tr><tr><td>SynchronousQueue</td><td>bounded</td><td>加锁</td><td>无</td><td></td></tr><tr><td>LinkedTransferQueue</td><td>unbounded</td><td>加锁</td><td>heap</td><td></td></tr><tr><td>LinkedBlockingDeque</td><td>unbounded</td><td>加锁</td><td>heap</td><td></td></tr></tbody></table></li><li><h4 id="volatile的作用" tabindex="-1">volatile的作用 <a class="header-anchor" href="#volatile的作用" aria-label="Permalink to &quot;volatile的作用&quot;">​</a></h4><ul><li>保证多线程之间的可见性。</li><li>和CAS结合，保证原子性。</li></ul></li><li><h4 id="如何在两个线程之间共享数据" tabindex="-1">如何在两个线程之间共享数据 <a class="header-anchor" href="#如何在两个线程之间共享数据" aria-label="Permalink to &quot;如何在两个线程之间共享数据&quot;">​</a></h4><p>通 过 在 线 程 之 间 共 享 对 象 就 可 以 了 ， 然 后 通 过 wait/notify/notifyAll 、await/signal/signalAll 进行唤起和等待，比方说阻塞队列 BlockingQueue就是为线程之间共享数据而设计的</p></li><li><h4 id="生产者消费者模型的作用是什么" tabindex="-1">生产者消费者模型的作用是什么 <a class="header-anchor" href="#生产者消费者模型的作用是什么" aria-label="Permalink to &quot;生产者消费者模型的作用是什么&quot;">​</a></h4><ul><li>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率</li><li>解耦</li></ul></li><li><h4 id="concurrenthashmap的并发度是什么" tabindex="-1">ConcurrentHashMap的并发度是什么 <a class="header-anchor" href="#concurrenthashmap的并发度是什么" aria-label="Permalink to &quot;ConcurrentHashMap的并发度是什么&quot;">​</a></h4><p>是segment（部分）的大小，默认是16，也就意味着最多16条线程同时操作ConcurrentHashMap</p></li><li><h4 id="readwritelock是什么" tabindex="-1">ReadWriteLock是什么 <a class="header-anchor" href="#readwritelock是什么" aria-label="Permalink to &quot;ReadWriteLock是什么&quot;">​</a></h4><p>ReentrantReadWriteLock是 ReadWriteLock 接口的一个具体实现 ，实现了<strong>读写分离</strong>，读锁是共享的，写锁是独占的，提升了读写性能。</p></li><li><h4 id="写一个死锁的例子" tabindex="-1">写一个死锁的例子 <a class="header-anchor" href="#写一个死锁的例子" aria-label="Permalink to &quot;写一个死锁的例子&quot;">​</a></h4><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247483887&amp;idx=1&amp;sn=ab85965995bde2fb539aaa4b47e7e008&amp;chksm=eb5384d9dc240dcfa20ce9ceedcc8f6174337f74482b103d0b9fc363b5e6b6366e7ddc4590c7&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247483887&amp;idx=1&amp;sn=ab85965995bde2fb539aaa4b47e7e008&amp;chksm=eb5384d9dc240dcfa20ce9ceedcc8f6174337f74482b103d0b9fc363b5e6b6366e7ddc4590c7&amp;scene=21#wechat_redirect</a></p></blockquote><ul><li>两个线程里分别持有2个Object对象，lock1和lock2，这两个lock作为同步代码块的锁。</li><li>线程1的run()方法先获取lock1的锁，然后睡眠50毫秒（防止刚启动就直接获取了lock2的锁），获取lock2的锁。</li><li>线程2的run()方法先获取lock2的锁，再去获取lock1的锁。此时形成了死锁。</li></ul></li><li><h4 id="如何避免死锁" tabindex="-1">如何避免死锁？ <a class="header-anchor" href="#如何避免死锁" aria-label="Permalink to &quot;如何避免死锁？&quot;">​</a></h4><ul><li>顺序加锁。</li><li>获取锁时限。每个获取锁的时候加上时限，如果超时，则放弃该锁。</li><li>死锁检查。按线程间获取锁的关系检测线程间是否发生死锁，如果发生死锁就执行一定的策略，如终端线程或回滚操作等。</li></ul></li><li></li><li></li></ol><h2 id="io" tabindex="-1">IO <a class="header-anchor" href="#io" aria-label="Permalink to &quot;IO&quot;">​</a></h2><ol><li><h4 id="通道" tabindex="-1">通道 <a class="header-anchor" href="#通道" aria-label="Permalink to &quot;通道&quot;">​</a></h4><ul><li>FileChannel：操作文件</li><li>DatagramChannel：通过UDP读写网络中数据</li><li>SocketChannel：通过TCP读写网络中数据</li><li>ServerSocketChannel： 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel</li></ul></li><li><h4 id="缓冲区" tabindex="-1">缓冲区 <a class="header-anchor" href="#缓冲区" aria-label="Permalink to &quot;缓冲区&quot;">​</a></h4><p><img src="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1703511759538.png" alt="1703511759538"></p></li><li></li><li></li></ol><h2 id="mysql" tabindex="-1">Mysql <a class="header-anchor" href="#mysql" aria-label="Permalink to &quot;Mysql&quot;">​</a></h2><p>索引包含所有满足查询需要的数据的索引，称为覆盖索引(Covering Index)。</p><h2 id="项目技术点" tabindex="-1">项目技术点 <a class="header-anchor" href="#项目技术点" aria-label="Permalink to &quot;项目技术点&quot;">​</a></h2><p>1、网络结构是7层国际标准（OSI）、4层模型、5层结构</p><p>2、每一层对应常见协议</p><table tabindex="0"><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>应用层</td><td>http、ftp</td><td></td></tr><tr><td>传输层</td><td>TCP、UDP</td><td></td></tr><tr><td>网络层</td><td>IP</td><td></td></tr><tr><td>网络接口层</td><td></td><td></td></tr></tbody></table><h2 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-label="Permalink to &quot;http&quot;">​</a></h2><p><strong>1、输入URl到返回页面的解析过程</strong></p><p>大致6步，</p><p>1、DNS解析，获取域名对应IP</p><p>2、TCP连接，3次握手，建立TCP连接</p><p>3、发送Http数据</p><p>4、服务器处理数据，返回http请求结果</p><p>5、浏览器渲染</p><p>6、断开TCP，4次挥手</p><h2 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h2><p><strong>1、握手为什么不是2次或4次</strong></p><ul><li>防止服务器端开启无用连接，增加服务器开销</li><li>防止已失效连接请求报文突然传到服务器，产生错误。</li><li>3次已经足够，没有必要再增加一次</li></ul><p><strong>2、挥手4次</strong></p><ul><li>需要等待完成数据的发送和接收，ack和FIN是分开发送的</li></ul><h2 id="udp" tabindex="-1">udp <a class="header-anchor" href="#udp" aria-label="Permalink to &quot;udp&quot;">​</a></h2><h2 id="socket" tabindex="-1">socket <a class="header-anchor" href="#socket" aria-label="Permalink to &quot;socket&quot;">​</a></h2><p><strong>1、socket和websocket有啥区别</strong></p><p>socket就是ip+port+协议，是一套网络标准接口，完成了对TCP/IP的高度封装，屏蔽了网络细节，方便开发者更好的进行网络编程。</p><p>websocket是解决http不支持持久化连接的问题，伴随H5而出的持久化的协议，属于应用层通信协议。</p><h2 id="netty" tabindex="-1">netty <a class="header-anchor" href="#netty" aria-label="Permalink to &quot;netty&quot;">​</a></h2><h2 id="线程池" tabindex="-1">线程池 <a class="header-anchor" href="#线程池" aria-label="Permalink to &quot;线程池&quot;">​</a></h2><h2 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h2><h4 id="_23种设计模式。" tabindex="-1">23种设计模式。 <a class="header-anchor" href="#_23种设计模式。" aria-label="Permalink to &quot;23种设计模式。&quot;">​</a></h4><ul><li>单例模式。Runtim，getRunTime()。饿汉（线程安全效率低）、懒汉（懒加载，线程不安全）、双重检验锁（效率高）、静态内部类（既可以懒加载，又线程安全）</li><li>工厂模式。被用于不可变的类，如Boolean.valueOf()</li><li>观察者模式（发布-订阅模式）。事件的监听中listener</li><li>装饰器设计模式。用于IO，bufferRead</li><li>责任链模式（多任务形成一条链，请求在链上传递）。Filter，doFilter()</li><li>原型模式</li><li>适配器模式。当不希望实现一个接口中所有的方法，创建一个抽象类，实现所有方法，我们继承这个抽象类即可。</li><li>代理模式</li><li>外观模式，集合所有操作到一个类，降低耦合</li><li>桥接模式（数据库驱动桥接），JDBC提供统一接口</li><li>享元模式（共享池、数据库连接池），目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用，如果有就直接返回对象，如果没有，再创建</li><li>策略模式（多种算法封装）。统一接口，jvm根据不同的实现类调用不同实现类的方法</li><li>模板方法模式（抽象方法作为骨架，具体逻辑让子类实现）</li><li>迭代器模式（遍历集合）</li><li>命令模式（实现请求和执行的解耦）</li><li>备忘录模式（保存和恢复对象状态）</li><li>状态模式（对象状态改变时改变其行为）</li><li>访问者模式（数据接口稳定，但算法易变）</li><li>中介模式。降低耦合，类似Spring容器的作用。</li><li>解释器模式。正则表达式</li><li>建造者模式</li></ul><h4 id="spring中设计模式" tabindex="-1">Spring中设计模式 <a class="header-anchor" href="#spring中设计模式" aria-label="Permalink to &quot;Spring中设计模式&quot;">​</a></h4><ul><li>简单工厂。BeanFactory就是简单工厂模式的体现。</li><li>单例模式：Spring下默认的bean均为singleto</li><li>代理模式</li><li>观察者模式：ApplicationListener</li></ul><ol><li><p><strong>简述一下线程的几种状态以及状态之间的转换</strong>。<a href="https://www.cnblogs.com/javastack/p/17639536.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/javastack/p/17639536.html</a></p><p>在 JVM 运行中，线程一共有 NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED 六种状态，这些状态对应 <code>Thread.State</code> 枚举类中的状态。</p><p><img src="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1218593-20230818092917421-1372614659.png" alt="img"></p></li><li><p><strong>什么是线程安全，如何实现线程安全？</strong></p></li></ol><p>线程安全是指在多线程环境下，多个线程同时访问同一资源时，不会产生意外结果或导致数据出错的状态</p><ul><li><p>加锁。通过加锁机制控制对共享资源的访问，使得每次只有一个线程能够访问共享资源。Java中提供了synchronized关键字和Lock接口来实现加锁功能。</p></li><li><p>原子变量。 AtomicInteger和AtomicReference</p></li><li><p>线程安全的集合类 . ConcurrentHashMap和ConcurrentLinkedQueue</p></li><li><p>使用volatile关键字：当多个线程同时访问同一个变量时，使用volatile关键字可以确保该变量对所有线程可见，避免出现数据不一致问题。</p></li><li><p>线程封闭：将共享资源限定在单个线程内部，避免多个线程同时访问，也就不存在线程安全问题。</p></li><li><p>不可变对象：将对象设计成不可变的，可以避免线程安全问题。因为不可变对象的状态不会改变，因此多个线程同时访问该对象也不会出现问题</p></li></ul><p><strong>HashMap 的实现原理以及在什么情况下会发生扩容</strong></p><ul><li>1.7数组+链表</li><li>1.8数组+红黑树</li></ul><ol><li><p><strong>如何理解 Java 的反射机制，它有什么作用？</strong></p><p>Java中的反射机制（Reflection）是一种能够在运行时动态获取类的详细信息并操作类和对象的机制。反射允许程序在运行时检查和修改类的结构和行为</p><p>Java反射机制的用途</p><ul><li><p>动态类加载：反射可以在运行时加载类和创建类的实例，而不需要在编译时知道类的名称。这对于实现动态模块加载和插件机制非常有用。</p></li><li><p>获取类的信息：通过反射，程序可以在运行时获取类的结构信息，包括类的属性、方法、构造函数、父类和实现的接口等。</p></li><li><p>操作对象：反射可以在运行时访问和修改对象的属性、调用对象的方法，甚至可以创建新对象。这在框架和库中经常使用，比如Spring、Hibernate等。</p></li><li><p>动态代理：反射是Java动态代理机制的基础。动态代理允许在运行时创建一个代理对象，用来代理其他对象的行为，这对于AOP（面向方面编程）非常重要。</p></li><li><p>测试和调试：反射可以用于编写测试代码，比如JUnit中的测试框架，通过反射可以调用私有方法和访问私有属性，从而进行单元测试。</p></li></ul></li><li><p><strong>讲讲常见的设计模式，以及在实际项目中的应用</strong>。</p></li><li><p><strong>Spring 框架的核心概念有哪些？</strong></p><ul><li>IOC</li><li>AOP</li><li>DI</li></ul></li><li><p><strong>数据库事务的四大特性是什么？</strong></p><p>ACID</p><ul><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ul></li><li><p><strong>如何优化数据库查询性能？</strong></p><ul><li><p>使用索引</p></li><li><p>避免函数和表达式</p></li><li></li><li><p>缓存</p><p><strong>在高并发场景下，如何处理数据一致性问题？</strong></p></li></ul></li></ol><ul><li>事务管理：使用数据库事务来确保关键操作的原子性、一致性、隔离性和持久性。通过合理的事务设计和管理，对于涉及到多个数据操作的场景，可以保证数据的一致性。</li><li>数据库锁机制：使用数据库提供的锁机制来保证对共享资源的独占访问。通过合理使用行锁、表锁、悲观锁或乐观锁等方式，控制并发访问数据库的行为，保证数据的一致性和正确性。</li><li>幂等性设计：设计接口或操作具有幂等性，即对同一请求的多次执行只会产生一次结果影响。通过设计幂等性操作，可以避免因为同一请求的重复执行而导致的数据重复或不一致问题。</li><li>高可用架构：构建高可用的系统架构，采用主备、集群、分布式等方式实现故障容错和数据备份。通过合理的架构设计和备份策略，当某个节点或服务发生故障时，可以快速切换到备用节点或服务，保证服务的可用性和数据的可靠性。</li><li>队列和消息中间件：使用消息队列和消息中间件来解耦和异步处理高并发请求。将请求发送到队列中进行异步处理，保证数据操作的顺序和一致性。消息中间件还可以提供事务消息、可靠消息传递等特性，以确保数据的可靠传输和处理。</li><li>分布式一致性算法：采用一致性哈希、分布式锁、Paxos、Raft等分布式一致性算法来处理分布式环境下的数据一致性问题。这些算法可以实现在分布式系统中的协调和一致性保证。</li><li>异常处理和监控：及时捕获和处理异常，对于异常操作进行回滚或补偿操作，保证数据的一致性。同时，建立合适的监控系统，对系统和数据进行实时监测和报警，及时发现和处理潜在的问题。</li><li>数据备份和恢复：定期进行数据备份，并建立完备的数据恢复机制。可以采用灾备方案、冷备、热备、增量备份等方式进行数据备份，确保在数据丢失或损坏情况下可以进行快速的恢复。</li></ul></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/wiki/01.%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/%E6%9E%B6%E6%9E%84300%E8%AE%B2.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>架构300讲</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/wiki/markdown-examples.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>Markdown Examples</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"01.后端技术栈_java.md\":\"BYA3oC2s\",\"01.后端技术栈_kafka.md\":\"UuY9rLXq\",\"01.后端技术栈_lanmei-question.md\":\"Dzimh3QT\",\"01.后端技术栈_linux学习笔记.md\":\"C6nfssGN\",\"01.后端技术栈_netty.md\":\"COJZntj9\",\"01.后端技术栈_springboot.md\":\"LVVjmsBN\",\"01.后端技术栈_zookeeper.md\":\"oexH2QJb\",\"01.后端技术栈_公司技术栈.md\":\"T75YWD1k\",\"01.后端技术栈_单词.md\":\"VOfrAj8t\",\"01.后端技术栈_复习.md\":\"CLjUX7U5\",\"01.后端技术栈_学习目录.md\":\"dbq1NpP6\",\"01.后端技术栈_心路历程.md\":\"BFFOQvDN\",\"01.后端技术栈_架构300讲.md\":\"DZJelVnf\",\"01.后端技术栈_算法.md\":\"Dd8BfsI_\",\"01.后端技术栈_遇到的问题.md\":\"BgcAhm8K\",\"01.后端技术栈_面试.md\":\"BAiAYs3B\",\"01.后端技术栈_面试题.md\":\"BvcFAGp_\",\"02.前端技术栈_html.md\":\"DSgfiFiE\",\"02.前端技术栈_javascript.md\":\"DRkEv99b\",\"03.开发工具_idea快捷键.md\":\"D68Vc3ti\",\"03.开发工具_window.md\":\"GXPh8-dc\",\"03.开发工具_常用开发工具.md\":\"DLUfVXHA\",\"03.开发工具_常用开源项目.md\":\"DToDfYHr\",\"api-examples.md\":\"DRcpOulh\",\"index.md\":\"Baj4H64R\",\"markdown-examples.md\":\"vjmPFt3Y\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"笔记整理\",\"description\":\"日常笔记整理\",\"base\":\"/wiki/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":\"deep\",\"nav\":[{\"text\":\"Home\",\"link\":\"/\"},{\"text\":\"后端技术栈\",\"link\":\"/01.后端技术栈/Java.md\"},{\"text\":\"Examples\",\"link\":\"/markdown-examples\"}],\"sidebar\":[{\"text\":\"后端技术栈\",\"collapsed\":false,\"items\":[{\"text\":\"JAVA\",\"link\":\"/01.后端技术栈/Java.md\"},{\"text\":\"SpringBoot\",\"link\":\"/01.后端技术栈/SpringBoot.md\"},{\"text\":\"架构300讲\",\"link\":\"/01.后端技术栈/架构300讲.md\"},{\"text\":\"面试题\",\"link\":\"/01.后端技术栈/面试题.md\"}]},{\"text\":\"Examples\",\"items\":[{\"text\":\"Markdown Examples\",\"link\":\"/markdown-examples\"},{\"text\":\"Runtime API Examples\",\"link\":\"/api-examples\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>