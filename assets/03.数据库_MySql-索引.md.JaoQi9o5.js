import{_ as s,c as a,o as l,ah as n,aE as e,aF as t,aG as p,aH as r,aI as h,aJ as k,aK as o}from"./chunks/framework.Dgw6jcLr.js";const m=JSON.parse('{"title":"索引","description":"","frontmatter":{},"headers":[],"relativePath":"03.数据库/MySql-索引.md","filePath":"03.数据库/MySql-索引.md","lastUpdated":null}'),d={name:"03.数据库/MySql-索引.md"};function E(g,i,c,y,D,b){return l(),a("div",null,[...i[0]||(i[0]=[n(`<h1 id="索引" tabindex="-1">索引 <a class="header-anchor" href="#索引" aria-label="Permalink to “索引”">​</a></h1><h2 id="索引分类" tabindex="-1">索引分类 <a class="header-anchor" href="#索引分类" aria-label="Permalink to “索引分类”">​</a></h2><ol><li>主键索引：主键索引是一种特殊的索引类型，它是用于唯一标识每一行数据的索引，每个表只能有一个主键索引。</li><li>唯一索引：唯一索引是用来保证列的唯一性的索引，一个表可以有多个唯一索引。</li><li>普通索引：普通索引也叫非唯一索引，它是最常见的一种索引类型，可以加速查询和排序操作。</li><li>全文索引：全文索引是一种用于全文搜索的索引类型，能够对文本数据进行快速的模糊搜索和关键字搜索。</li><li>复合索引：复合索引也叫多列索引或联合索引，它是包含多个列的索引类型，能够加速多列查询和排序操作。</li><li>哈希索引：哈希索引是基于哈希表实现的索引类型，能够对等值查询进行高效的处理，但不支持范围查询和排序，MySQL 中 Memory 引擎中支持哈希索引。</li></ol><h2 id="优缺点分析" tabindex="-1">优缺点分析 <a class="header-anchor" href="#优缺点分析" aria-label="Permalink to “优缺点分析”">​</a></h2><p>索引的主要优点如下：</p><ol><li>提高查询效率：索引可以加速数据的检索速度，对于大量数据的表而言，使用索引可以大幅提高查询效率。</li><li>避免全表扫描：当没有索引时，数据库会进行全表扫描，而索引可以帮助避免全表扫描，加速查询。</li><li>增强数据的唯一性和完整性：可以通过在列上创建唯一索引和主键索引来确保表中的数据唯一性和完整性。</li></ol><p>索引的缺点如下：</p><ol><li>占用额外存储空间：每个索引都会占用额外的存储空间，因此在设计索引时需要权衡存储空间和查询效率之间的平衡。</li><li>降低写操作效率：索引的维护需要额外的写操作，因此在大量写操作的情况下可能会降低写操作的效率。</li><li>可能出现索引失效：索引并不是万能的，有些情况下使用索引可能会导致查询效率降低甚至出现索引失效的情况。例如，当对于一个非常小的表或者一个稠密的索引列进行查询时，使用索引可能并不会提高查询效率。</li><li>索引需要维护：随着表数据的不断变化，索引也需要不断维护以保持其效率。因此，在使用索引时需要注意索引的维护成本。</li></ol><h2 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to “应用场景”">​</a></h2><p>适合创建索引的场景有以下几个：</p><ol><li>频繁用于条件查询的列：如果一个列经常用于 WHERE、JOIN、ORDER BY 或 GROUP BY 子句中，那么可以考虑在该列上创建索引。</li><li>唯一性约束：对于需要保证唯一性的列，应该在该列上创建唯一索引或主键索引。</li><li>经常用于排序的列：对于需要经常进行排序的列，如 ORDER BY 子句中的列，应该在该列上创建索引。</li><li>经常用于聚合函数的列：对于经常用于聚合函数（如 COUNT、AVG、SUM、MIN、MAX）的列，应该在该列上创建索引，可以加速聚合查询。</li></ol><p>虽然索引可以提高查询效率，但有些情况下并不适合使用索引，比如以下这些：</p><ol><li>对于小表：如果表的数据量比较小，那么建立索引并不能带来很大的性能提升，反而会增加查询时间和占用存储空间。</li><li>对于多写少读的表：索引会增加写操作的时间，并占用更多的存储空间，因此对于频繁进行 INSERT、UPDATE 或 DELETE 操作的表，不宜过多地建立索引。</li></ol><p>总之，创建索引需要根据具体的情况进行权衡和取舍，只有在真正需要提高查询效率时才应该创建索引，否则会浪费存储空间和增加写操作的时间。</p><h2 id="覆盖索引" tabindex="-1">覆盖索引 <a class="header-anchor" href="#覆盖索引" aria-label="Permalink to “覆盖索引”">​</a></h2><p>是指索引本身包含了查询所需的所有字段，从而无需再回表查询的数据访问方式。这种优化能显著提升查询性能。</p><p><a href="https://www.cnblogs.com/eiffelzero/p/18607367" target="_blank" rel="noreferrer">https://www.cnblogs.com/eiffelzero/p/18607367</a></p><h2 id="聚簇索引和非聚簇索引" tabindex="-1">聚簇索引和非聚簇索引 <a class="header-anchor" href="#聚簇索引和非聚簇索引" aria-label="Permalink to “聚簇索引和非聚簇索引”">​</a></h2><p>聚簇索引（Clustered Index）也被称为聚集索引，在 InnoDB 存储引擎中，每个表只能有一个聚集索引，其余的索引都是非聚集索引（也称为二级索引）。</p><p>聚集索引是按照数据在磁盘上的物理顺序来组织数据的，其叶子节点保存着完整的数据行信息。InnoDB 中，如果表定义了主键，则主键索引是聚集索引；如果表没有定义主键，则第一个唯一非空索引是聚集索引；如果都没有，则 InnoDB 会隐式创建一个隐藏的聚集索引。</p><p>例如，我们创建一张 student 表，它的构建 SQL 如下：</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">drop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> exists</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> student;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">create</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> student</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> primary key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> varchar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    class_id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> not null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (class_id)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)engine</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">InnoDB;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 添加测试数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">insert into</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> student(id,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,class_id) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张三&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;李四&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">300</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;王五&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>以上 student 表中有一个聚簇索引（也就是主键索引）id，和一个非聚簇索引 class_id。 聚簇索引 id 对应存储结构如下图所示：</p><p><img src="`+e+'" alt=""></p><p>非聚集索引也叫二级索引，其叶子节点保存着索引字段和指向对应数据行的指针（相当于主键 ID），通过这个指针可以找到对应的数据行。在查询中，如果使用的是非聚集索引，则需要先根据索引查找到对应的行指针，再通过行指针查找数据行，这个过程叫做回表查询，因此他的查询速度相对于聚集索引要慢一些。</p><p>以上面 student 表为例，在 student 中非聚簇索引 class_id 对应存储结构如下图所示：</p><p><img src="'+t+'" alt=""></p><p>从上图我们可以看出，<strong>在非聚簇索引的叶子节点上存储的并不是真正的行数据，而是主键 ID，所以当我们使用非聚簇索引进行查询时，首先会得到一个主键 ID，然后再使用主键 ID 去聚簇索引上找到真正的行数据，所以查询速度要慢一些</strong>。</p><p><strong>聚簇索引 VS 非聚簇索引</strong></p><p>聚簇索引和非聚簇索引的区别主要有以下几点：</p><ol><li>存储数据不同：聚簇索引将数据行存储在与索引相同的 B+ 树结构中，而非聚簇索引是将索引和主键 ID 存储在 B+ 树结构中；</li><li>数量限制不同：一张表只能有一个聚簇索引，但可以有多个非聚簇索引；</li><li>索引更新不同：由于聚簇索引中的数据行与索引行是一一对应的，因此对于聚簇索引的任何更新都需要重新排列数据行的物理顺序。这可能会导致性能问题，特别是在高并发环境中，而非聚簇索引的更新不需要重新排列数据行的物理顺序，因为索引和数据行是分开存储的；</li><li>索引大小不同：由于聚簇索引中的数据行与索引行是一一对应的，因此聚簇索引的大小通常比非聚簇索引大，而非聚簇索引通常比较小，因为它们只存储索引不存储数据行；</li><li>范围查询不同：聚簇索引中的数据行与索引行是一一对应的，因此聚簇索引通常比非聚簇索引更适合范围查询，而非聚簇索引需要进行两次查找：首先查找索引，然后查找数据行，这可能会导致性能问题，特别是在大型表上进行范围查询时</li></ol><h2 id="在创建索引时一定会锁表吗" tabindex="-1">在创建索引时一定会锁表吗 <a class="header-anchor" href="#在创建索引时一定会锁表吗" aria-label="Permalink to “在创建索引时一定会锁表吗”">​</a></h2><p>因为在 MySQL 5.6 之前，创建索引时会锁表，所以，在早期 MySQL 版本中一定要在线上慎用，因为创建索引时会导致其他会话阻塞（select 查询命令除外）。</p><p>但这个问题，在 MySQL 5.6.7 版本中得到了改变，因为在 MySQL 5.6.7 中引入了 Online DDL 技术（在线 DDL 技术），它允许在创建索引时，不阻塞其他会话（所有的 DML 操作都可以一起并发执行）。</p><p><strong>什么是DDL</strong></p><p><strong>DDL（Data Definition Language，数据库定义语言）</strong>：用于定义和管理数据库的结构，它主要包括以下语句：</p><ul><li><strong>CREATE</strong>：用于创建数据库、表、索引、视图等对象。</li><li><strong>ALTER</strong>：用于修改数据库、表、索引、视图等已存在的对象的结构。</li><li><strong>DROP</strong>：用于删除数据库、表、索引、视图等对象。</li><li><strong>TRUNCATE</strong>：用于删除表中的所有数据，但保留表的结构。</li><li><strong>RENAME</strong>：用于重命名数据库、表等对象。</li></ul><p><strong>什么是 DML？</strong></p><p><strong>DML (Data Manipulation Language，数据操作语言)</strong>：用于查询和修改数据，它主要包括以下语句：</p><ul><li><strong>INSERT</strong>：用于向表中插入新的数据行。</li><li><strong>UPDATE</strong>：用于更新表中已存在的数据行。</li><li><strong>DELETE</strong>：用于删除表中的数据行。</li><li><strong>SELECT</strong>：用于从表中检索数据。虽然 SELECT 主要用于查询，但某些包含数据修改的扩展 SQL 功能（如 LIMIT、ORDER BY、GROUP BY 等）也属于 DML 的范畴。</li></ul><p><strong>什么是 Online DDL？</strong></p><p>Online DDL（Online Data Definition Language，在线数据定义语言）是指在数据库运行期间执行对表结构或其他数据库对象的更改操作，而不需要中断或阻塞其他正在进行的事务和查询。</p><p>Online DDL 官方介绍文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html" target="_blank" rel="noreferrer">https://dev.mysql.com/doc/refman/8.0/en/innodb-online-ddl-operations.html</a></p><h2 id="索引底层是如何实现的" tabindex="-1">索引底层是如何实现的 <a class="header-anchor" href="#索引底层是如何实现的" aria-label="Permalink to “索引底层是如何实现的”">​</a></h2><p>MySQL 中默认的存储引擎 InnoDB 的索引是使用 B+ 树实现的。B+ 树是一种多路搜索树，它的叶子节点存储了所有的数据行信息，叶子节点之间使用指针连接，方便范围查询和排序等操作，非叶子节点存储的是索引字段的值，这样就可以通过非叶子节点的索引值快速定位到叶子节点的数据了，索引的实现如下图所示：</p><p><img src="'+p+'" alt=""></p><h3 id="b-树优点分析" tabindex="-1">B+ 树优点分析 <a class="header-anchor" href="#b-树优点分析" aria-label="Permalink to “B+ 树优点分析”">​</a></h3><p><strong>1.查询效率</strong></p><p>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比即存索引又存记录的 B 树，B+ 树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O 次数会更少。</p><p><strong>2.插入和删除效率</strong></p><p>B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快， 比如下面这个动图是删除 B+ 树 0004 节点的过程，因为非叶子节点有 0004 的冗余节点，所以在删除的时候，树形结构变化很小：</p><p><img src="'+r+'" alt=""></p><p>B 树则不同，B 树没有冗余节点，删除节点的时候非常复杂，比如删除根节点中的数据，可能涉及复杂的树的变形，比如下面这个动图是删除 B 树根节点的过程：</p><p><img src="'+h+'" alt=""></p><p>B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且 B+ 树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。因此，B+ 树的插入和删除效率更高。</p><p><strong>3.范围查询</strong></p><p>因为 B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助，比如说我们想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间。</p><p>而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。</p><p>因此，存在大量范围检索的场景，适合使用 B+树。</p><h2 id="最左匹配原则" tabindex="-1">最左匹配原则 <a class="header-anchor" href="#最左匹配原则" aria-label="Permalink to “最左匹配原则”">​</a></h2><h3 id="什么是最左匹配原则" tabindex="-1">什么是最左匹配原则 <a class="header-anchor" href="#什么是最左匹配原则" aria-label="Permalink to “什么是最左匹配原则”">​</a></h3><p>最左匹配原则是指在复合索引（也叫联合索引），即由多个列组成的索引时，只有从索引的最左边的列开始查询，才能利用到该复合索引。</p><p>例如，如果有一个联合索引为 (col1, col2, col3)，那么只有按照以下顺序进行查询才能利用该索引：</p><ul><li>col1</li><li>col1, col2</li><li>col1, col2, col3</li></ul><p>而如果查询是这样的：</p><ul><li>col2</li><li>col2, col3</li></ul><p>则不能使用该复合索引。</p><h3 id="为什么必须要最左匹配" tabindex="-1">为什么必须要最左匹配 <a class="header-anchor" href="#为什么必须要最左匹配" aria-label="Permalink to “为什么必须要最左匹配”">​</a></h3><p>例如，我们以 (年龄,姓名,住址) 为联合索引，如下图所示：</p><p><img src="'+k+'" alt=""></p><p>此时只有我们使用了最左匹配原则：(年龄)或(年龄,姓名)或(年龄,姓名,住址) 才能顺利的找到对应的数据，否则将无法使用上图中的联合索引进行高效的查询了 。</p><h3 id="最左匹配的原理从索引结构解释一下" tabindex="-1">最左匹配的原理从索引结构解释一下 <a class="header-anchor" href="#最左匹配的原理从索引结构解释一下" aria-label="Permalink to “最左匹配的原理从索引结构解释一下”">​</a></h3><p><a href="https://www.zhihu.com/question/52536048/answer/3568300352" target="_blank" rel="noreferrer">https://www.zhihu.com/question/52536048/answer/3568300352</a></p><p>联合索引：先导列（最左边的列）选择区分度高的，同时也需要考虑查询命中率的问题。</p><p>在一定条件下可以不遵循最左前缀原则，Mysql8.0引入了index skip scan。a、b、c种where b=5也是会走索引的。</p><p>skip scan的限定条件：联合索引、单表查询不能使用DISTINCT 和GROUP BY 关键字、只能使用<code>覆盖索引（最大的限制）</code>查询条件必须是常量。</p><p>原理：使用了穷举法，有局限性，适用于区分度比较小的字段。</p><p>讲一下联合索引的最左前缀原则，为什么得最左匹配，不按照这个来为什么失效？</p><p>最左前缀原则就是只要查询的是联合索引的最左 N 个字段，就可以利用该联合索引来加速查询。 不按照最左匹配来为什么失效，其原因就在于联合索引的 B+ 树中的键值是排好序的。不过，这里指的排好序，其实是相对的，举个例子，有 (a, b, c) 联合索引，a 首先是排序好的，而 b 列是在 a 列排序的基础上做的排序，同样的 c 是在 a,b 有序的基础上做的排序。所以说，如果有 <code>where a = xxx order by b = xxx</code> 这种请求的话，是可以直接在这颗联合索引树上查出来的，不用对 b 列进行额外的排序；而如果是 <code>where a = xxx order by c = xxx</code> 这种请求的话，还需要额外对 c 列进行一次排序才行。 另外，如果有对 a,b,c 的联合条件查询的话，并且 a 是模糊匹配或者说是范围查询的话，其实并不能完全踩中联合索引（a,b,c），a 列右边的所有列都无法使用索引进行快速定位了。所以这个时候就需要进行回表判断。也就是说数据库会首先根据索引来查找记录，然后再根据 where 条件来过滤记录。 不过在 MySQL 5.6 中支持了索引下推 ICP，数据库在取出索引的同时，会根据 where 条件直接过滤掉不满足条件的记录，减少回表次数</p><h2 id="什么情况下会导致索引失效" tabindex="-1">什么情况下会导致索引失效 <a class="header-anchor" href="#什么情况下会导致索引失效" aria-label="Permalink to “什么情况下会导致索引失效”">​</a></h2><ol><li>未遵循最左匹配原则</li><li>使用列运算</li><li>使用函数方法</li><li>类型转换</li><li>使用 is not null</li><li>错误的模糊匹配</li><li>OR语句前后没有同时使用索引</li></ol><p>为了验证 MySQL 中哪些情况下会导致索引失效，我们可以借助 explain 执行计划来分析索引失效的具体场景。 explain 使用如下，只需要在查询的 SQL 前面添加上 explain 关键字即可，如下图所示：</p><p><img src="'+o+'" alt=""></p><p><strong>而以上查询结果的列中，我们最主要观察 key 这一列，key 这一列表示实际使用的索引，如果为 NULL 则表示未使用索引，反之则使用了索引。</strong></p><p>以上所有结果列说明如下：</p><ul><li>id — 选择标识符，id 越大优先级越高，越先被执行；</li><li>select_type — 表示查询的类型；</li><li>table — 输出结果集的表；</li><li>partitions — 匹配的分区；</li><li>type — 表示表的连接类型；</li><li>possible_keys — 表示查询时，可能使用的索引；</li><li><strong>key — 表示实际使用的索引；</strong></li><li>key_len — 索引字段的长度；</li><li>ref— 列与索引的比较；</li><li>rows — 大概估算的行数；</li><li>filtered — 按表条件过滤的行百分比；</li><li>Extra — 执行情况的描述和说明。</li></ul><p>其中最重要的就是 type 字段，type 值类型如下：</p><ul><li>all — 扫描全表数据；</li><li>index — 遍历索引；</li><li>range — 索引范围查找；</li><li>index_subquery — 在子查询中使用 ref；</li><li>unique_subquery — 在子查询中使用 eq_ref；</li><li>ref_or_null — 对 null 进行索引的优化的 ref；</li><li>fulltext — 使用全文索引；</li><li>ref — 使用非唯一索引查找数据；</li><li>eq_ref — 在 join 查询中使用主键或唯一索引关联；</li><li>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点。</li></ul>',88)])])}const u=s(d,[["render",E]]);export{m as __pageData,u as default};
