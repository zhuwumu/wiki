import{_ as s,c as a,o as l,ah as e,aD as t}from"./chunks/framework.Dgw6jcLr.js";const E=JSON.parse('{"title":"limit 100w，10为什么慢？如何优化？","description":"","frontmatter":{},"headers":[],"relativePath":"03.数据库/MySql-深度分页.md","filePath":"03.数据库/MySql-深度分页.md","lastUpdated":null}'),n={name:"03.数据库/MySql-深度分页.md"};function h(p,i,k,r,d,o){return l(),a("div",null,[...i[0]||(i[0]=[e(`<h1 id="limit-100w-10为什么慢-如何优化" tabindex="-1">limit 100w，10为什么慢？如何优化？ <a class="header-anchor" href="#limit-100w-10为什么慢-如何优化" aria-label="Permalink to “limit 100w，10为什么慢？如何优化？”">​</a></h1><h2 id="为什么limit越来越慢" tabindex="-1">为什么limit越来越慢？ <a class="header-anchor" href="#为什么limit越来越慢" aria-label="Permalink to “为什么limit越来越慢？”">​</a></h2><p>在数据库查询中，当使用 LIMIT x, y 分页查询时，如果 x 值越大，查询速度可能会变慢。<strong>这主要是因为数据库需要扫描和跳过 x 条记录才能返回 y 条结果。随着 x 的增加，需要扫描和跳过的记录数也增加，从而导致性能下降。</strong></p><blockquote><p>例如 limit 1000000,10 需要扫描 1000010 行数据，然后丢掉前面的 1000000 行记录，所以查询速度就会很慢。</p></blockquote><h2 id="优化手段" tabindex="-1">优化手段 <a class="header-anchor" href="#优化手段" aria-label="Permalink to “优化手段”">​</a></h2><p>对于 MySQL 深度分页比较典型的优化手段有以下两种：</p><ol><li><strong>起始 ID 定位法</strong>：使用最后查询的 ID 作为起始查询的 ID。</li><li><strong>索引覆盖+子查询</strong>。</li></ol><h2 id="_1-起始id定位法" tabindex="-1">1.起始ID定位法 <a class="header-anchor" href="#_1-起始id定位法" aria-label="Permalink to “1.起始ID定位法”">​</a></h2><p>起始 ID 定位法指的是 limit 查询时，指定起始 ID。而这个起始 ID 是上一次查询的最后一条 ID。例如上一次查询的最后一条数据的 ID 为 6800000，那我们就从 6800001 开始扫描表，直接跳过前面的 6800000 条数据，这样查询的效率就高了，具体实现 SQL 如下：</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, age, gender</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6800000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> -- 核心实现 SQL</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><blockquote><p>其中 id 字段为表的主键字段。</p></blockquote><h3 id="为什么起始id查询效率高呢" tabindex="-1">为什么起始ID查询效率高呢？ <a class="header-anchor" href="#为什么起始id查询效率高呢" aria-label="Permalink to “为什么起始ID查询效率高呢？”">​</a></h3><p>因此这种查询是以上一次查询的最后 ID 作为起始 ID 进行查询的，而上次的 ID 已经定位到具体的位置了，所以只需要遍历 B+ 树叶子节点的双向链表（主键索引的底层数据结构）就可以查询到后面的数据了，所以查询效率就比较高，如下图所示：</p><p><img src="`+t+`" alt=""></p><p>如果上次查询结果为 9，之后再查询时，只需要从 9 之后再遍历 N 条数据就能查询出结果了，所以效率就很高。</p><h3 id="优缺点分析" tabindex="-1">优缺点分析 <a class="header-anchor" href="#优缺点分析" aria-label="Permalink to “优缺点分析”">​</a></h3><p>这种查询方式，只适合一页一页的数据查询，例如手机 APP 中刷新闻时那种瀑布流方式。</p><p>但如果用户是跳着分页的，例如查询完第 1 页之后，直接查询第 250 页，那么这种实现方式就不行了。</p><h2 id="_2-索引覆盖-子查询" tabindex="-1">2.索引覆盖+子查询 <a class="header-anchor" href="#_2-索引覆盖-子查询" aria-label="Permalink to “2.索引覆盖+子查询”">​</a></h2><p>此时我们为了查询效率，可以使用索引覆盖加子查询的方式，具体实现如下。</p><p>假设，我们未优化前的 SQL 如下：</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, age, gender</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> person</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> createtime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">desc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><blockquote><p>在以上 SQL 中，createtime 字段创建了索引，但查询效率依然很慢，因为它要取出 100w 完整的数据，并需要读取大量的索引页，和进行频繁的回表查询，所以执行效率会很低。</p></blockquote><p>此时，我们可以做以下优化：</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SELECT p1.name, p1.age, p1.gender</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">FROM person p1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">JOIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SELECT id FROM person ORDER BY createtime desc LIMIT </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) AS p2 ON p1.id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p2.id;</span></span></code></pre></div><p>相比于优化前的 SQL，<strong>优化后的 SQL 将不需要频繁回表查询了</strong>，因为子查询中只查询主键 ID，这时可以使用索引覆盖来实现。那么子查询就可以先查询出一小部分主键 ID，再进行查询，这样就可以大大提升查询的效率了。</p><blockquote><p>索引覆盖（Index Coverage）是一种数据库查询优化技术，它指的是在执行查询时，数据库引擎可以直接从索引中获取所有需要的数据，而不需要再回表（访问主键索引或者表中的实际数据行）来获取额外的信息。这种方式可以减少磁盘 I/O 操作，从而提高查询性能</p></blockquote>`,27)])])}const c=s(n,[["render",h]]);export{E as __pageData,c as default};
