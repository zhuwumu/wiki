import{_ as i,c as l,o as e,ah as t,ai as r,aj as n,ak as o,al as s,am as d,an as h}from"./chunks/framework.DVT8N-ZV.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01.后端技术栈/JAVA基础.md","filePath":"01.后端技术栈/JAVA基础.md","lastUpdated":null}'),c={name:"01.后端技术栈/JAVA基础.md"};function p(u,a,b,m,g,k){return e(),l("div",null,[...a[0]||(a[0]=[t('<blockquote></blockquote><p><img src="'+r+'" alt=""></p><ol><li><p>Java三大特性：封装、继承、多态</p></li><li><p>运行多态时有3个条件：继承、覆盖（重写）、向上转型</p></li><li><p>Integer对象缓存池中，java默认大小-128~127。使用valueOf()，默认会从缓存池中获取</p></li><li><p>String类定义为final，因此不可以被继承。内部使用声明为final的char数组存储数据。不能变的好处：缓存hash值、String Pool的需要、安全性、天生线程安全。</p></li><li><p>Java的参数是值传递而不是引用传递。本质上是将对象的地址以值的的方式传递， 因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。但是改变对象的字段值，就会改变元对象的值，因为改变的是同一地址指向的内容。</p></li><li><p>抽象类abstract不能被直接实例化，只能实例化继承它的子类</p></li><li><p>使用对象作为hashset的值或hashMap的key时，要重写equals和hashcode，防止因判断hashcode值相同，导致重复</p></li><li><p>类的<strong>元数据</strong>存放在方法区。<strong>静态变量</strong>（被static修饰的变量）优先于对象加载，且加载一次，（又称类变量）并且被所有的实例对象共享，也存在方法区</p></li><li><p>static静态语句块在类初始化时运行一次</p></li><li><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p></li><li><p>两个对象==相等，则其hashcode一定相等，反之不一定成立。两个对象equals相等，则其hashcode一定相等，反之不一定成立。</p></li><li><p>clone是浅拷贝，对象重写clone()，实现cloneable接口</p></li><li><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConstantDesc</span></span></code></pre></div></li><li><p>collection：set、list、queue</p></li><li><p>Set：TreeSet(有序)、HashSet、LinkedHashSet</p></li><li><p>List：ArrayList、Vector(线程安全)、LinkedList</p></li><li><p>Queue：LinkedList（双向队列）、priorityQueue(优先队列)</p></li><li><p>Map：TreeMap(有序、基于红黑树、效率不如hashmap)、HashMap(基于hash表)、concurrentHashMap(线程安全)、LinkedHashMap(有序)</p></li><li><p>红黑树（TreeMap、1.8的HashMap[1.7是hash表，1.8 数组+链表+红黑树 ]，当链表中元素达到8个时，链表会转换为红黑树、 ConcurrentHashMap ）</p></li></ol><h2 id="java基础" tabindex="-1">JAVA基础 <a class="header-anchor" href="#java基础" aria-label="Permalink to “JAVA基础”">​</a></h2><h3 id="_1、wait-和sleep-有啥区别" tabindex="-1">1、wait()和sleep()有啥区别 <a class="header-anchor" href="#_1、wait-和sleep-有啥区别" aria-label="Permalink to “1、wait()和sleep()有啥区别”">​</a></h3><ul><li>wait()是object类的方法，当前线程等待，直到另一个线程调用该对象的notify()或notifyAll()，或者指定的时间已过。</li><li>sleep()是Thread()类的方法，使当前正在执行的线程以指定的毫秒数暂停。</li></ul><h3 id="_2、object类有哪些方法" tabindex="-1">2、Object类有哪些方法 <a class="header-anchor" href="#_2、object类有哪些方法" aria-label="Permalink to “2、Object类有哪些方法”">​</a></h3><ul><li>clone()</li><li>wait()</li><li>notify()</li><li>notifyAll()</li><li>equals()</li><li>hasCode()</li><li>getClass()</li><li>toStirng()</li></ul><h3 id="_4-讲一下equals-与hashcode-什么时候重写-为什么重写-怎么重写" tabindex="-1">4. 讲一下equals()与hashcode()，什么时候重写，为什么重写，怎么重写？ <a class="header-anchor" href="#_4-讲一下equals-与hashcode-什么时候重写-为什么重写-怎么重写" aria-label="Permalink to “4. 讲一下equals()与hashcode()，什么时候重写，为什么重写，怎么重写？”">​</a></h3><ul><li><p>重写equals时必需重写hashCode。</p></li><li><p>Map中key为自定义对象时，必需重写hashcode和equals。</p></li><li><p>Set中存储自定义对象时</p></li><li><p>原因就是以key是不重复的，底层是以hashcode值作为判断的，如果不重写，可能会重复，所以要重写。String已经重写了，所以可以愉快的</p></li></ul><h3 id="_5-java多态-如何实现-动态绑定" tabindex="-1">5.Java多态，如何实现？动态绑定 <a class="header-anchor" href="#_5-java多态-如何实现-动态绑定" aria-label="Permalink to “5.Java多态，如何实现？动态绑定”">​</a></h3><ul><li>重载和重写也是多态的一种形式，实现编译时多态。虚函数实现运行时多态</li><li>声明父类去接子类的实现</li></ul><h3 id="_6-java如何保证多线程安全-战略性观望-采用锁机制" tabindex="-1">6.Java如何保证多线程安全 -战略性观望，采用锁机制 <a class="header-anchor" href="#_6-java如何保证多线程安全-战略性观望-采用锁机制" aria-label="Permalink to “6.Java如何保证多线程安全 -战略性观望，采用锁机制”">​</a></h3><ul><li><p>阻塞同步，内置锁关键字synchronized</p></li><li><p>同步代码块</p></li><li><p>同步方法</p></li><li><p>使用Lock接口及其实现类</p></li><li><p>非阻塞同步，基于CAS操作。JUC下各种原子类，避免了因锁带来的性能开销。</p></li><li><p>使用线程安全的数据结构，courrentHashMap</p></li><li><p>使用volatile关键字，可以保证可见性，但是无法保证原子性，需要结合其他同步机制</p></li></ul><ol><li><h4 id="string-str-new-string-abc-创建了几个对象-为什么" tabindex="-1">String str = new String(&quot;abc&quot;);创建了几个对象，为什么？ <a class="header-anchor" href="#string-str-new-string-abc-创建了几个对象-为什么" aria-label="Permalink to “String str = new String(&quot;abc&quot;);创建了几个对象，为什么？”">​</a></h4><p>2个，&quot;abc&quot;本身创建在方法区的常量池，通过new又创建在堆中。</p><p><img src="'+n+'" alt="1703307877243"></p><p><img src="'+o+'" alt=""></p></li><li><h4 id="string可以被继承么" tabindex="-1">String可以被继承么？ <a class="header-anchor" href="#string可以被继承么" aria-label="Permalink to “String可以被继承么？”">​</a></h4><p>String是final的，不能被继承</p></li><li><h4 id="java类加载机制-到底能不能自己自定义java-lang-string类" tabindex="-1">java类加载机制：到底能不能自己自定义java.lang.String类 <a class="header-anchor" href="#java类加载机制-到底能不能自己自定义java-lang-string类" aria-label="Permalink to “java类加载机制：到底能不能自己自定义java.lang.String类”">​</a></h4><blockquote><p><a href="https://blog.csdn.net/liubenlong007/article/details/88574544" target="_blank" rel="noreferrer">https://blog.csdn.net/liubenlong007/article/details/88574544</a></p></blockquote><ul><li>不可以加载自定义的java.开头的任何类。JDK8+以上直接报警</li><li>因为JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写loadClass搜索类的算法。</li><li>如果不想打破双亲委派模型，那么只需要重写findClass方法即可。</li><li>如果想打破双亲委派模型，那么就重写整个loadClass方法。</li></ul></li><li><h4 id="main方法的作用域是什么-能否改变" tabindex="-1">main方法的作用域是什么，能否改变 <a class="header-anchor" href="#main方法的作用域是什么-能否改变" aria-label="Permalink to “main方法的作用域是什么，能否改变”">​</a></h4><p>public，不能改变。main()方法是虚拟机在调用。Java虚拟机需要调用类的main()方法，Java虚拟机和main()方法不在同一个类中，所以访问权限必须是public</p></li><li><h4 id="main-方法为什么是静态的-能不能改为非静态" tabindex="-1">main 方法为什么是静态的？能不能改为非静态？ <a class="header-anchor" href="#main-方法为什么是静态的-能不能改为非静态" aria-label="Permalink to “main 方法为什么是静态的？能不能改为非静态？”">​</a></h4><ul><li>JVM调用main()方法时不必创建对象，所以方法必须是public。如果为非静态，需要实例化他的类，在实例化时还得调用构造函数，如果这个类的构造函数有参数，那么届时就会出现歧义。</li></ul></li><li><h4 id="main-方法如何传递参数-传递参数的类型是什么-能不能改变该参数类型" tabindex="-1">main 方法如何传递参数？传递参数的类型是什么？能不能改变该参数类型？ <a class="header-anchor" href="#main-方法如何传递参数-传递参数的类型是什么-能不能改变该参数类型" aria-label="Permalink to “main 方法如何传递参数？传递参数的类型是什么？能不能改变该参数类型？”">​</a></h4><ul><li><p>String[]数组。不能改变，该数组中保存着执行java命令时传递给所运行的类的参数，接受参数。</p></li><li><p>Java应用程序是可以通过命令行接受参数传入的</p></li></ul></li><li><h4 id="main方法的返回值是void。因为它是入口-不需要任何返回值。" tabindex="-1">main方法的返回值是void。因为它是入口，不需要任何返回值。 <a class="header-anchor" href="#main方法的返回值是void。因为它是入口-不需要任何返回值。" aria-label="Permalink to “main方法的返回值是void。因为它是入口，不需要任何返回值。”">​</a></h4></li></ol><h3 id="匿名内部类、静态内部类" tabindex="-1">匿名内部类、静态内部类 <a class="header-anchor" href="#匿名内部类、静态内部类" aria-label="Permalink to “匿名内部类、静态内部类”">​</a></h3><h3 id="spring的bean有无状态" tabindex="-1">Spring的Bean有无状态 <a class="header-anchor" href="#spring的bean有无状态" aria-label="Permalink to “Spring的Bean有无状态”">​</a></h3><ul><li></li></ul><h3 id="java类加载机制-双亲委派模型的好处" tabindex="-1">java类加载机制？ 双亲委派模型的好处？ <a class="header-anchor" href="#java类加载机制-双亲委派模型的好处" aria-label="Permalink to “java类加载机制？ 双亲委派模型的好处？”">​</a></h3><h3 id="解释下hashmap的原理" tabindex="-1">解释下hashmap的原理 <a class="header-anchor" href="#解释下hashmap的原理" aria-label="Permalink to “解释下hashmap的原理”">​</a></h3><h2 id="集合" tabindex="-1">集合 <a class="header-anchor" href="#集合" aria-label="Permalink to “集合”">​</a></h2><ol><li><h4 id="容器包含map和collection。collection包含list、set-元素不重复-、queue" tabindex="-1">容器包含map和collection。collection包含list、set(元素不重复)、queue <a class="header-anchor" href="#容器包含map和collection。collection包含list、set-元素不重复-、queue" aria-label="Permalink to “容器包含map和collection。collection包含list、set(元素不重复)、queue”">​</a></h4><p><img src="'+s+'" alt="1703318795730"></p></li><li><h4 id="list遍历删除-不能直接使用remove-要使用iterator。原因是会导致-modcount-不准确" tabindex="-1">List遍历删除，不能直接使用remove，要使用iterator。原因是会导致 modCount 不准确 <a class="header-anchor" href="#list遍历删除-不能直接使用remove-要使用iterator。原因是会导致-modcount-不准确" aria-label="Permalink to “List遍历删除，不能直接使用remove，要使用iterator。原因是会导致 modCount 不准确”">​</a></h4></li><li><h4 id="list线程安全" tabindex="-1">List线程安全 <a class="header-anchor" href="#list线程安全" aria-label="Permalink to “List线程安全”">​</a></h4><ul><li><code>CopyOnWriteArrayList</code>读不加锁，写加锁并且复制副本，内存偏大，适合读多写少场景，比如缓存。</li><li><code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code>读写都加锁，适合读写均匀的场景。</li></ul></li></ol><h2 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to “线程”">​</a></h2><h3 id="线程的状态" tabindex="-1">线程的状态 <a class="header-anchor" href="#线程的状态" aria-label="Permalink to “线程的状态”">​</a></h3><p>新建（new）、可运行（Runnable）、阻塞（Blocking）、等待（限期等待、无限期等待）、终止（terminated）</p><p><img src="'+d+'" alt="1703317342878"></p><h3 id="lock和synchronized的区别" tabindex="-1">Lock和Synchronized的区别 <a class="header-anchor" href="#lock和synchronized的区别" aria-label="Permalink to “Lock和Synchronized的区别”">​</a></h3><blockquote><p><a href="https://www.zhihu.com/question/554622035/answer/2989085239" target="_blank" rel="noreferrer">https://www.zhihu.com/question/554622035/answer/2989085239</a></p></blockquote><ul><li><p>Synchronized通过使用<strong>内置锁</strong>、<strong>与对象关联的锁</strong>、<strong>可重入性</strong>、<strong>内存屏障</strong>等机制来实现线程的同步和锁的管理，以保证对共享资源的访问具有互斥性和可见性。</p></li><li><p>Lock使用<strong>条件变量</strong>（condition）来实现线程的等待和通知。 Condition接口提供了await()、signal()和signalAll()等方法，用于线程之间的等待和通知，从而避免了Object类中wait()和notify()方法可能出现的信号丢失问题。 比Synchronized提供了灵活性和扩展性。</p></li><li><p>Lock可以中断和设置超时</p></li><li><p>Lock可以获取锁的状态。</p></li><li><p>ReentrantLock()可重入锁。</p></li></ul><h3 id="synchronized的注意事项" tabindex="-1">Synchronized的注意事项 <a class="header-anchor" href="#synchronized的注意事项" aria-label="Permalink to “Synchronized的注意事项”">​</a></h3><ul><li>方法锁形式：Synchronized修饰<strong>普通方法</strong>，锁对象默认为this，实例对象。</li><li>Synchronized代码块默认是this，可以指定锁对象为class对象。</li><li>Synchronized修饰<strong>静态方法</strong>，默认的锁就是当前所在的class类，所以无论哪个线程去访问它，需要的锁都只有一把。</li><li>锁对象不能为空，因为锁的信息都保存在对象里头</li><li>作用域不易过大，影响程序执行速度，控制范围过大，编写代码也容易出错。有时也可以通过扩大作用域，提升性能，如StringBuffer</li><li>避免死锁</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错。</li></ul><h3 id="在-java-中-wait-和-sleep-方法的不同" tabindex="-1">在 java 中 wait 和 sleep 方法的不同？ <a class="header-anchor" href="#在-java-中-wait-和-sleep-方法的不同" aria-label="Permalink to “在 java 中 wait 和 sleep 方法的不同？”">​</a></h3><p>wait会释放锁，sleep会一直持有锁。wait通常用于线程间交互，sleep通常用于暂停执行。</p><h3 id="阻塞队列成员" tabindex="-1">阻塞队列成员 <a class="header-anchor" href="#阻塞队列成员" aria-label="Permalink to “阻塞队列成员”">​</a></h3><table tabindex="0"><thead><tr><th><strong>队列</strong></th><th><strong>有界性</strong></th><th><strong>锁</strong></th><th><strong>数据结构</strong></th><th>备注</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>bounded（有界）</td><td>加锁</td><td>arrayList</td><td>满了，会根据maximumPoolSize的值增加线程数量，如果增加了还是处理不过来，则会使用拒绝策略RejectedExecutionHandler，默认是AbortPolicy</td></tr><tr><td>LinkedBlockingQueue</td><td>optionally-bounded（可选-有界）</td><td>加锁</td><td>linkedList</td><td>无界队列，可以认为是一个无穷大的队列，可以无限存放任务。</td></tr><tr><td>PriorityBlockingQueue(优先)</td><td>unbounded（无界）</td><td>加锁</td><td>heap</td><td></td></tr><tr><td>DelayQueue</td><td>unbounded</td><td>加锁</td><td>heap</td><td>队列中元素顺序是按到期时间排序的，而非进入队列的顺序。最优的消费者线程的个数与任务启动的时间间隔好像存在这样的关系：单个任务处理时间的最大值　/ 相邻任务的启动时间最小间隔　＝　最优线程数，如果最优线程数是小数，则取整数后加１，比如1.3的话，那么最优线程数应该是2。</td></tr><tr><td>SynchronousQueue</td><td>bounded</td><td>加锁</td><td>无</td><td></td></tr><tr><td>LinkedTransferQueue</td><td>unbounded</td><td>加锁</td><td>heap</td><td></td></tr><tr><td>LinkedBlockingDeque</td><td>unbounded</td><td>加锁</td><td>heap</td><td></td></tr></tbody></table><h3 id="volatile的作用" tabindex="-1">volatile的作用 <a class="header-anchor" href="#volatile的作用" aria-label="Permalink to “volatile的作用”">​</a></h3><ul><li>保证多线程之间的可见性。</li><li>和CAS结合，保证原子性。</li></ul><h3 id="如何在两个线程之间共享数据" tabindex="-1">如何在两个线程之间共享数据? <a class="header-anchor" href="#如何在两个线程之间共享数据" aria-label="Permalink to “如何在两个线程之间共享数据?”">​</a></h3><p>由于多个线程对共享数据的访问存在竞争，因此需要合理的<strong>同步机制</strong>来确保数据的一致性和程序的正确性。</p><ol><li>使用共享变量。将一个变量声明为一个类的成员变量，使多个线程能够访问和修改它。为了确保数据一致性，通常需要使用同步机制来避免数据竞争，例如使用<code>synchronized</code>关键字或显示的锁（ReentrantLock）。</li><li>使用线程安全的集合。如<code>concurrentHashMap</code>、<code>CopyOnWriteArrayList</code>。</li><li>使用<code>wait()</code>和<code>notify()、await/signal/signalAll </code>方法可以实现线程之间的通信，从而实现数据共享。例如生产者-消费者模式就是经典的使用来实现线程之间协调的场景。</li><li>使用<code>BlockingQueue</code>。被用作共享数据的容器，生产者和消费者之间通过队列进行数据传递，<code>put()</code> 和<code>take()</code>方法会自动阻塞，确保数据的正确传递和同步。</li></ol><h3 id="生产者消费者模型的作用是什么" tabindex="-1">生产者消费者模型的作用是什么 <a class="header-anchor" href="#生产者消费者模型的作用是什么" aria-label="Permalink to “生产者消费者模型的作用是什么”">​</a></h3><ul><li>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率</li><li>解耦</li></ul><h3 id="concurrenthashmap的并发度是什么" tabindex="-1">ConcurrentHashMap的并发度是什么 <a class="header-anchor" href="#concurrenthashmap的并发度是什么" aria-label="Permalink to “ConcurrentHashMap的并发度是什么”">​</a></h3><p>是segment（部分）的大小，默认是16，也就意味着最多16条线程同时操作ConcurrentHashMap</p><h3 id="readwritelock是什么" tabindex="-1">ReadWriteLock是什么 <a class="header-anchor" href="#readwritelock是什么" aria-label="Permalink to “ReadWriteLock是什么”">​</a></h3><p>ReentrantReadWriteLock是 ReadWriteLock 接口的一个具体实现 ，实现了<strong>读写分离</strong>，读锁是共享的，写锁是独占的，提升了读写性能。</p><h3 id="写一个死锁的例子" tabindex="-1">写一个死锁的例子 <a class="header-anchor" href="#写一个死锁的例子" aria-label="Permalink to “写一个死锁的例子”">​</a></h3><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247483887&amp;idx=1&amp;sn=ab85965995bde2fb539aaa4b47e7e008&amp;chksm=eb5384d9dc240dcfa20ce9ceedcc8f6174337f74482b103d0b9fc363b5e6b6366e7ddc4590c7&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247483887&amp;idx=1&amp;sn=ab85965995bde2fb539aaa4b47e7e008&amp;chksm=eb5384d9dc240dcfa20ce9ceedcc8f6174337f74482b103d0b9fc363b5e6b6366e7ddc4590c7&amp;scene=21#wechat_redirect</a></p></blockquote><ul><li>两个线程里分别持有2个Object对象，lock1和lock2，这两个lock作为同步代码块的锁。</li><li>线程1的run()方法先获取lock1的锁，然后睡眠50毫秒（防止刚启动就直接获取了lock2的锁），获取lock2的锁。</li><li>线程2的run()方法先获取lock2的锁，再去获取lock1的锁。此时形成了死锁。</li></ul><h3 id="如何避免死锁" tabindex="-1">如何避免死锁？ <a class="header-anchor" href="#如何避免死锁" aria-label="Permalink to “如何避免死锁？”">​</a></h3><ul><li>顺序加锁。</li><li>获取锁时限。每个获取锁的时候加上时限，如果超时，则放弃该锁。</li><li>死锁检查。按线程间获取锁的关系检测线程间是否发生死锁，如果发生死锁就执行一定的策略，如终端线程或回滚操作等。</li></ul><ol><li><p><strong>简述一下线程的几种状态以及状态之间的转换</strong>。<a href="https://www.cnblogs.com/javastack/p/17639536.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/javastack/p/17639536.html</a></p><p>在 JVM 运行中，线程一共有 NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED 六种状态，这些状态对应 <code>Thread.State</code> 枚举类中的状态。</p><p><img src="'+h+'" alt="img"></p></li><li><p><strong>什么是线程安全，如何实现线程安全？</strong></p></li></ol><p>线程安全是指在多线程环境下，多个线程同时访问同一资源时，不会产生意外结果或导致数据出错的状态</p><ul><li><p>加锁。通过加锁机制控制对共享资源的访问，使得每次只有一个线程能够访问共享资源。Java中提供了synchronized关键字和Lock接口来实现加锁功能。</p></li><li><p>原子变量。 AtomicInteger和AtomicReference</p></li><li><p>线程安全的集合类 . ConcurrentHashMap和ConcurrentLinkedQueue</p></li><li><p>使用volatile关键字：当多个线程同时访问同一个变量时，使用volatile关键字可以确保该变量对所有线程可见，避免出现数据不一致问题。</p></li><li><p>线程封闭：将共享资源限定在单个线程内部，避免多个线程同时访问，也就不存在线程安全问题。</p></li><li><p>不可变对象：将对象设计成不可变的，可以避免线程安全问题。因为不可变对象的状态不会改变，因此多个线程同时访问该对象也不会出现问题</p></li></ul><p><strong>HashMap 的实现原理以及在什么情况下会发生扩容</strong></p><ul><li>1.7数组+链表</li><li>1.8数组+红黑树</li></ul><ol><li><p><strong>如何理解 Java 的反射机制，它有什么作用？</strong></p><p>Java中的反射机制（Reflection）是一种能够在运行时动态获取类的详细信息并操作类和对象的机制。反射允许程序在运行时检查和修改类的结构和行为</p><p>Java反射机制的用途</p><ul><li><p>动态类加载：反射可以在运行时加载类和创建类的实例，而不需要在编译时知道类的名称。这对于实现动态模块加载和插件机制非常有用。</p></li><li><p>获取类的信息：通过反射，程序可以在运行时获取类的结构信息，包括类的属性、方法、构造函数、父类和实现的接口等。</p></li><li><p>操作对象：反射可以在运行时访问和修改对象的属性、调用对象的方法，甚至可以创建新对象。这在框架和库中经常使用，比如Spring、Hibernate等。</p></li><li><p>动态代理：反射是Java动态代理机制的基础。动态代理允许在运行时创建一个代理对象，用来代理其他对象的行为，这对于AOP（面向方面编程）非常重要。</p></li><li><p>测试和调试：反射可以用于编写测试代码，比如JUnit中的测试框架，通过反射可以调用私有方法和访问私有属性，从而进行单元测试。</p></li></ul></li><li><p><strong>讲讲常见的设计模式，以及在实际项目中的应用</strong>。</p></li><li><p><strong>Spring 框架的核心概念有哪些？</strong></p><ul><li>IOC</li><li>AOP</li><li>DI</li></ul></li><li><p><strong>如何优化数据库查询性能？</strong></p><ul><li><p>使用索引</p></li><li><p>避免函数和表达式</p></li><li><p>缓存</p><p><strong>在高并发场景下，如何处理数据一致性问题？</strong></p></li></ul></li></ol><ul><li>事务管理：使用数据库事务来确保关键操作的原子性、一致性、隔离性和持久性。通过合理的事务设计和管理，对于涉及到多个数据操作的场景，可以保证数据的一致性。</li><li>数据库锁机制：使用数据库提供的锁机制来保证对共享资源的独占访问。通过合理使用行锁、表锁、悲观锁或乐观锁等方式，控制并发访问数据库的行为，保证数据的一致性和正确性。</li><li>幂等性设计：设计接口或操作具有幂等性，即对同一请求的多次执行只会产生一次结果影响。通过设计幂等性操作，可以避免因为同一请求的重复执行而导致的数据重复或不一致问题。</li><li>高可用架构：构建高可用的系统架构，采用主备、集群、分布式等方式实现故障容错和数据备份。通过合理的架构设计和备份策略，当某个节点或服务发生故障时，可以快速切换到备用节点或服务，保证服务的可用性和数据的可靠性。</li><li>队列和消息中间件：使用消息队列和消息中间件来解耦和异步处理高并发请求。将请求发送到队列中进行异步处理，保证数据操作的顺序和一致性。消息中间件还可以提供事务消息、可靠消息传递等特性，以确保数据的可靠传输和处理。</li><li>分布式一致性算法：采用一致性哈希、分布式锁、Paxos、Raft等分布式一致性算法来处理分布式环境下的数据一致性问题。这些算法可以实现在分布式系统中的协调和一致性保证。</li><li>异常处理和监控：及时捕获和处理异常，对于异常操作进行回滚或补偿操作，保证数据的一致性。同时，建立合适的监控系统，对系统和数据进行实时监测和报警，及时发现和处理潜在的问题。</li><li>数据备份和恢复：定期进行数据备份，并建立完备的数据恢复机制。可以采用灾备方案、冷备、热备、增量备份等方式进行数据备份，确保在数据丢失或损坏情况下可以进行快速的恢复。</li></ul>',58)])])}const _=i(c,[["render",p]]);export{v as __pageData,_ as default};
