import{_ as i,c as a,o as e,ah as l,aL as n,aM as p,aN as h,aO as t,aP as d}from"./chunks/framework.DVT8N-ZV.js";const b=JSON.parse('{"title":"MySql和Redis数据一致性","description":"","frontmatter":{},"headers":[],"relativePath":"03.数据库/Mysql和Redis数据一致性.md","filePath":"03.数据库/Mysql和Redis数据一致性.md","lastUpdated":null}'),k={name:"03.数据库/Mysql和Redis数据一致性.md"};function r(E,s,o,y,g,c){return e(),a("div",null,[...s[0]||(s[0]=[l('<h1 id="mysql和redis数据一致性" tabindex="-1">MySql和Redis数据一致性 <a class="header-anchor" href="#mysql和redis数据一致性" aria-label="Permalink to “MySql和Redis数据一致性”">​</a></h1><h2 id="一、谈谈一致性" tabindex="-1">一、谈谈一致性 <a class="header-anchor" href="#一、谈谈一致性" aria-label="Permalink to “一、谈谈一致性”">​</a></h2><ul><li><strong>强一致性</strong>：如果你的项目对缓存的要求是强一致性的，那么请不要使用缓存。这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大。读请求和写请求会串行化，串到一个内存队列里去，这样会大大增加系统的处理效率，吞吐量也会大大降低。</li><li><strong>弱一致性</strong>：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态。</li><li><strong>最终一致性</strong>：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型。一般情况下，高可用只确保最终一致性，不确保强一致性。</li></ul><h2 id="二、场景分析" tabindex="-1">二、场景分析 <a class="header-anchor" href="#二、场景分析" aria-label="Permalink to “二、场景分析”">​</a></h2><p>一份数据同时保存在数据库和Redis里面，当数据发生变化的时候，需要同时更新Redis和Mysql，由于更新操作是有先后顺序的，并且它并不像Mysql中的多表事务操作可以满足ACID的特性，所以就会出现数据一致性的问题。</p><h2 id="三、同步策略" tabindex="-1">三、同步策略 <a class="header-anchor" href="#三、同步策略" aria-label="Permalink to “三、同步策略”">​</a></h2><p>删除缓存，在高并发情况下，同一时间大量请求该条数据，第一条查询未完成写入缓存操作时，导致大量请求会直接打到数据库，造成数据库压力过大。</p><h3 id="_1、先更新数据库-再更新缓存-一般不考虑" tabindex="-1">1、先更新数据库，再更新缓存（一般不考虑） <a class="header-anchor" href="#_1、先更新数据库-再更新缓存-一般不考虑" aria-label="Permalink to “1、先更新数据库，再更新缓存（一般不考虑）”">​</a></h3><p>这个⽅案存在如下问题：</p><p>（1）如果先更新MySQL成功了，还未对Redis进⾏更新的间隙期，这时如果请求过来，读到的都是 Redis的更新前数据。</p><p>（2）如果先更新MySQL成功了，再更新Redis失败了的话，后⾯的请求读到的都是Redis的更新前数 据，并且后续的补救⽅案很难做。</p><p>补救⽅案⼀：为Redis更新失败，将MySQL中的对应数据也回滚了，以此达到两者数据的⼀致性。但 MySQL是主数据源，它代表的是数据的“权威性”，这样做显然并不合理。</p><p>补救⽅案⼆：通过Redis重试更新的⽅式进⾏补救。但如果重试也失败了，还要继续重试吗？是设置固定 的重试次数，还是⼀直重试到成功为⽌？ 另外，重试时间间隔设置多少？时间间隔设置⻓了，影响业务的时间也会变⻓；时间间隔设置短了，重 试成功率⼜会降低。这些其实都是问题。</p><p>（3）两个线程同时更新的并发问题。</p><h3 id="_2、先更新缓存-再更新数据库-一般不考虑" tabindex="-1">2、先更新缓存，再更新数据库（一般不考虑） <a class="header-anchor" href="#_2、先更新缓存-再更新数据库-一般不考虑" aria-label="Permalink to “2、先更新缓存，再更新数据库（一般不考虑）”">​</a></h3><p>这个⽅案，要⽐⽅案⼀的“先更新MySQL，再更新Redis”合理⼀些。原因在于更新完Redis的话，哪怕还 没更新MySQL，这时如果请求过来，读到的都是Redis更新后的新数据。 另外，先更新Redis成功，再更新MySQL失败，可以通过再删除Redis所对应的数据进⾏补救。</p><p>但其依然存在如下问题：</p><p>（1）如果先更新Redis成功了，再更新MySQL失败了的话，还未对Redis所对应的数据进⾏删除补救的 间隙期，这时如果请求过来，读到的都是Redis未⽣效的新数据。</p><p>（2）如果先更新Redis成功了，再更新MySQL失败了的话，然后再删除Redis对应的数据也失败的时 候，应该如何处理？如果通过重试机制继续进⾏删除Redis的话，⼜会⾯临之前说的重试次数和间隔期的 问题。</p><p>（3）两个线程同时更新的并发问题。</p><h3 id="_3、先更新数据库-再删除缓存" tabindex="-1">3、先更新数据库，再删除缓存 <a class="header-anchor" href="#_3、先更新数据库-再删除缓存" aria-label="Permalink to “3、先更新数据库，再删除缓存”">​</a></h3><p>这个⽅案可以解决“并发更新”的问题，但依然会存在下⾯的两个问题：</p><p>（1）如果先更新MySQL成功了，还未对Redis进⾏删除的间隙期，这时如果请求过来，读到的都是 Redis的删除前数据。</p><p>（2）如果先更新MySQL成功了，再删除Redis失败了的话，后⾯的请求读到的都是Redis的删除前数 据，并且后续的补救⽅案很难做。</p><h3 id="_4、先删除缓存-再更新数据库" tabindex="-1">4、先删除缓存，再更新数据库 <a class="header-anchor" href="#_4、先删除缓存-再更新数据库" aria-label="Permalink to “4、先删除缓存，再更新数据库”">​</a></h3><p>这个⽅案能解决⽅案3中遗留的两个棘⼿的问题：</p><p>（1）如果先删除Redis成功了，还未对MySQL进⾏更新的间隙期，此时对于该条数据⽽⾔，只存在于 MySQL⼀个存储载体中，也就没有了数据⼀致性的问题。</p><p>（2）如果先删除Redis成功了，再更新MySQL失败了的话，此时对于该条数据⽽⾔，只存在于MySQL ⼀个存储载体中，所谓的补救⽅案也就不需要了，直接当这条数据没更新成功。</p><p>OK，整体看起来似乎“天下⽆贼”了，但真的如此吗？其实不然，如果配合上Redis的“读策略”，还是会 有数据⼀致性的问题。</p><h4 id="_4-1-先删除redis-再更新mysql-redis读策略" tabindex="-1">4.1 先删除Redis，再更新MySQL + Redis读策略 <a class="header-anchor" href="#_4-1-先删除redis-再更新mysql-redis读策略" aria-label="Permalink to “4.1 先删除Redis，再更新MySQL + Redis读策略”">​</a></h4><p>Redis的读策略：</p><p>如果读取的数据在Redis中存在，则直接返回数据； 如果读取的数据在Redis中不存在，则从MySQL中读取数据，然后将数据写⼊到Redis，并返回数据。</p><p>这样⼀来，就会存在如下问题： 某商品的库存数为10个，⽤户A购买⼀件商品时进⾏库存扣减，因此第⼀步先删除了Redis中的库存数。 这时，⽤户B查询该商品的库存，发现Redis中并没有该商品的库存，于是从MySQL中读取库存数后，写 ⼊到了Redis中（10个）。 然后，⽤户A更新数据库，将库存数从10个扣减为9个。 最终，Redis中的库存数是10个，MySQL中的库存数是9个。</p><p><img src="'+n+'" alt=""></p><h4 id="_4-2-先删除redis-再更新mysql-binlog同步-不推荐" tabindex="-1">4.2 先删除Redis，再更新MySQL + Binlog同步 (不推荐) <a class="header-anchor" href="#_4-2-先删除redis-再更新mysql-binlog同步-不推荐" aria-label="Permalink to “4.2 先删除Redis，再更新MySQL + Binlog同步 (不推荐)”">​</a></h4><p>该⽅案将填充Redis的操作，改为通过DataBus和Canal同步Binlog的⽅式，这样可以解决⽅案4.1中的 Redis读策略带来的数据⼀致性问题。</p><p><img src="'+p+'" alt=""></p><p>但是，这种⽅案的适⽤于数据量不⼤，可以完全吃进Redis缓存中，并设置为永不过期的场景。 ⽽那种数据量庞⼤到不能全部吃进Redis缓存中，需要在数据读取的时机来写⼊Redis，⻓时间未被读取 的数据则过期淘汰的场景，就不适合了。 因为这种⽅案的缓存命中率太低了，也就失去了其应有的价值</p><h4 id="_4-3-先删除redis-再更新mysql-redis读策略-延时双删" tabindex="-1">4.3* 先删除Redis，再更新MySQL + Redis读策略 + 延时双删 <a class="header-anchor" href="#_4-3-先删除redis-再更新mysql-redis读策略-延时双删" aria-label="Permalink to “4.3* 先删除Redis，再更新MySQL + Redis读策略 + 延时双删”">​</a></h4><p>这个⽅案稍复杂了⼀些，是在⽅案4.1中“先删除Redis，再更新MySQL + Redis读策略”，⼜增加了最后 ⼀步Redis删除的操作。 它可以解决“最终，Redis中的库存数是10个，MySQL中的库存数是9个”的数据⼀致性场景。</p><p><img src="'+h+`" alt=""></p><p>也可以跟⽅案4.2中 “数据量庞⼤到不能全部吃进Redis缓存中，需要在数据读取的时机来写⼊Redis，⻓ 时间未被读取的数据则过期淘汰”的不适合场景进⾏互补。</p><p>有⼈会说，这种⽅案也不能100%保证解决数据⼀致性的问题，如果最后⼀步删除操作失败了怎么办？ 确实，它并不能保证100%。 但如果第⼀步删除Redis成功了，第⼆步Redis读策略恰好在这个间隙期发⽣并写⼊Redis成功了，⽽第三 步删除Redis⼜失败了，这种概率有多⼤？0.0000001%的可能性有没有？</p><h4 id="_5、延时双删" tabindex="-1">5、延时双删 <a class="header-anchor" href="#_5、延时双删" aria-label="Permalink to “5、延时双删”">​</a></h4><p>该方案还存在并发引发的一致性问题，假设同时有两个线程进行数据更新操作，如下图所示。当缓存被线程一删除后，如果此时有新的读请求（线程二）发生，由于缓存已经被删除，这个读请求（线程二）将会去从数据库查询。如果此时线程一还没有修改完数据库，线程二从数据库读的数据仍然是旧值，同时线程二将读的旧值写入到缓存。线程一完成后，数据库变为新值，而缓存还是旧值。当发生读/写并发时，还是存在数据不一致的情况。如何解决呢？最简单的解决办法就是<strong>延时双删策略</strong>：先淘汰缓存、再写数据库、休眠后再次淘汰缓存。这样做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deleteRedisData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UserInfo userInfo){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 删除Redis中的缓存数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    jedis.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">del</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userInfo);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 更新MySQL数据库数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    userInfoDao.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userInfo);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        TimeUnit.SECONDS.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Exception </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">exp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        exp.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printStackTrace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 删除Redis中的缓存数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    jedis.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">del</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userInfo);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>延时双删就能彻底解决不一致吗？当然不一定来。首先，我们评估的延时时间并不能完全代表实际运行过程中的耗时，运行过程如果因为系统压力过大，我们评估的耗时就是不准确，仍然会导致数据不一致的出现。其次，延时双删虽然在保证事务提交完以后再进行删除缓存，但是如果使用的是MySQL的读写分离的机构，主从同步之间其实也会有时间差。</p><h4 id="_6、-分布式锁" tabindex="-1">6、 分布式锁 <a class="header-anchor" href="#_6、-分布式锁" aria-label="Permalink to “6、 分布式锁”">​</a></h4><p>虽然分布式锁可以完全解决一致性问题，但影响性能。</p><h2 id="四、解决办法" tabindex="-1">四、解决办法 <a class="header-anchor" href="#四、解决办法" aria-label="Permalink to “四、解决办法”">​</a></h2><p>考虑一致性的时候，也要考虑是否需要解耦及场景的复杂性，根据场景要求，满足即可。</p><ol><li><p>先更新数据库，后删除缓存。但会导致同一时间高流量，容易直接打到数据库，有极大风险。</p></li><li><p>异步更新(异步通知)</p><p>在更新数据库数据时，同时发送一个异步通知给Redis，让Redis知道数据库数据已经更新，需要更新缓存中的数据。这个过程是异步的，不会阻塞数据库的更新操作。当Redis收到异步通知后，会立即删除缓存中对应的数据，确保缓存中没有旧数据。这样，即使在这个过程中有新的读请求发生，也不会读取到旧数据。等到数据库更新完成后，Redis再次从数据库中读取最新的数据并缓存起来。</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新MySQL</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">userMapper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(user);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 发送消息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">rabbitTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">convertAndSend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;updateUser&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * 然后在消息消费者中更新Redis。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RabbitListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">queues</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;updateUser&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> updateUser</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String userId) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    User user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> userMapper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">selectById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userId);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    redisTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">opsForValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(redisTemplate.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">opsForValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;user_&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), user);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这种异步通知的方式，可以确保Redis中的数据与数据库中的数据保持一致，避免出现数据不一致的情况。这种方案可以降低数据不一致的风险，但仍然无法完全避免。因为消息队列本身也可能因为各种原因丢失消息。</p></li><li><p>用 Redisson 实现读锁和写锁</p></li></ol><p>如果需要在极端情况下仍然去保证Redis和Mysql的数据一致性就只能采用最终一致性的一个方案</p><p><img src="`+t+'" alt=""></p><h3 id="基于rocketmq的可靠性通信" tabindex="-1">基于RocketMq的可靠性通信 <a class="header-anchor" href="#基于rocketmq的可靠性通信" aria-label="Permalink to “基于RocketMq的可靠性通信”">​</a></h3><ol><li>更新数据库的数据</li><li>更新redis的数据</li><li>失败的请求写入mq事务消息</li><li>异步重试，确保成功</li></ol><h3 id="基于canal组件" tabindex="-1">基于canal组件 <a class="header-anchor" href="#基于canal组件" aria-label="Permalink to “基于canal组件”">​</a></h3><ol><li>更新数据库的数据</li><li>更新redis的数据</li><li>从binlog加载数据</li><li>同步到Redis里面</li></ol><p>如果业务不能接受短期的不一致性，那么就不能这样的一个方案来实现</p><h3 id="基于binlog" tabindex="-1">基于binlog <a class="header-anchor" href="#基于binlog" aria-label="Permalink to “基于binlog”">​</a></h3><p>那如何能解决binlog监听时的数据乱序问题，并且有一定的容错机制保证缓存的最终一致性？</p><p>​ 如下图所示，我们基于之前的binlog监听方案新增了两处改动。</p><ol><li><p>通过监听消费binlog时记录binlog产生时间，并且每次对比binlog时间解决多线程消费的情况下，缓存和db数据最终不一致的问题；</p></li><li><p>由于每次update都会产生binlog，那么对于配置表的全表update（非业务字段，如set update_time=now()）即可完成数据全量更新同步至缓存，通过定时任务定时触发，这样就能给业务带来更高的容错性。</p><p><img src="'+d+'" alt=""></p></li></ol><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to “参考文章”">​</a></h2><ul><li><code>https://juejin.cn/post/7388033437173678090</code></li><li><code>https://juejin.cn/post/7050768976355262501</code></li><li><code>https://juejin.cn/post/7081921047578017828</code></li></ul>',65)])])}const u=i(k,[["render",r]]);export{b as __pageData,u as default};
