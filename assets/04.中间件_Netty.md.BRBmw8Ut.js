import{_ as i,c as r,o,aj as p,bO as l,bP as a,ak as t,bQ as n}from"./chunks/framework.Cy-ZmcqA.js";const y=JSON.parse('{"title":"netty","description":"","frontmatter":{},"headers":[],"relativePath":"04.中间件/Netty.md","filePath":"04.中间件/Netty.md","lastUpdated":1762179876000}'),h={name:"04.中间件/Netty.md"};function c(s,e,d,b,m,u){return o(),r("div",null,[...e[0]||(e[0]=[p('<h1 id="netty" tabindex="-1">netty <a class="header-anchor" href="#netty" aria-label="Permalink to “netty”">​</a></h1><p>要求掌握技术</p><ul><li>OOP编程</li><li>多线程</li><li>IO编程</li><li>网络编程</li><li>常用的JAVA设计模式（观察者模式、命令模式、职责链模式）</li><li>常用的数据结构（双向链表）</li></ul><p>在线文档文档，实战<a href="https://waylau.com/essential-netty-in-action/" target="_blank" rel="noreferrer">https://waylau.com/essential-netty-in-action/</a></p><h2 id="介绍一下自己对netty-的认识吧" tabindex="-1">介绍一下自己对Netty 的认识吧 <a class="header-anchor" href="#介绍一下自己对netty-的认识吧" aria-label="Permalink to “介绍一下自己对Netty 的认识吧”">​</a></h2><p>第一：Netty 是一个 基于 NIO 模型的高性能网络通信框架，其实可以认为它是对NIO网络模式。型的封装，提供了简单易用的 API，我们可以利用这些封装好的 API 快速开发自己的网络程序。</p><p>第二：Netty 在 NIO 的基础上做了很多优化，比如零拷贝机制、高性能无锁队列、内存池等，因此性能会比 NIO 更高。</p><p>第三：Netty 可以支持多种通信协议，如 Http、WebSocket 等，并且针对数据通信的拆包黏包问题，Netty 内置了拆包策略。</p><h2 id="那你再说说为什么要用netty" tabindex="-1">那你再说说为什么要用Netty <a class="header-anchor" href="#那你再说说为什么要用netty" aria-label="Permalink to “那你再说说为什么要用Netty”">​</a></h2><p>Nety 相比于直接使用 JDK 自带的 NIO 相关的 API 来说更加易用。同时，它还具有以下特点：</p><ol><li>统一的 API，支持多种传输类型，如阻塞、非阻塞，以及 epoll、poll 等模型。</li><li>我们可以使用非常少的代码来实现，多线程 Reactor 模型以及主从多线程Reactor 模型</li><li>自带编解码器解决 TCP 粘包/拆包问题。</li><li>自带各种协议栈。</li><li>比直接使用 Java 库中的 NIO API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制。</li><li>安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持。</li><li>社区活跃成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了Netty，比如我们经常接触的 Dubbo、RocketMQ 等等。</li></ol><h2 id="netty-核心组件了解吗-分别有什么作用" tabindex="-1">Netty 核心组件了解吗？分别有什么作用？ <a class="header-anchor" href="#netty-核心组件了解吗-分别有什么作用" aria-label="Permalink to “Netty 核心组件了解吗？分别有什么作用？”">​</a></h2><p>高手：Netty 由三层结构构成：网络通信层、事件调度器与服务编排层</p><p>在网络通信层有三个核心组件：Bootstrap、ServerBootStrap、Channel</p><p> Bootstrap 负责客户端启动并用来连接远程 netty server  ServerBootStrap 负责服务端监听，用来监听指定端口，</p><p> Channel 是负责网络通信的载体 事件调度器有两个核心组件：EventLoopGroup 与 EventLoop</p><p> EventLoopGroup 本质上是一个线程池，主要负责接收 I/O 请求，并分配线程执行处理请求。</p><p> EventLoop。相当于线程池中的线程 在服务编排层有三个核心组件 ChannelPipeline、ChannelHandler、ChannelHandlerContext ChannelPipeline 负责将多个 Channelhandler 连接在一起</p><p> ChannelHandler 针对 IO 数据的处理器，数据接收后，通过指定的Handler 进行处理。</p><p> ChannelHandlerContext 用来保存 ChannelHandler 的上下文信息</p><h2 id="面试官-那-再说说-netty-有几种线程模型吧" tabindex="-1">面试官：那，再说说 Netty 有几种线程模型吧？ <a class="header-anchor" href="#面试官-那-再说说-netty-有几种线程模型吧" aria-label="Permalink to “面试官：那，再说说 Netty 有几种线程模型吧？”">​</a></h2><p>高手 Netty 提供了三种 Reactor 模型的支持</p><p> 单线程单 Reactor 模型 咕泡科技出品,严禁商用</p><p> 多线程单 Reactor 模型</p><p> 多线程多 Reactor 模型</p><p>高手：Reactor 模型有三个重要的组件：</p><ol><li>Reactor ：将 I/O 事件发派给对应的 Handler</li><li>Acceptor ：处理客户端连接请求</li><li>Handlers ：执行非阻塞读/写 这是最基本的单 Reactor 单线程模型</li></ol><h1 id="netty-1" tabindex="-1">netty <a class="header-anchor" href="#netty-1" aria-label="Permalink to “netty”">​</a></h1><p>要求掌握技术</p><ul><li>OOP编程</li><li>多线程</li><li>IO编程</li><li>网络编程</li><li>常用的JAVA设计模式（观察者模式、命令模式、职责链模式）</li><li>常用的数据结构（双向链表）</li></ul><p>在线文档文档，实战<a href="https://waylau.com/essential-netty-in-action/" target="_blank" rel="noreferrer">https://waylau.com/essential-netty-in-action/</a></p><h2 id="netty详解" tabindex="-1">Netty详解 <a class="header-anchor" href="#netty详解" aria-label="Permalink to “Netty详解”">​</a></h2><p><a href="https://blog.csdn.net/golove666/article/details/137263541" target="_blank" rel="noreferrer">https://blog.csdn.net/golove666/article/details/137263541</a></p><h2 id="io模型" tabindex="-1">IO模型 <a class="header-anchor" href="#io模型" aria-label="Permalink to “IO模型”">​</a></h2><ul><li><p>BIO（阻塞），适用场景，连接数较少，代码简单，易于理解。</p><p><img src="'+l+'" alt="1720614498473"></p></li><li><p>NIO（同步非阻塞），连接数多且短，代码复杂</p><p><img src="'+a+'" alt="1720614577524"></p></li><li><p>AIO（异步非阻塞，暂未广泛使用），连接数多且长，代码复杂，相册服务器。</p></li></ul><h2 id="nio" tabindex="-1">NIO <a class="header-anchor" href="#nio" aria-label="Permalink to “NIO”">​</a></h2><p>面向缓冲区编程，事件驱动</p><ul><li>selectot</li><li>channel</li><li>buffer（容器对象，数组）</li></ul><h3 id="bytebuffer" tabindex="-1">ByteBuffer <a class="header-anchor" href="#bytebuffer" aria-label="Permalink to “ByteBuffer”">​</a></h3><p><img src="'+t+'" alt="1699669677755"></p><h3 id="channel" tabindex="-1">channel <a class="header-anchor" href="#channel" aria-label="Permalink to “channel”">​</a></h3><ul><li>FileChannel 的读和写都复制了2次</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><h3 id="selector" tabindex="-1">selector <a class="header-anchor" href="#selector" aria-label="Permalink to “selector”">​</a></h3><p><img src="'+n+'" alt="1699671228517"></p><p>为了实现Selector管理多个SocketChannel，必须将具体的SocketChannel对象注册到Selector，并声明需要监听的事件（这样Selector才知道需要记录什么数据），一共有4种事件：</p><ul><li>connetc：客户端连接服务器事件， 对应值为SelectionKey.OPCONNECT(8)</li><li>accept：服务端接收客户端连接事件，对应值为SelectionKey.OPACCEPT(16)</li><li>read：读事件 ，对应值为SelectionKey.OPREAD(1)</li><li>write：写事件，对应值为SelectionKey.OPWRITE(4)</li></ul><blockquote><p>参数调优</p></blockquote><p><a href="https://blog.csdn.net/weixin_44680802/article/details/128462846" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_44680802/article/details/128462846</a></p><p>针对ScoketChannel，7个，通过.childOption设置，常用的两个如下：</p><ul><li>SO_KEEPALIVE，tcp层keepalvie，默认关闭，一般选择关闭tcp keepalive 而使用应keepalive</li><li>TCP_NODELAY：设置是否启用nagle算法，该算法是tcp在发送数据时将小的、碎片化的数据拼接成一个大的报文一起发送，以此来提高效率，默认是false（启用），如果启用可能会导致有些数据有延时，如果业务不能忍受，小报文也需要立即发送则可以禁用该算法</li></ul><p>针对ServerScoketChannel，3个，通过.Option设置，常用的一个如下：</p><ul><li>.option(ChannelOption.SO_BACKLOG, 1024) // 等待最大连接数量</li><li>.childOption(ChannelOption.SO_KEEPALIVE, true) // 服务端开启tcp keepalive</li><li>.childOption(ChannelOption.TCP_NODELAY, true) // 关闭nagle算法，tcp发送小数据时，直接发送，不再拼装，减少延迟</li></ul><blockquote><p>出现io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1的原因及解决办法 <a href="http://www.manongjc.com/detail/21-cvkttljmlbmamsz.html" target="_blank" rel="noreferrer">http://www.manongjc.com/detail/21-cvkttljmlbmamsz.html</a></p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">msg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">release</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>从以上的分析文章中发现，SimpleChannelInboundHandler会自动释放内存（虽然这是一种软释放）即是refCnt引用数减一。</p><p>而本人在使用SimpleChannelInboundHandler作为Server端的时候，自己手动释放了一次msg的内存，导致refCnt引用数为0，这个时候框架试图去释放一</p><p>次，就报如上错误。释放代码如：</p><p>当然前提是你使用了SimpleChannelInboundHandler作为Handler处理事务，使用AbstractChannelInboundHandler是不会主动释放内容的，这个时候需要你自己手动释放一次。</p><blockquote><p>SimpleChannelInboundHandler和ChannelInboundHandlerAdapter区别<a href="https://www.pianshen.com/article/46501669845/" target="_blank" rel="noreferrer">https://www.pianshen.com/article/46501669845/</a></p></blockquote><ul><li>SimpleChannelInboundHandler继承ChannelInboundHandlerAdapter</li><li>SimpleChannelInboundHandler自动释放内存，ChannelInboundHandlerAdapter不自动释放</li><li>在Netty中客户端的Handler一般继承SimpleChannelInboundHandler抽象类，服务端Handler一般继承ChannelInboundHandlerAdapter抽象类</li><li>在客户端，当 channelRead0() 方法完成时，你已经有了传入消息，并且已经处理完它了。当该方法返回时，SimpleChannelInboundHandler负责释放指向保存该消息的ByteBuf的内存引用。</li><li>服务端：在EchoServerHandler中，你仍然需要将传入消息回送给发送者，而 write() 操作是异步的，直到 channelRead() 方法返回后可能仍然没有完成。为此，EchoServerHandler扩展了 ChannelInboundHandlerAdapter ，其在这个时间点上不会释放消息。</li></ul><blockquote><p>示例<a href="https://mp.weixin.qq.com/s/RPTETiULRAkOS-ZTd6xM2A" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/RPTETiULRAkOS-ZTd6xM2A</a></p></blockquote><h2 id="心跳demo" tabindex="-1">心跳demo <a class="header-anchor" href="#心跳demo" aria-label="Permalink to “心跳demo”">​</a></h2><p><a href="https://github.com/yongshun/some_java_code/tree/master/NettyHeartbeatDemo" target="_blank" rel="noreferrer">https://github.com/yongshun/some_java_code/tree/master/NettyHeartbeatDemo</a></p><h2 id="netty详解-1" tabindex="-1">Netty详解 <a class="header-anchor" href="#netty详解-1" aria-label="Permalink to “Netty详解”">​</a></h2><p><a href="https://blog.csdn.net/golove666/article/details/137263541" target="_blank" rel="noreferrer">https://blog.csdn.net/golove666/article/details/137263541</a></p><h2 id="io模型-1" tabindex="-1">IO模型 <a class="header-anchor" href="#io模型-1" aria-label="Permalink to “IO模型”">​</a></h2><ul><li><p>BIO（阻塞），适用场景，连接数较少，代码简单，易于理解。</p><p><img src="'+l+'" alt="1720614498473"></p></li><li><p>NIO（同步非阻塞），连接数多且短，代码复杂</p><p><img src="'+a+'" alt="1720614577524"></p></li><li><p>AIO（异步非阻塞，暂未广泛使用），连接数多且长，代码复杂，相册服务器。</p></li></ul><h2 id="nio-1" tabindex="-1">NIO <a class="header-anchor" href="#nio-1" aria-label="Permalink to “NIO”">​</a></h2><p>面向缓冲区编程，事件驱动</p><ul><li>selectot</li><li>channel</li><li>buffer（容器对象，数组）</li></ul><h3 id="bytebuffer-1" tabindex="-1">ByteBuffer <a class="header-anchor" href="#bytebuffer-1" aria-label="Permalink to “ByteBuffer”">​</a></h3><p><img src="'+t+'" alt="1699669677755"></p><h3 id="channel-1" tabindex="-1">channel <a class="header-anchor" href="#channel-1" aria-label="Permalink to “channel”">​</a></h3><ul><li>FileChannel 的读和写都复制了2次</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><h3 id="selector-1" tabindex="-1">selector <a class="header-anchor" href="#selector-1" aria-label="Permalink to “selector”">​</a></h3><p><img src="'+n+'" alt="1699671228517"></p><p>为了实现Selector管理多个SocketChannel，必须将具体的SocketChannel对象注册到Selector，并声明需要监听的事件（这样Selector才知道需要记录什么数据），一共有4种事件：</p><ul><li>connetc：客户端连接服务器事件， 对应值为SelectionKey.OPCONNECT(8)</li><li>accept：服务端接收客户端连接事件，对应值为SelectionKey.OPACCEPT(16)</li><li>read：读事件 ，对应值为SelectionKey.OPREAD(1)</li><li>write：写事件，对应值为SelectionKey.OPWRITE(4)</li></ul><blockquote><p>参数调优</p></blockquote><p><a href="https://blog.csdn.net/weixin_44680802/article/details/128462846" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_44680802/article/details/128462846</a></p><p>针对ScoketChannel，7个，通过.childOption设置，常用的两个如下：</p><ul><li>SO_KEEPALIVE，tcp层keepalvie，默认关闭，一般选择关闭tcp keepalive 而使用应keepalive</li><li>TCP_NODELAY：设置是否启用nagle算法，该算法是tcp在发送数据时将小的、碎片化的数据拼接成一个大的报文一起发送，以此来提高效率，默认是false（启用），如果启用可能会导致有些数据有延时，如果业务不能忍受，小报文也需要立即发送则可以禁用该算法</li></ul><p>针对ServerScoketChannel，3个，通过.Option设置，常用的一个如下：</p><ul><li>.option(ChannelOption.SO_BACKLOG, 1024) // 等待最大连接数量</li><li>.childOption(ChannelOption.SO_KEEPALIVE, true) // 服务端开启tcp keepalive</li><li>.childOption(ChannelOption.TCP_NODELAY, true) // 关闭nagle算法，tcp发送小数据时，直接发送，不再拼装，减少延迟</li></ul><blockquote><p>出现io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1的原因及解决办法 <a href="http://www.manongjc.com/detail/21-cvkttljmlbmamsz.html" target="_blank" rel="noreferrer">http://www.manongjc.com/detail/21-cvkttljmlbmamsz.html</a></p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">msg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">release</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>从以上的分析文章中发现，SimpleChannelInboundHandler会自动释放内存（虽然这是一种软释放）即是refCnt引用数减一。</p><p>而本人在使用SimpleChannelInboundHandler作为Server端的时候，自己手动释放了一次msg的内存，导致refCnt引用数为0，这个时候框架试图去释放一</p><p>次，就报如上错误。释放代码如：</p><p>当然前提是你使用了SimpleChannelInboundHandler作为Handler处理事务，使用AbstractChannelInboundHandler是不会主动释放内容的，这个时候需要你自己手动释放一次。</p><blockquote><p>SimpleChannelInboundHandler和ChannelInboundHandlerAdapter区别<a href="https://www.pianshen.com/article/46501669845/" target="_blank" rel="noreferrer">https://www.pianshen.com/article/46501669845/</a></p></blockquote><ul><li>SimpleChannelInboundHandler继承ChannelInboundHandlerAdapter</li><li>SimpleChannelInboundHandler自动释放内存，ChannelInboundHandlerAdapter不自动释放</li><li>在Netty中客户端的Handler一般继承SimpleChannelInboundHandler抽象类，服务端Handler一般继承ChannelInboundHandlerAdapter抽象类</li><li>在客户端，当 channelRead0() 方法完成时，你已经有了传入消息，并且已经处理完它了。当该方法返回时，SimpleChannelInboundHandler负责释放指向保存该消息的ByteBuf的内存引用。</li><li>服务端：在EchoServerHandler中，你仍然需要将传入消息回送给发送者，而 write() 操作是异步的，直到 channelRead() 方法返回后可能仍然没有完成。为此，EchoServerHandler扩展了 ChannelInboundHandlerAdapter ，其在这个时间点上不会释放消息。</li></ul><blockquote><p>示例<a href="https://mp.weixin.qq.com/s/RPTETiULRAkOS-ZTd6xM2A" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/RPTETiULRAkOS-ZTd6xM2A</a></p></blockquote><h2 id="心跳demo-1" tabindex="-1">心跳demo <a class="header-anchor" href="#心跳demo-1" aria-label="Permalink to “心跳demo”">​</a></h2><p><a href="https://github.com/yongshun/some_java_code/tree/master/NettyHeartbeatDemo" target="_blank" rel="noreferrer">https://github.com/yongshun/some_java_code/tree/master/NettyHeartbeatDemo</a></p>',95)])])}const f=i(h,[["render",c]]);export{y as __pageData,f as default};
