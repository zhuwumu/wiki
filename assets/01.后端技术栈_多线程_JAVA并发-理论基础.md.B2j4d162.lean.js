import{_ as i,c as a,a2 as e,o as t}from"./chunks/framework.6NRZc4eo.js";const h=JSON.parse('{"title":"JAVA并发-理论基础","description":"","frontmatter":{},"headers":[],"relativePath":"01.后端技术栈/多线程/JAVA并发-理论基础.md","filePath":"01.后端技术栈/多线程/JAVA并发-理论基础.md","lastUpdated":null}'),o={name:"01.后端技术栈/多线程/JAVA并发-理论基础.md"};function r(n,l,p,s,c,u){return t(),a("div",null,l[0]||(l[0]=[e('<h1 id="java并发-理论基础" tabindex="-1">JAVA并发-理论基础 <a class="header-anchor" href="#java并发-理论基础" aria-label="Permalink to &quot;JAVA并发-理论基础&quot;">​</a></h1><h3 id="并发出现问题的根源" tabindex="-1">并发出现问题的根源 <a class="header-anchor" href="#并发出现问题的根源" aria-label="Permalink to &quot;并发出现问题的根源&quot;">​</a></h3><ul><li>可见性：CPU缓存引起</li><li>原子性：多线程分时复用引起</li><li>有序性：指令重排引起</li></ul><h3 id="java是怎样解决并发问题的-jmm-java内存模型" tabindex="-1">JAVA是怎样解决并发问题的：JMM（JAVA内存模型） <a class="header-anchor" href="#java是怎样解决并发问题的-jmm-java内存模型" aria-label="Permalink to &quot;JAVA是怎样解决并发问题的：JMM（JAVA内存模型）&quot;">​</a></h3><ul><li>理解的第一个维度：核心知识点 <ul><li>volatile、final、 synchronized 三个关键字</li><li>8个Happens-Before规则 <ul><li>单一线程</li><li>管程锁定</li><li>volatile变量</li><li>线程start</li><li>线程join</li><li>线程interruption</li><li>对象终结finalize()</li><li>传递性</li></ul></li></ul></li><li>理解的第二个维度：可见性、原子性、有序性</li></ul><h3 id="线程安全-不是一个非真即假的命题" tabindex="-1">线程安全：不是一个非真即假的命题 <a class="header-anchor" href="#线程安全-不是一个非真即假的命题" aria-label="Permalink to &quot;线程安全：不是一个非真即假的命题&quot;">​</a></h3><ul><li><p>不可变</p><ul><li>final修饰的基本数据类型</li><li>String类</li><li>枚举</li><li>Number部分子类，如Long和Double等数值的包装类型，BigInteger和BigDecimal等大数据类型。但同为Number的原子类AtomicInteger和Atomic Long是可变的</li><li>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合</li></ul></li><li><p>绝对线程安全</p><p>不管运行时环境如何，调用者都不需要任何额外的同步措施。</p></li><li><p>相对线程安全</p><p>相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><p>在Java语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。</p></li><li><p>线程兼容</p><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p></li><li><p>线程独立</p><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免</p></li></ul><h3 id="线程安全的实现方法" tabindex="-1">线程安全的实现方法 <a class="header-anchor" href="#线程安全的实现方法" aria-label="Permalink to &quot;线程安全的实现方法&quot;">​</a></h3><ol><li><p>互斥同步</p><p>synchronized 和 ReentrantLock。</p></li><li><p>非阻塞同步</p><ul><li>CAS</li><li>AtomicInteger</li><li>ABA</li></ul></li><li><p>无同步方案</p><ul><li><p>栈封闭</p><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p></li><li><p>线程本地存储(Thread Local Storage)</p></li><li><p>可重入代码(Reentrant Code)</p></li></ul></li></ol>',9)]))}const A=i(o,[["render",r]]);export{h as __pageData,A as default};
