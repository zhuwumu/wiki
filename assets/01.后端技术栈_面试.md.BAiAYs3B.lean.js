import{_ as a,c as e,a0 as s,o as l}from"./chunks/framework.DNN_1AUP.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01.后端技术栈/面试.md","filePath":"01.后端技术栈/面试.md"}'),t={name:"01.后端技术栈/面试.md"};function p(n,i,h,o,r,c){return l(),e("div",null,i[0]||(i[0]=[s('<ol><li><p>Java三大特性：封装、继承、多态</p></li><li><p>运行多态时有3个条件：继承、覆盖（重写）、向上转型</p></li><li><p>Integer对象缓存池中，java默认大小-128~127。使用valueOf()，默认会从缓存池中获取</p></li><li><p>String类定义为final，因此不可以被继承。内部使用声明为final的char数组存储数据。不能变的好处：缓存hash值、String Pool的需要、安全性、天生线程安全。</p></li><li><p>Java的参数是值传递而不是引用传递。本质上是将对象的地址以值的的方式传递， 因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。但是改变对象的字段值，就会改变元对象的值，因为改变的是同一地址指向的内容。</p></li><li><p>抽象类abstract不能被直接实例化，只能实例化继承它的子类</p></li><li><p>使用对象作为hashset的值或hashMap的key时，要重写equals和hashcode，防止因判断hashcode值相同，导致重复</p></li><li><p>类的<strong>元数据</strong>存放在方法区。<strong>静态变量</strong>（被static修饰的变量）优先于对象加载，且加载一次，（又称类变量）并且被所有的实例对象共享，也存在方法区</p></li><li><p>static静态语句块在类初始化时运行一次</p></li><li><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p></li><li><p>两个对象==相等，则其hashcode一定相等，反之不一定成立。两个对象equals相等，则其hashcode一定相等，反之不一定成立。</p></li><li><p>clone是浅拷贝，对象重写clone()，实现cloneable接口</p></li><li></li><li><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConstantDesc</span></span></code></pre></div></li><li></li><li><p>collection：set、list、queue</p></li><li><p>Set：TreeSet(有序)、HashSet、LinkedHashSet</p></li><li><p>List：ArrayList、Vector(线程安全)、LinkedList</p></li><li><p>Queue：LinkedList（双向队列）、priorityQueue(优先队列)</p></li><li><p>Map：TreeMap(有序、基于红黑树、效率不如hashmap)、HashMap(基于hash表)、concurrentHashMap(线程安全)、LinkedHashMap(有序)</p></li><li><p>红黑树（TreeMap、1.8的HashMap[1.7是hash表，1.8 数组+链表+红黑树 ]，当链表中元素达到8个时，链表会转换为红黑树、 ConcurrentHashMap ）</p></li></ol>',1)]))}const u=a(t,[["render",p]]);export{k as __pageData,u as default};
