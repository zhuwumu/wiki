import{_ as a}from"./chunks/1699669677755.B4FROfId.js";import{_ as l,c as s,a2 as e,o as t}from"./chunks/framework.6NRZc4eo.js";const n="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1703307877243.png",r="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1.jpg",p="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1703318795730.png",h="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1703317342878.png",o="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1703511759538.png",d="/wiki/images/%E9%9D%A2%E8%AF%95%E9%A2%98/1218593-20230818092917421-1372614659.png",A=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01.后端技术栈/JAVA基础.md","filePath":"01.后端技术栈/JAVA基础.md","lastUpdated":null}'),c={name:"01.后端技术栈/JAVA基础.md"};function k(u,i,g,E,b,m){return t(),s("div",null,i[0]||(i[0]=[e('<blockquote></blockquote><p><img src="'+a+'" alt=""></p><ol><li><p>Java三大特性：封装、继承、多态</p></li><li><p>运行多态时有3个条件：继承、覆盖（重写）、向上转型</p></li><li><p>Integer对象缓存池中，java默认大小-128~127。使用valueOf()，默认会从缓存池中获取</p></li><li><p>String类定义为final，因此不可以被继承。内部使用声明为final的char数组存储数据。不能变的好处：缓存hash值、String Pool的需要、安全性、天生线程安全。</p></li><li><p>Java的参数是值传递而不是引用传递。本质上是将对象的地址以值的的方式传递， 因此在方法中改变指针引用的对象，那么这两个指针此时指向的是完全不同的对象，一方改变其所指向对象的内容对另一方没有影响。但是改变对象的字段值，就会改变元对象的值，因为改变的是同一地址指向的内容。</p></li><li><p>抽象类abstract不能被直接实例化，只能实例化继承它的子类</p></li><li><p>使用对象作为hashset的值或hashMap的key时，要重写equals和hashcode，防止因判断hashcode值相同，导致重复</p></li><li><p>类的<strong>元数据</strong>存放在方法区。<strong>静态变量</strong>（被static修饰的变量）优先于对象加载，且加载一次，（又称类变量）并且被所有的实例对象共享，也存在方法区</p></li><li><p>static静态语句块在类初始化时运行一次</p></li><li><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p></li><li><p>两个对象==相等，则其hashcode一定相等，反之不一定成立。两个对象equals相等，则其hashcode一定相等，反之不一定成立。</p></li><li><p>clone是浅拷贝，对象重写clone()，实现cloneable接口</p></li><li></li><li><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sealed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConstantDesc</span></span></code></pre></div></li><li></li><li><p>collection：set、list、queue</p></li><li><p>Set：TreeSet(有序)、HashSet、LinkedHashSet</p></li><li><p>List：ArrayList、Vector(线程安全)、LinkedList</p></li><li><p>Queue：LinkedList（双向队列）、priorityQueue(优先队列)</p></li><li><p>Map：TreeMap(有序、基于红黑树、效率不如hashmap)、HashMap(基于hash表)、concurrentHashMap(线程安全)、LinkedHashMap(有序)</p></li><li><p>红黑树（TreeMap、1.8的HashMap[1.7是hash表，1.8 数组+链表+红黑树 ]，当链表中元素达到8个时，链表会转换为红黑树、 ConcurrentHashMap ）</p></li></ol><h2 id="java基础" tabindex="-1">JAVA基础 <a class="header-anchor" href="#java基础" aria-label="Permalink to &quot;JAVA基础&quot;">​</a></h2><h3 id="_1、wait-和sleep-有啥区别" tabindex="-1">1、wait()和sleep()有啥区别 <a class="header-anchor" href="#_1、wait-和sleep-有啥区别" aria-label="Permalink to &quot;1、wait()和sleep()有啥区别&quot;">​</a></h3><ul><li>wait()是object类的方法，当前线程等待，直到另一个线程调用该对象的notify()或notifyAll()，或者指定的时间已过。</li><li>sleep()是Thread()类的方法，使当前正在执行的线程以指定的毫秒数暂停。</li></ul><h3 id="_2、object类有哪些方法" tabindex="-1">2、Object类有哪些方法 <a class="header-anchor" href="#_2、object类有哪些方法" aria-label="Permalink to &quot;2、Object类有哪些方法&quot;">​</a></h3><ul><li>clone()</li><li>wait()</li><li>notify()</li><li>notifyAll()</li><li>equals()</li><li>hasCode()</li><li>getClass()</li><li>toStirng()</li></ul><h3 id="_4-讲一下equals-与hashcode-什么时候重写-为什么重写-怎么重写" tabindex="-1">4. 讲一下equals()与hashcode()，什么时候重写，为什么重写，怎么重写？ <a class="header-anchor" href="#_4-讲一下equals-与hashcode-什么时候重写-为什么重写-怎么重写" aria-label="Permalink to &quot;4. 讲一下equals()与hashcode()，什么时候重写，为什么重写，怎么重写？&quot;">​</a></h3><ul><li><p>重写equals时必需重写hashCode。</p></li><li><p>Map中key为自定义对象时，必需重写hashcode和equals。</p></li><li><p>Set中存储自定义对象时</p></li><li><p>原因就是以key是不重复的，底层是以hashcode值作为判断的，如果不重写，可能会重复，所以要重写。String已经重写了，所以可以愉快的</p></li></ul><h3 id="_5-java多态-如何实现-动态绑定" tabindex="-1">5.Java多态，如何实现？动态绑定 <a class="header-anchor" href="#_5-java多态-如何实现-动态绑定" aria-label="Permalink to &quot;5.Java多态，如何实现？动态绑定&quot;">​</a></h3><ul><li>重载和重写也是多态的一种形式，实现编译时多态。虚函数实现运行时多态</li><li>声明父类去接子类的实现</li></ul><h3 id="_6-java如何保证多线程安全-战略性观望-采用锁机制" tabindex="-1">6.Java如何保证多线程安全 -战略性观望，采用锁机制 <a class="header-anchor" href="#_6-java如何保证多线程安全-战略性观望-采用锁机制" aria-label="Permalink to &quot;6.Java如何保证多线程安全 -战略性观望，采用锁机制&quot;">​</a></h3><ul><li><p>阻塞同步，内置锁关键字synchronized</p></li><li><p>同步代码块</p></li><li><p>同步方法</p></li><li><p>使用Lock接口及其实现类</p></li><li><p>非阻塞同步，基于CAS操作。JUC下各种原子类，避免了因锁带来的性能开销。</p></li><li><p>使用线程安全的数据结构，courrentHashMap</p></li><li><p>使用volatile关键字，可以保证可见性，但是无法保证原子性，需要结合其他同步机制</p></li></ul><h3 id="_7-i-o多路复用讲一下-epoll优势在哪-为什么-epoll水平触发-lt-与边缘触发-et" tabindex="-1">7.I/O多路复用讲一下，epoll优势在哪，为什么，epoll水平触发（LT）与边缘触发(ET) <a class="header-anchor" href="#_7-i-o多路复用讲一下-epoll优势在哪-为什么-epoll水平触发-lt-与边缘触发-et" aria-label="Permalink to &quot;7.I/O多路复用讲一下，epoll优势在哪，为什么，epoll水平触发（LT）与边缘触发(ET)&quot;">​</a></h3><ul><li>select 、poll、epoll接口，并非堵塞在IO上，而是在其中一个系统上，堵塞于select调用，等待数据报套接字变为可读，select监听所有注册好的IO，优点可以等待多个描述符就绪</li><li>select和poll采用<strong>轮训</strong>的方式检查就绪事件，每次都扫描整个文件描述符，复杂度O(n)</li><li>epoll采用<strong>回调</strong>方式检查就绪事件，复杂度O(1)</li><li>select只工作在低效的LT模式，epoll可以工作在高效的ET模式</li><li>epoll是linux特有，select是规定，一般操作系统都有</li><li>select单个进程监听端口有限，64位是2048个，epoll没有最大并发连接限制，1G大约监听10万个端口</li><li>select内核需要将消息传递到用户空间，都需要内核拷贝动作；epoll通过内核和用户空间共享一块内存来实现</li></ul><ol><li><h4 id="string-str-new-string-abc-创建了几个对象-为什么" tabindex="-1">String str = new String(&quot;abc&quot;);创建了几个对象，为什么？ <a class="header-anchor" href="#string-str-new-string-abc-创建了几个对象-为什么" aria-label="Permalink to &quot;String str = new String(&quot;abc&quot;);创建了几个对象，为什么？&quot;">​</a></h4><p>2个，&quot;abc&quot;本身创建在方法区的常量池，通过new又创建在堆中。</p><p><img src="'+n+'" alt="1703307877243"></p><p><img src="'+r+'" alt=""></p></li><li><h4 id="string可以被继承么" tabindex="-1">String可以被继承么？ <a class="header-anchor" href="#string可以被继承么" aria-label="Permalink to &quot;String可以被继承么？&quot;">​</a></h4><p>String是final的，不能被继承</p></li><li><h4 id="java类加载机制-到底能不能自己自定义java-lang-string类" tabindex="-1">java类加载机制：到底能不能自己自定义java.lang.String类 <a class="header-anchor" href="#java类加载机制-到底能不能自己自定义java-lang-string类" aria-label="Permalink to &quot;java类加载机制：到底能不能自己自定义java.lang.String类&quot;">​</a></h4><blockquote><p><a href="https://blog.csdn.net/liubenlong007/article/details/88574544" target="_blank" rel="noreferrer">https://blog.csdn.net/liubenlong007/article/details/88574544</a></p></blockquote><ul><li>不可以加载自定义的java.开头的任何类。JDK8+以上直接报警</li><li>因为JDK已经在loadClass方法中帮我们实现了ClassLoader搜索类的算法，当在loadClass方法中搜索不到类时，loadClass方法就会调用findClass方法来搜索类，所以我们只需重写该方法即可。如没有特殊的要求，一般不建议重写loadClass搜索类的算法。</li><li>如果不想打破双亲委派模型，那么只需要重写findClass方法即可。</li><li>如果想打破双亲委派模型，那么就重写整个loadClass方法。</li></ul></li><li><h4 id="main方法的作用域是什么-能否改变" tabindex="-1">main方法的作用域是什么，能否改变 <a class="header-anchor" href="#main方法的作用域是什么-能否改变" aria-label="Permalink to &quot;main方法的作用域是什么，能否改变&quot;">​</a></h4><p>public，不能改变。main()方法是虚拟机在调用。Java虚拟机需要调用类的main()方法，Java虚拟机和main()方法不在同一个类中，所以访问权限必须是public</p></li><li><h4 id="main-方法为什么是静态的-能不能改为非静态" tabindex="-1">main 方法为什么是静态的？能不能改为非静态？ <a class="header-anchor" href="#main-方法为什么是静态的-能不能改为非静态" aria-label="Permalink to &quot;main 方法为什么是静态的？能不能改为非静态？&quot;">​</a></h4><ul><li>JVM调用main()方法时不必创建对象，所以方法必须是public。如果为非静态，需要实例化他的类，在实例化时还得调用构造函数，如果这个类的构造函数有参数，那么届时就会出现歧义。</li><li></li></ul></li><li><h4 id="main-方法如何传递参数-传递参数的类型是什么-能不能改变该参数类型" tabindex="-1">main 方法如何传递参数？传递参数的类型是什么？能不能改变该参数类型？ <a class="header-anchor" href="#main-方法如何传递参数-传递参数的类型是什么-能不能改变该参数类型" aria-label="Permalink to &quot;main 方法如何传递参数？传递参数的类型是什么？能不能改变该参数类型？&quot;">​</a></h4><ul><li><p>String[]数组。不能改变，该数组中保存着执行java命令时传递给所运行的类的参数，接受参数。</p></li><li><p>Java应用程序是可以通过命令行接受参数传入的</p></li></ul></li><li><h4 id="main方法的返回值是void。因为它是入口-不需要任何返回值。" tabindex="-1">main方法的返回值是void。因为它是入口，不需要任何返回值。 <a class="header-anchor" href="#main方法的返回值是void。因为它是入口-不需要任何返回值。" aria-label="Permalink to &quot;main方法的返回值是void。因为它是入口，不需要任何返回值。&quot;">​</a></h4></li><li></li></ol><h3 id="匿名内部类、静态内部类" tabindex="-1">匿名内部类、静态内部类 <a class="header-anchor" href="#匿名内部类、静态内部类" aria-label="Permalink to &quot;匿名内部类、静态内部类&quot;">​</a></h3><h3 id="spring的bean有无状态" tabindex="-1">Spring的Bean有无状态 <a class="header-anchor" href="#spring的bean有无状态" aria-label="Permalink to &quot;Spring的Bean有无状态&quot;">​</a></h3><h3 id="threadlocal" tabindex="-1">ThreadLocal <a class="header-anchor" href="#threadlocal" aria-label="Permalink to &quot;ThreadLocal&quot;">​</a></h3><p>存储多线程之间的局部变量，空间换时间，内部threadlocalMap维护。 在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。</p><h3 id="事务失效的情况" tabindex="-1">事务失效的情况 <a class="header-anchor" href="#事务失效的情况" aria-label="Permalink to &quot;事务失效的情况&quot;">​</a></h3><ul><li>1、方法不是public。spring要求被代理方法必须是public的</li><li>2、方法用final修饰。Spring事务底层使用了aop，也就是通过jdk或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。final的方法，在它的代理类中，无法重写该方法，无法添加事务功能。</li><li>3、方法内部调用。内部调用其实是通过this来调用的。如果要解决，就将这个service通过Autowired本身进行注入。</li><li>4、未被Spring管理</li><li>5、多线程调用。Spring的事务是通过数据库连接来实现的。当前线程中保存了一个map&lt;数据源，数据库连接&gt;。线程间的数据是隔离的，如果用多线程去调用另一个方法的话，就会产生多分ThreadLocal，从而产生多个数据库连接，数据库也就不一样了。同一个事务，是指同一个数据库连接，只有拥有同一个数据库连接，才能同时提交和回滚。</li><li>6、表不支持事务</li><li>7、未开启事务。Spring是需要通过xml去配置的。Springboot是默认开启事务的。</li><li><strong>事务未回滚</strong></li><li>8、错误的传播特性</li><li>9、自己吞了异常，开发者在代码中手动try...catch了异常</li><li>10、手动抛了别的异常</li><li>11、自定义了回滚异常</li><li>12、嵌套事务回滚多了。</li></ul><h3 id="java类加载机制-双亲委派模型的好处" tabindex="-1">java类加载机制？ 双亲委派模型的好处？ <a class="header-anchor" href="#java类加载机制-双亲委派模型的好处" aria-label="Permalink to &quot;java类加载机制？ 双亲委派模型的好处？&quot;">​</a></h3><h3 id="解释下hashmap的原理" tabindex="-1">解释下hashmap的原理 <a class="header-anchor" href="#解释下hashmap的原理" aria-label="Permalink to &quot;解释下hashmap的原理&quot;">​</a></h3><h2 id="集合" tabindex="-1">集合 <a class="header-anchor" href="#集合" aria-label="Permalink to &quot;集合&quot;">​</a></h2><ol><li><h4 id="容器包含map和collection。collection包含list、set-元素不重复-、queue" tabindex="-1">容器包含map和collection。collection包含list、set(元素不重复)、queue <a class="header-anchor" href="#容器包含map和collection。collection包含list、set-元素不重复-、queue" aria-label="Permalink to &quot;容器包含map和collection。collection包含list、set(元素不重复)、queue&quot;">​</a></h4><p><img src="'+p+'" alt="1703318795730"></p></li><li><h4 id="list遍历删除-不能直接使用remove-要使用iterator。原因是会导致-modcount-不准确" tabindex="-1">List遍历删除，不能直接使用remove，要使用iterator。原因是会导致 modCount 不准确 <a class="header-anchor" href="#list遍历删除-不能直接使用remove-要使用iterator。原因是会导致-modcount-不准确" aria-label="Permalink to &quot;List遍历删除，不能直接使用remove，要使用iterator。原因是会导致 modCount 不准确&quot;">​</a></h4></li><li><h4 id="list线程安全" tabindex="-1">List线程安全 <a class="header-anchor" href="#list线程安全" aria-label="Permalink to &quot;List线程安全&quot;">​</a></h4><ul><li><code>CopyOnWriteArrayList</code>读不加锁，写加锁并且复制副本，内存偏大，适合读多写少场景，比如缓存。</li><li><code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code>读写都加锁，适合读写均匀的场景。</li></ul></li><li></li></ol><h2 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h2><h3 id="线程的状态" tabindex="-1">线程的状态 <a class="header-anchor" href="#线程的状态" aria-label="Permalink to &quot;线程的状态&quot;">​</a></h3><p>新建（new）、可运行（Runnable）、阻塞（Blocking）、等待（限期等待、无限期等待）、终止（terminated）</p><p><img src="'+h+'" alt="1703317342878"></p><h3 id="lock和synchronized的区别" tabindex="-1">Lock和Synchronized的区别 <a class="header-anchor" href="#lock和synchronized的区别" aria-label="Permalink to &quot;Lock和Synchronized的区别&quot;">​</a></h3><blockquote><p><a href="https://www.zhihu.com/question/554622035/answer/2989085239" target="_blank" rel="noreferrer">https://www.zhihu.com/question/554622035/answer/2989085239</a></p></blockquote><ul><li><p>Synchronized通过使用<strong>内置锁</strong>、<strong>与对象关联的锁</strong>、<strong>可重入性</strong>、<strong>内存屏障</strong>等机制来实现线程的同步和锁的管理，以保证对共享资源的访问具有互斥性和可见性。</p></li><li><p>Lock使用<strong>条件变量</strong>（condition）来实现线程的等待和通知。 Condition接口提供了await()、signal()和signalAll()等方法，用于线程之间的等待和通知，从而避免了Object类中wait()和notify()方法可能出现的信号丢失问题。 比Synchronized提供了灵活性和扩展性。</p></li><li><p>Lock可以中断和设置超时</p></li><li><p>Lock可以获取锁的状态。</p></li><li><p>ReentrantLock()可重入锁。</p></li><li></li></ul><h3 id="synchronized的注意事项" tabindex="-1">Synchronized的注意事项 <a class="header-anchor" href="#synchronized的注意事项" aria-label="Permalink to &quot;Synchronized的注意事项&quot;">​</a></h3><ul><li>方法锁形式：Synchronized修饰<strong>普通方法</strong>，锁对象默认为this，实例对象。</li><li>Synchronized代码块默认是this，可以指定锁对象为class对象。</li><li>Synchronized修饰<strong>静态方法</strong>，默认的锁就是当前所在的class类，所以无论哪个线程去访问它，需要的锁都只有一把。</li><li>锁对象不能为空，因为锁的信息都保存在对象里头</li><li>作用域不易过大，影响程序执行速度，控制范围过大，编写代码也容易出错。有时也可以通过扩大作用域，提升性能，如StringBuffer</li><li>避免死锁</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错。</li></ul><h3 id="在-java-中-wait-和-sleep-方法的不同" tabindex="-1">在 java 中 wait 和 sleep 方法的不同？ <a class="header-anchor" href="#在-java-中-wait-和-sleep-方法的不同" aria-label="Permalink to &quot;在 java 中 wait 和 sleep 方法的不同？&quot;">​</a></h3><p>wait会释放锁，sleep会一直持有锁。wait通常用于线程间交互，sleep通常用于暂停执行。</p><h3 id="阻塞队列成员" tabindex="-1">阻塞队列成员 <a class="header-anchor" href="#阻塞队列成员" aria-label="Permalink to &quot;阻塞队列成员&quot;">​</a></h3><table tabindex="0"><thead><tr><th><strong>队列</strong></th><th><strong>有界性</strong></th><th><strong>锁</strong></th><th><strong>数据结构</strong></th><th>备注</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>bounded（有界）</td><td>加锁</td><td>arrayList</td><td>满了，会根据maximumPoolSize的值增加线程数量，如果增加了还是处理不过来，则会使用拒绝策略RejectedExecutionHandler，默认是AbortPolicy</td></tr><tr><td>LinkedBlockingQueue</td><td>optionally-bounded（可选-有界）</td><td>加锁</td><td>linkedList</td><td>无界队列，可以认为是一个无穷大的队列，可以无限存放任务。</td></tr><tr><td>PriorityBlockingQueue(优先)</td><td>unbounded（无界）</td><td>加锁</td><td>heap</td><td></td></tr><tr><td>DelayQueue</td><td>unbounded</td><td>加锁</td><td>heap</td><td>队列中元素顺序是按到期时间排序的，而非进入队列的顺序。最优的消费者线程的个数与任务启动的时间间隔好像存在这样的关系：单个任务处理时间的最大值　/ 相邻任务的启动时间最小间隔　＝　最优线程数，如果最优线程数是小数，则取整数后加１，比如1.3的话，那么最优线程数应该是2。</td></tr><tr><td>SynchronousQueue</td><td>bounded</td><td>加锁</td><td>无</td><td></td></tr><tr><td>LinkedTransferQueue</td><td>unbounded</td><td>加锁</td><td>heap</td><td></td></tr><tr><td>LinkedBlockingDeque</td><td>unbounded</td><td>加锁</td><td>heap</td><td></td></tr></tbody></table><h3 id="volatile的作用" tabindex="-1">volatile的作用 <a class="header-anchor" href="#volatile的作用" aria-label="Permalink to &quot;volatile的作用&quot;">​</a></h3><ul><li>保证多线程之间的可见性。</li><li>和CAS结合，保证原子性。</li></ul><h3 id="如何在两个线程之间共享数据" tabindex="-1">如何在两个线程之间共享数据? <a class="header-anchor" href="#如何在两个线程之间共享数据" aria-label="Permalink to &quot;如何在两个线程之间共享数据?&quot;">​</a></h3><p>由于多个线程对共享数据的访问存在竞争，因此需要合理的<strong>同步机制</strong>来确保数据的一致性和程序的正确性。</p><ol><li>使用共享变量。将一个变量声明为一个类的成员变量，使多个线程能够访问和修改它。为了确保数据一致性，通常需要使用同步机制来避免数据竞争，例如使用<code>synchronized</code>关键字或显示的锁（ReentrantLock）。</li><li>使用线程安全的集合。如<code>concurrentHashMap</code>、<code>CopyOnWriteArrayList</code>。</li><li>使用<code>wait()</code>和<code>notify()、await/signal/signalAll </code>方法可以实现线程之间的通信，从而实现数据共享。例如生产者-消费者模式就是经典的使用来实现线程之间协调的场景。</li><li>使用<code>BlockingQueue</code>。被用作共享数据的容器，生产者和消费者之间通过队列进行数据传递，<code>put()</code> 和<code>take()</code>方法会自动阻塞，确保数据的正确传递和同步。</li></ol><h3 id="生产者消费者模型的作用是什么" tabindex="-1">生产者消费者模型的作用是什么 <a class="header-anchor" href="#生产者消费者模型的作用是什么" aria-label="Permalink to &quot;生产者消费者模型的作用是什么&quot;">​</a></h3><ul><li>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率</li><li>解耦</li></ul><h3 id="concurrenthashmap的并发度是什么" tabindex="-1">ConcurrentHashMap的并发度是什么 <a class="header-anchor" href="#concurrenthashmap的并发度是什么" aria-label="Permalink to &quot;ConcurrentHashMap的并发度是什么&quot;">​</a></h3><p>是segment（部分）的大小，默认是16，也就意味着最多16条线程同时操作ConcurrentHashMap</p><h3 id="readwritelock是什么" tabindex="-1">ReadWriteLock是什么 <a class="header-anchor" href="#readwritelock是什么" aria-label="Permalink to &quot;ReadWriteLock是什么&quot;">​</a></h3><p>ReentrantReadWriteLock是 ReadWriteLock 接口的一个具体实现 ，实现了<strong>读写分离</strong>，读锁是共享的，写锁是独占的，提升了读写性能。</p><h3 id="写一个死锁的例子" tabindex="-1">写一个死锁的例子 <a class="header-anchor" href="#写一个死锁的例子" aria-label="Permalink to &quot;写一个死锁的例子&quot;">​</a></h3><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247483887&amp;idx=1&amp;sn=ab85965995bde2fb539aaa4b47e7e008&amp;chksm=eb5384d9dc240dcfa20ce9ceedcc8f6174337f74482b103d0b9fc363b5e6b6366e7ddc4590c7&amp;scene=21#wechat_redirect" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247483887&amp;idx=1&amp;sn=ab85965995bde2fb539aaa4b47e7e008&amp;chksm=eb5384d9dc240dcfa20ce9ceedcc8f6174337f74482b103d0b9fc363b5e6b6366e7ddc4590c7&amp;scene=21#wechat_redirect</a></p></blockquote><ul><li>两个线程里分别持有2个Object对象，lock1和lock2，这两个lock作为同步代码块的锁。</li><li>线程1的run()方法先获取lock1的锁，然后睡眠50毫秒（防止刚启动就直接获取了lock2的锁），获取lock2的锁。</li><li>线程2的run()方法先获取lock2的锁，再去获取lock1的锁。此时形成了死锁。</li></ul><h3 id="如何避免死锁" tabindex="-1">如何避免死锁？ <a class="header-anchor" href="#如何避免死锁" aria-label="Permalink to &quot;如何避免死锁？&quot;">​</a></h3><ul><li>顺序加锁。</li><li>获取锁时限。每个获取锁的时候加上时限，如果超时，则放弃该锁。</li><li>死锁检查。按线程间获取锁的关系检测线程间是否发生死锁，如果发生死锁就执行一定的策略，如终端线程或回滚操作等。</li></ul><ol start="13"><li></li></ol><h3 id="_1、用过threadlocal吗-原理是啥" tabindex="-1">1、用过threadlocal吗？原理是啥 <a class="header-anchor" href="#_1、用过threadlocal吗-原理是啥" aria-label="Permalink to &quot;1、用过threadlocal吗？原理是啥&quot;">​</a></h3><p><a href="https://cloud.tencent.com/developer/article/2398602" target="_blank" rel="noreferrer">https://cloud.tencent.com/developer/article/2398602</a></p><p>相比于局部变量。ThreadLocal的优点就是可以在任意地方获取一些专属当前线程的数据。</p><p>一般可以考虑使用ThreadLocal实现如下功能：</p><ol><li>统计接口请求的持续时间</li><li>实现请求的RPC日志 <ul><li>可以在日志系统中使用 <code>ThreadLocal</code> 存储线程级别的上下文信息，比如 <code>requestId</code> 或 <code>traceId</code>，这样在整个请求链中都可以记录统一的上下文信息，方便追踪日志。</li></ul></li><li>用户会话管理 <ul><li>在处理 HTTP 请求时，每个线程都代表一个用户请求。可以使用 <code>ThreadLocal</code> 来存储每个线程的会话信息，如用户 ID、认证信息、角色等，保证线程间的会话信息独立。</li></ul></li><li>数据库连接管理 <ul><li>在一些数据库操作中，每个线程可能需要维护一个数据库连接。通过 <code>ThreadLocal</code>，可以确保每个线程都有一个独立的数据库连接，避免了多个线程竞争同一个连接。</li></ul></li><li>事务管理 <ul><li>在事务管理中，可以通过ThreadLocal来确保每个线程拥有独立的事务状态，从而保证事务的原子性和隔离性。</li><li>Spring中 <code>TransactionSynchronizationManager</code> 就是通过ThreadLocal来存储当前线程的事务上下文信息。</li></ul></li><li>跨层数据传参</li></ol><h2 id="io" tabindex="-1">IO <a class="header-anchor" href="#io" aria-label="Permalink to &quot;IO&quot;">​</a></h2><ol><li><h4 id="通道" tabindex="-1">通道 <a class="header-anchor" href="#通道" aria-label="Permalink to &quot;通道&quot;">​</a></h4><ul><li>FileChannel：操作文件</li><li>DatagramChannel：通过UDP读写网络中数据</li><li>SocketChannel：通过TCP读写网络中数据</li><li>ServerSocketChannel： 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel</li></ul></li><li><h4 id="缓冲区" tabindex="-1">缓冲区 <a class="header-anchor" href="#缓冲区" aria-label="Permalink to &quot;缓冲区&quot;">​</a></h4><p><img src="'+o+'" alt="1703511759538"></p></li><li></li><li></li></ol><h3 id="网络io模型-什么是多路复用io" tabindex="-1">网络IO模型？ 什么是多路复用IO？ <a class="header-anchor" href="#网络io模型-什么是多路复用io" aria-label="Permalink to &quot;网络IO模型？ 什么是多路复用IO？&quot;">​</a></h3><h2 id="网络编程" tabindex="-1">网络编程 <a class="header-anchor" href="#网络编程" aria-label="Permalink to &quot;网络编程&quot;">​</a></h2><p>1、网络结构是7层国际标准（OSI）、4层模型、5层结构</p><p>2、每一层对应常见协议</p><table tabindex="0"><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>应用层</td><td>http、ftp</td><td></td></tr><tr><td>传输层</td><td>TCP、UDP</td><td></td></tr><tr><td>网络层</td><td>IP</td><td></td></tr><tr><td>网络接口层</td><td></td><td></td></tr></tbody></table><h3 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-label="Permalink to &quot;http&quot;">​</a></h3><p><strong>1、输入URl到返回页面的解析过程</strong></p><p>大致6步，</p><p>1、DNS解析，获取域名对应IP</p><p>2、TCP连接，3次握手，建立TCP连接</p><p>3、发送Http数据</p><p>4、服务器处理数据，返回http请求结果</p><p>5、浏览器渲染</p><p>6、断开TCP，4次挥手</p><h3 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h3><p><strong>1、握手为什么不是2次或4次</strong></p><ul><li>防止服务器端开启无用连接，增加服务器开销</li><li>防止已失效连接请求报文突然传到服务器，产生错误。</li><li>3次已经足够，没有必要再增加一次</li></ul><p><strong>2、挥手4次</strong></p><ul><li>需要等待完成数据的发送和接收，ack和FIN是分开发送的</li></ul><h3 id="udp" tabindex="-1">UDP <a class="header-anchor" href="#udp" aria-label="Permalink to &quot;UDP&quot;">​</a></h3><blockquote><p>关于netty UDP不能发送大于2048字节包的问题<a href="https://blog.csdn.net/KokJuis/article/details/72864018" target="_blank" rel="noreferrer">https://blog.csdn.net/KokJuis/article/details/72864018</a></p></blockquote><ul><li><p>udp理论上支持最大发送64K的包，那为什么netty udp不能发送大于2048字节呢？实际上网络通信中，还受到很多其他因素的影响，netty udp并非不能发送大于2048字节的包。而是收到MTU的影响。MTU【最大传输单元（Maximum Transmission Unit，MTU）是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）】。</p></li><li><p>MTU国际默认规定是1500，不同的网络接入方式，不同地区的网络运营商，甚至不同的路由器，它们的MTU值都可能是不同的，例如：ADSL接入时MTU为1492字节。操作系统中可以通过命令查看：netsh interface ipv4 show subinterfaces</p></li><li><p>最后说一下netty udp每次发送包大小的建议，因为国内很多用户的上网方式都是ADSL。而ADSL的MTU值1492。但每个UDP包都包含28字节的“数据包报头”，所以实际你每次只能发送的数据是1464个字节。</p></li></ul><h3 id="socket" tabindex="-1">socket <a class="header-anchor" href="#socket" aria-label="Permalink to &quot;socket&quot;">​</a></h3><p><strong>1、socket和websocket有啥区别</strong></p><p>socket就是ip+port+协议，是一套网络标准接口，完成了对TCP/IP的高度封装，屏蔽了网络细节，方便开发者更好的进行网络编程。</p><p>websocket是解决http不支持持久化连接的问题，伴随H5而出的持久化的协议，属于应用层通信协议。</p><ol><li><p><strong>简述一下线程的几种状态以及状态之间的转换</strong>。<a href="https://www.cnblogs.com/javastack/p/17639536.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/javastack/p/17639536.html</a></p><p>在 JVM 运行中，线程一共有 NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED 六种状态，这些状态对应 <code>Thread.State</code> 枚举类中的状态。</p><p><img src="'+d+`" alt="img"></p></li><li><p><strong>什么是线程安全，如何实现线程安全？</strong></p></li></ol><p>线程安全是指在多线程环境下，多个线程同时访问同一资源时，不会产生意外结果或导致数据出错的状态</p><ul><li><p>加锁。通过加锁机制控制对共享资源的访问，使得每次只有一个线程能够访问共享资源。Java中提供了synchronized关键字和Lock接口来实现加锁功能。</p></li><li><p>原子变量。 AtomicInteger和AtomicReference</p></li><li><p>线程安全的集合类 . ConcurrentHashMap和ConcurrentLinkedQueue</p></li><li><p>使用volatile关键字：当多个线程同时访问同一个变量时，使用volatile关键字可以确保该变量对所有线程可见，避免出现数据不一致问题。</p></li><li><p>线程封闭：将共享资源限定在单个线程内部，避免多个线程同时访问，也就不存在线程安全问题。</p></li><li><p>不可变对象：将对象设计成不可变的，可以避免线程安全问题。因为不可变对象的状态不会改变，因此多个线程同时访问该对象也不会出现问题</p></li></ul><p><strong>HashMap 的实现原理以及在什么情况下会发生扩容</strong></p><ul><li>1.7数组+链表</li><li>1.8数组+红黑树</li></ul><ol><li><p><strong>如何理解 Java 的反射机制，它有什么作用？</strong></p><p>Java中的反射机制（Reflection）是一种能够在运行时动态获取类的详细信息并操作类和对象的机制。反射允许程序在运行时检查和修改类的结构和行为</p><p>Java反射机制的用途</p><ul><li><p>动态类加载：反射可以在运行时加载类和创建类的实例，而不需要在编译时知道类的名称。这对于实现动态模块加载和插件机制非常有用。</p></li><li><p>获取类的信息：通过反射，程序可以在运行时获取类的结构信息，包括类的属性、方法、构造函数、父类和实现的接口等。</p></li><li><p>操作对象：反射可以在运行时访问和修改对象的属性、调用对象的方法，甚至可以创建新对象。这在框架和库中经常使用，比如Spring、Hibernate等。</p></li><li><p>动态代理：反射是Java动态代理机制的基础。动态代理允许在运行时创建一个代理对象，用来代理其他对象的行为，这对于AOP（面向方面编程）非常重要。</p></li><li><p>测试和调试：反射可以用于编写测试代码，比如JUnit中的测试框架，通过反射可以调用私有方法和访问私有属性，从而进行单元测试。</p></li></ul></li><li><p><strong>讲讲常见的设计模式，以及在实际项目中的应用</strong>。</p></li><li><p><strong>Spring 框架的核心概念有哪些？</strong></p><ul><li>IOC</li><li>AOP</li><li>DI</li></ul></li><li><p><strong>数据库事务的四大特性是什么？</strong></p><p>ACID</p><ul><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ul></li><li><p><strong>如何优化数据库查询性能？</strong></p><ul><li><p>使用索引</p></li><li><p>避免函数和表达式</p></li><li></li><li><p>缓存</p><p><strong>在高并发场景下，如何处理数据一致性问题？</strong></p></li></ul></li></ol><ul><li>事务管理：使用数据库事务来确保关键操作的原子性、一致性、隔离性和持久性。通过合理的事务设计和管理，对于涉及到多个数据操作的场景，可以保证数据的一致性。</li><li>数据库锁机制：使用数据库提供的锁机制来保证对共享资源的独占访问。通过合理使用行锁、表锁、悲观锁或乐观锁等方式，控制并发访问数据库的行为，保证数据的一致性和正确性。</li><li>幂等性设计：设计接口或操作具有幂等性，即对同一请求的多次执行只会产生一次结果影响。通过设计幂等性操作，可以避免因为同一请求的重复执行而导致的数据重复或不一致问题。</li><li>高可用架构：构建高可用的系统架构，采用主备、集群、分布式等方式实现故障容错和数据备份。通过合理的架构设计和备份策略，当某个节点或服务发生故障时，可以快速切换到备用节点或服务，保证服务的可用性和数据的可靠性。</li><li>队列和消息中间件：使用消息队列和消息中间件来解耦和异步处理高并发请求。将请求发送到队列中进行异步处理，保证数据操作的顺序和一致性。消息中间件还可以提供事务消息、可靠消息传递等特性，以确保数据的可靠传输和处理。</li><li>分布式一致性算法：采用一致性哈希、分布式锁、Paxos、Raft等分布式一致性算法来处理分布式环境下的数据一致性问题。这些算法可以实现在分布式系统中的协调和一致性保证。</li><li>异常处理和监控：及时捕获和处理异常，对于异常操作进行回滚或补偿操作，保证数据的一致性。同时，建立合适的监控系统，对系统和数据进行实时监测和报警，及时发现和处理潜在的问题。</li><li>数据备份和恢复：定期进行数据备份，并建立完备的数据恢复机制。可以采用灾备方案、冷备、热备、增量备份等方式进行数据备份，确保在数据丢失或损坏情况下可以进行快速的恢复。</li></ul><h2 id="线程池" tabindex="-1">线程池 <a class="header-anchor" href="#线程池" aria-label="Permalink to &quot;线程池&quot;">​</a></h2><h3 id="_1、用过线程池吗-解释下线程池的参数" tabindex="-1">1、用过线程池吗？解释下线程池的参数 <a class="header-anchor" href="#_1、用过线程池吗-解释下线程池的参数" aria-label="Permalink to &quot;1、用过线程池吗？解释下线程池的参数&quot;">​</a></h3><p>用过，在处理批量任务、异步任务、在推演项目中，开启新的场景。</p><p>7个参数：</p><ol><li><p>corePoolSize：线程池中保持的最小线程数，即使这些线程空闲也不会被销毁，除非设置了allowCoreThreadTimeOut=true。cpu密集型：N+1。IO密集型：2N</p></li><li><p>maximumPoolSize：线程池中允许的最大线程数。当任务数超过核心线程数且队列满时，线程池会创建新线程，直到达到最大线程数。</p></li><li><p>keepAliveTime：线程空闲时间</p></li><li><p>TimeUnit：时间单位</p></li><li><p>workQueue：队列</p><ul><li>无界队列，默认使用LinkedBlockQueue（FIFO），默认容量是Integer.max_value;无界队列，任务数超过核心线程数时，新任务会进入队列等待。</li><li>有界队列：有界队列，队列满时会触发创建新线程。 <ul><li>ArrayBlockingQueue</li><li>PriorityBlockingQueue</li></ul></li><li>同步移交队列：SynchronousQueue。 如果不希望任务在队列中等待而是希望将任务直接移交给工作线程。SynchronousQueue不是一个真正的队列，而是一种线程之间移交的机制。要将一个元素放入SynchronousQueue中，必须有另一个线程正在等待接收这个元素。只有在使用无界线程池或者有饱和策略时才建议使用该队列。</li></ul></li><li><p>threadFactory： 用于创建新线程，可以自定义线程的名称、优先级等。</p></li><li><p>RejectedExecutionHandler：任务拒绝处理器</p><p>两种情况会拒绝处理任务：</p><ol><li>当线程数已经达到maxPoolSize，且队列已满，会拒绝新任务。</li><li>当线程池被调用shutdown()后，会等待线程池里的任务执行完毕再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务。</li></ol><ul><li>AbortPolicy：丢弃任务，抛运行时异常。(默认)</li><li>CallerRunsPolicy：由提交任务的线程执行该任务 ， 高负载下仍能正常运行 。</li><li>DiscardPolicy： 直接丢弃任务 。</li><li>DiscardOldestPolicy：从队列中踢出最先进入队列（最后一个执行）的任务。</li></ul></li></ol><p><strong>设置线程池参数</strong></p><blockquote><p>线程池参数设置<a href="https://blog.51cto.com/u_16099170/6771992" target="_blank" rel="noreferrer">https://blog.51cto.com/u_16099170/6771992</a></p></blockquote><p><strong>具体是怎么设置呢？</strong></p><p>假设机器有N个CPU</p><p>1.那么对于计算密集型的任务，corePoolSize 应该设置线程数为N+1</p><p>2.对于IO密集型的任务，corePoolSize 应该设置线程数为2N</p><p>3.对于同时又计算工作和IO工作的任务，应该考虑使用两个线程池，一个处理计算任务，一个处理IO任务，分别对两个线程池按照计算密集型和IO密集型来设置线程数</p><blockquote><p>获取cpu个数代码</p></blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Runtime.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRuntime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">availableProcessors</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span></code></pre></div><p><strong>创建线程池</strong></p><p>ThreadPoolTaskExecutor （属于spring）和ThreadPoolExecutor（属于JDK）的区别：<a href="https://blog.csdn.net/qq_44754515/article/details/125805766" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_44754515/article/details/125805766</a></p><blockquote><p>Java线程池中三种方式创建 ThreadFactory 设置线程名称</p><p><a href="https://cloud.tencent.com/developer/article/1948703?areaSource=102001.16&amp;traceId=5aZi_fV1b9JskW2w7c9er" target="_blank" rel="noreferrer">https://cloud.tencent.com/developer/article/1948703?areaSource=102001.16&amp;traceId=5aZi_fV1b9JskW2w7c9er</a></p></blockquote><blockquote><p><a href="https://www.cnblogs.com/LiPengFeiii/p/15766351.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/LiPengFeiii/p/15766351.html</a></p></blockquote><p>使用common下创建ThreadFactory时，设置<code>daemon=true</code>变为守护线程，当主程序结束后，线程也会结束。如果要查看打印，需要给主线程加一下Thread.sleep(5000); // 主线程休眠5秒</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ThreadFactory basicThreadFactory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BasicThreadFactory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">namingPattern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;example-schedule-pool-%d&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">daemon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>示例</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">package</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> com.cetc.gatekeeper.config;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.apache.commons.lang3.concurrent.BasicThreadFactory;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> org.springframework.stereotype.Component;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> java.util.concurrent.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * @auther lanmei</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> * @date 2023/10/17</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadPoolConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /** 线程池核心池的大小 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> corePoolSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /** 线程池中允许的最大线程数量 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> maximumPoolSize </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /** 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间 默认秒s*/</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> keepAliveTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 60L</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /** 队列 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> capacity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThreadFactory threadFactory </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BasicThreadFactory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Builder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">namingPattern</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data-send-pool-%d&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">daemon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ExecutorService executorService </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ThreadPoolExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            corePoolSize,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            maximumPoolSize,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            keepAliveTime,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            TimeUnit.SECONDS,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinkedBlockingQueue&lt;&gt;(capacity),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            threadFactory,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThreadPoolExecutor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CallerRunsPolicy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 获取线程池service</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ExecutorService </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getExecutorService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> executorService;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h3><h2 id="场景题" tabindex="-1">场景题 <a class="header-anchor" href="#场景题" aria-label="Permalink to &quot;场景题&quot;">​</a></h2><h3 id="_1、-如何防止重复提交订单" tabindex="-1">1、 如何防⽌重复提交订单？ <a class="header-anchor" href="#_1、-如何防止重复提交订单" aria-label="Permalink to &quot;1、 如何防⽌重复提交订单？&quot;">​</a></h3><p>重复提交的原因：</p><ul><li>用户多次点击按钮</li><li>nginx或springCloud的gateway的网关层，进行超时重试造成的</li></ul><ol><li><p>按钮置灰</p></li><li><p>预生成全局唯一订单号（后端），利用数据的唯一索引特性，在插入数据库时，如果重复，则插入失败</p></li><li><p>前端生成唯一订单号。</p></li><li><p>订单业务本质入手，redis设置过期时间。防止短时间内，用户和商品进行多次连接。可以用”用户ID+分隔符+商品ID“作为唯一标识，让持有相同标识的请求在短时间内不能重复下单。</p></li><li><ul><li></li></ul></li></ol><h3 id="_3、水平分表如何保持id的唯一性" tabindex="-1">3、水平分表如何保持id的唯一性？ <a class="header-anchor" href="#_3、水平分表如何保持id的唯一性" aria-label="Permalink to &quot;3、水平分表如何保持id的唯一性？&quot;">​</a></h3><p>分库分表之后，需要保证ID唯一，既然是分库分表，所以不能使用ID自增。常见方案如下及各自优缺点。</p><ul><li><p><strong>UUID</strong></p><p>JDK自带工具类，生成无序的36位字符串，一般去掉中间的4个-，使用32位。</p><ul><li>优点：简单方便，本地生成，出错率低。</li><li>缺点：32个字符串，占用空间较大，无序，写入性能较差，可读性差。</li></ul></li><li><p><strong>雪花算法。</strong></p><p>生成19位long类型整数。组成部分，主要是由毫秒时间戳+5位房间号+5位机器号+12位不同的ID</p><ul><li>优点：有序递增</li><li>缺点：服务器时钟回拨，导致生成相同ID</li></ul></li><li><p><strong>Redis通过自增命令来生成分布式ID</strong></p><ul><li>优点：单调递增，不影响数据库写入性能，可读性高</li><li>缺点：需要额外引入redis，链路变长导致出错概率增加。开发成本相对较高。</li></ul></li><li><p><strong>数据库号段</strong></p><p>数据库号段，是在“数据库⾃增ID”⽅案上做的优化，实现⽅式如下：</p><p>（1）从中央数据库中获取出⼀批分布式ID，并缓存到分布式ID服务本地，业务系统获取分布式ID的时 候，可直接在这个批次内递增取值。</p><p>（2）若该批次分布式ID的号段⽤完，则需要更新数据库中的初始值，再次获取新批次的分布式ID，并重 新缓存到分布式ID服务本地，以供使用</p><p>优点：趋势递增，不会影响数据库的数据写入性能，数据库压力小，可读性高</p><p>缺点：开发成本极高，需要额外引入分布式ID服务和中央数据库，链路边长导致出错率增加。</p></li><li><p><strong>美团Leaf</strong></p><p>改动点：将本地jar变成独立服务，并引入zookeeper来解决时钟回拨问题</p><p>优点：解决了时钟回拨问题。</p><p>缺点：引入zookeeper，增加程序复杂性，链路变长导致出错率增加。</p></li><li><p><strong>滴滴Tinyid</strong></p><p>号段模式的优化</p></li><li><p><strong>百度Uidgenerator</strong></p><p>类似雪花算法，相比较雪花算法，时间bit变少了，而机器ID的bit变多了。</p><p>时间回拨产生的原因：分布式系统中，各机器同步服务器时间，一般每2小时同步一次，在 10ms 以内完成。</p><p>解决时钟回拨：传统的雪花算法都是通过<code>System.currentTimeMillis()</code>来获取时间并与上一次时间进行比对，这样严重依赖服务器时间。而百度的时间类型是<code>AtomicLong</code>，且通过<code>incrementAndGet()</code>方法获取下一次时间，从而脱离了对服务器的依赖，也不会有时间回拨的问题（这种做法也有一个小问题，即分布式ID中的时间信息可能并不是这个ID真正产生的时间点）</p></li><li><p><strong>MongoDB的ObjectID</strong></p><p>类似雪花算法，通过时间+机器码+pid+inc共12个字节，通过4+3+2+3的方式最终标识成一个24长度的十六进制字符。</p></li><li><p><strong>zookeeper生成唯一ID</strong> （不推荐）</p></li></ul><h3 id="消息堆积如何解决" tabindex="-1">消息堆积如何解决？ <a class="header-anchor" href="#消息堆积如何解决" aria-label="Permalink to &quot;消息堆积如何解决？&quot;">​</a></h3>`,129)]))}const D=l(c,[["render",k]]);export{A as __pageData,D as default};
