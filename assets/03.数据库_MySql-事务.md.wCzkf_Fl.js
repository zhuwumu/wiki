import{_ as s,c as a,o as l,aj as n,aM as p,aN as t,aO as h}from"./chunks/framework.DA_nFhhl.js";const y=JSON.parse('{"title":"事务","description":"","frontmatter":{},"headers":[],"relativePath":"03.数据库/MySql-事务.md","filePath":"03.数据库/MySql-事务.md","lastUpdated":1762179876000}'),e={name:"03.数据库/MySql-事务.md"};function k(r,i,d,o,g,E){return l(),a("div",null,[...i[0]||(i[0]=[n('<h1 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to “事务”">​</a></h1><h2 id="说说什么是事务" tabindex="-1">说说什么是事务 <a class="header-anchor" href="#说说什么是事务" aria-label="Permalink to “说说什么是事务”">​</a></h2><p><a href="https://www.cnblogs.com/binghe001/p/13620501.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/binghe001/p/13620501.html</a></p><p>本质考察：事务的四大特性</p><p>事务：单个逻辑工作单元组成的一系列操作，要么全部执行，要么全部不不执行。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性、持久性）属性。</p><ul><li>A：原子性（Atomicity）： 事务中的所有操作要么全部执行成功，要么全部失败回滚，不能只执行其中一部分操作。</li><li>C：一致性（Consistency）：事务执行前后，数据库的完整性约束没有被破坏，数据总是从一个一致性状态转移到另一个一致性状态。例如，如果一个事务要求将某个账户的金额从 A 转移到 B，那么无论事务是否成功，最终账户 A 和账户 B 的总金额应该保持不变。</li><li>I：隔离性（Isolation）： 事务之间是相互隔离的，每个事务对其他事务的操作是透明的，一个事务的中间结果对其他事务是不可见的。隔离性可以防止并发执行的事务之间产生脏读、不可重复读和幻读等问题。</li><li>D：持久性（Durability）： 事务完成后，对数据库的修改将永久保存在数据库中，即使系统故障也不会丢失。</li></ul><h2 id="如何保证事务的四大特性" tabindex="-1">如何保证事务的四大特性？ <a class="header-anchor" href="#如何保证事务的四大特性" aria-label="Permalink to “如何保证事务的四大特性？”">​</a></h2><p>以默认的引擎 InnoDB 为例，它保证四大特性的手段分别是：</p><ol><li>原子性是通过 undo log（回滚日志） 来保证的，InnoDB 使用日志（undo log）来记录事务的操作，包括事务开始、修改数据和事务提交等。如果事务执行失败或回滚，InnoDB 可以使用日志来撤销已经执行的操作，确保事务的原子性。</li><li>一致性：更多是依赖业务层。数据库是通过各种约束，如主键、外键、唯一性约束等。</li><li>隔离性：提供了4种隔离级别，默认隔离级别是RR（可重复读），是通过 MVCC（多版本并发控制）解决了脏读和不可重复读的问题， 锁机制（表锁和行锁）的方式解决幻读的问题。</li><li>持久性：是通过 redo log （重做日志）来保证的，在事务提交之前，InnoDB 会将事务的修改操作先写入事务日志（redo log），然后再将数据写入磁盘。即使在系统崩溃或断电的情况下，InnoDB 可以通过重放事务日志来恢复数据，确保事务的持久性。由<code>Buffer Pool缓冲区</code>+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</li></ol><h2 id="并发事务带来的问题-隔离级别" tabindex="-1">并发事务带来的问题|隔离级别 <a class="header-anchor" href="#并发事务带来的问题-隔离级别" aria-label="Permalink to “并发事务带来的问题|隔离级别”">​</a></h2><p>本质考察：带来哪些问题，有哪些解决方案</p><p>带来的问题：</p><ul><li>脏写：多个事务对数据进行更新，互相不知道对方的存在， 最后的更新将重写由其它事务所做的更新，这将导致数据丢失。</li><li>脏读：一个事务在更新时，在完成提交前，另一个事务读取同一条数据，如果不加控制，第二条事务就读到了“脏”数据， 并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读” 。</li><li>不可重复读： 同一个事务中，不同时间读取到的数据可能不一样。</li><li>幻读： 即在一个事务中，两次查询同一个范围的记录，但第二次查询却发现了新的记录。</li></ul><p>问题的解决方案：</p><p>为避免上面出现的几种情况，在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。以下4种隔离级别限制从低到高，性能从高到低。高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。</p><ul><li><strong>读未提交（Read Uncommitted）</strong></li></ul><p>允许脏读，但不允许更新丢失，一个事务写时，不允许其他事务写，可以读。该隔离级别可通过“排他写锁”实现。</p><ol><li>特点：最低的隔离级别，事务中的修改，即使未提交，也可以被其他事务读取到。</li><li>优点：并发性能最好，读取到的数据最新。</li><li>缺点：<strong>存在脏读（Dirty Read）问题</strong>，即读取到未提交的数据，可能导致数据不一致性</li></ol><ul><li><strong>读已提交（Read Committed）</strong></li></ul><p>这可以通过“瞬间共享读锁”和“排他写锁”实现 。 可避免 脏读，不可避免 不可重复读、虚读。Oracle采用读已提交。</p><ol><li>特点：保证事务读取到的数据都是已经提交的，其他事务提交的数据对该事务可见。</li><li>优点：避免了脏读的问题。</li><li>缺点：<strong>存在不可重复读（Non-Repeatable Read）问题</strong>，即同一个事务中，不同时间读取到的数据可能不一样。</li></ol><ul><li><strong>可重复读（Repeatable Read）</strong></li></ul><p>可避免脏读、不可重复读， 不可避免 虚读。MySQL采用可重复读。</p><ol><li>特点：保证同一个事务中，多次读取同一条记录时，读取到的数据都是一致的，MySQL 默认的事务隔离级别。</li><li>优点：避免了不可重复读的问题。</li><li>缺点：<strong>存在幻读（Phantom Read）问题</strong>，即在一个事务中，两次查询同一个范围的记录，但第二次查询却发现了新的记录。</li></ol><ul><li><strong>串行化（Serializable）</strong></li></ul><p>可避免 脏读、不可重复读、幻读情况的发生。</p><p>特点：最高的隔离级别，将所有的事务串行执行，保证了数据的完全隔离。</p><p>优点：避免了幻读的问题。</p><p>缺点：<strong>并发性能最差</strong>，可能导致大量的锁等待和死锁。</p><p>通常情况下，可重复读是一个比较好的选择，能够较好地平衡数据一致性和并发性能。</p><h2 id="不可重复读和幻读有什么区别" tabindex="-1">不可重复读和幻读有什么区别 <a class="header-anchor" href="#不可重复读和幻读有什么区别" aria-label="Permalink to “不可重复读和幻读有什么区别”">​</a></h2><ol><li><p>发生场景不同</p><p>：不可重复读主要涉及到修改数据，而幻读则主要涉及到插入或删除数据。</p><ol><li>不可重复读指的是在同一个事务中，多次读取同一行数据，但是每次读取的结果都不同，这是因为在这个事务读取数据的期间，其他事务修改了这些数据所导致的；</li><li>幻读指的是在同一个事务中，多次执行相同的查询，但是每次查询返回的行数却不同，这是因为在这个事务读取数据的期间，其他事务插入了新的数据所导致的。</li></ol></li><li><p><strong>解决方案不同</strong>：不可重复读的解决方案通常是使用行锁或者表锁来解决，而幻读的解决方案通常是使用间隙锁来解决。</p></li></ol><p>所以，不可重复读主要涉及到修改数据，而幻读则主要涉及到插入或删除数据。同时，不可重复读的解决方案通常是使用行锁或者表锁，而幻读的解决方案通常是使用间隙锁。</p><h2 id="rr有幻读问题么-mvcc能否解决幻读" tabindex="-1">RR有幻读问题么？MVCC能否解决幻读？ <a class="header-anchor" href="#rr有幻读问题么-mvcc能否解决幻读" aria-label="Permalink to “RR有幻读问题么？MVCC能否解决幻读？”">​</a></h2><p><strong>RR 隔离级别</strong></p><p>在 MySQL 中，RR 代表 Repeatable Read（可重复读），是数据库事务隔离级别中的一种，它的特性是保证同一个事务中，多次读取同一条记录时，读取到的数据都是一致的。它也是 MySQL 默认的事务隔离级别。</p><blockquote><p>隔离级别是数据库管理系统为了处理并发访问时，控制事务之间相互影响的程度而定义的一组规则。</p></blockquote><p><strong>MVCC</strong></p><p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种并发控制机制，用于在数据库系统中处理并发读写操作时保持数据的一致性和隔离性（<strong>主要是用来解决幻读问题的</strong>）。MVCC 通过在每个数据行上保存多个版本的数据来实现并发读取和写入的一致性。</p><p>MVCC 的核心思想是将每个事务的读操作与写操作解耦，通过保存数据的历史版本来实现并发控制。每个事务在开始时会创建一个读视图（Read View），用于确定在事务开始时可见的数据版本。读视图包含一个事务开始时的系统版本号，用于与数据行的版本号进行比较，以确定数据行是否对事务可见。</p><p>在 MVCC 中，当一个事务执行写操作时，会生成一个新的数据版本，并将旧版本的数据保存在回滚日志（Undo Log）中。这样，其他事务在读取数据时仍然可以访问到旧版本的数据，从而避免了幻读问题。</p><p>MVCC 工作流程如下：</p><ol><li>读操作：当一个事务执行 SELECT 语句时，会根据读视图的系统版本号和数据行的版本号进行比较，只读取在事务开始之前已经提交的数据行。这样，即使其他事务正在并发地插入或删除数据，事务仍然可以读取到一致的数据。</li><li>写操作：当一个事务执行 INSERT、UPDATE 或 DELETE 语句时，会生成新的数据版本，并将旧版本的数据保存在回滚日志中。这样，其他事务在读取数据时仍然可以访问到旧版本的数据，从而避免了幻读问题。</li></ol><p>MVCC 机制在数据库系统中广泛应用，特别是在支持事务的存储引擎中，如 MySQL 的 InnoDB 引擎。它通过解耦读操作和写操作，提供了高并发性能和数据一致性，使得多个事务可以同时读取和修改数据库，而不会相互干扰。</p><h3 id="rr-mvcc-有幻读问题吗" tabindex="-1">RR + MVCC 有幻读问题吗？ <a class="header-anchor" href="#rr-mvcc-有幻读问题吗" aria-label="Permalink to “RR + MVCC 有幻读问题吗？”">​</a></h3><p>在 MySQL 中，即使是<strong>RR 隔离级别（可重复读），虽然它通过 MVCC 消除了绝大部分幻读问题，但依旧存在部分幻读问题</strong>，所以 RR 隔离级别存在幻读问题，而 MVCC 也没有彻底解决幻读问题。</p><h3 id="幻读问题演示" tabindex="-1">幻读问题演示 <a class="header-anchor" href="#幻读问题演示" aria-label="Permalink to “幻读问题演示”">​</a></h3><p>在 RR 隔离级别中存在两种读操作：</p><ol><li><strong>快照读</strong>：数据库中一种读取数据的方式，它基于事务开始时的一个一致性快照来读取数据。快照读可以提供事务开始时的数据视图，即使在事务执行期间其他事务对数据进行了修改，也不会影响快照读取到的数据。简单理解，快照读就是事务开启时创建一个缓存，之后的查询都会从这个缓存中获取数据。</li><li><strong>当前读</strong>：数据库中一种读取数据的方式，它读取最新提交的数据，而不是基于事务开始时的一致性快照。</li></ol><p>所以，在 RR 隔离级别中 MVCC 通过快照读的方式解决了大部分幻读问题，但如果 RR 隔离级别存在当前读（使用 select ... for update 实现），那么此时也会发生幻读问题，比如以下执行过程：</p><p><img src="'+p+'" alt=""></p><h3 id="如何彻底解决幻读" tabindex="-1">如何彻底解决幻读？ <a class="header-anchor" href="#如何彻底解决幻读" aria-label="Permalink to “如何彻底解决幻读？”">​</a></h3><p>想要彻底解决幻读问题，有两个方案：</p><ol><li><p><strong>使用串行化（Serializable）隔离级别</strong>：官方推荐方案，但这种解决方案，并发性能比较低。</p></li><li><p><strong>RR + 锁</strong>：使用 RR 隔离级别，但在事务开启之后立即加锁，如下图所示：</p><p><img src="'+t+`" alt=""></p><p>事务一开启之后就加锁，之后其他事务在操作此表的相关数据时，就只能等待锁释放（事务一提交或回滚锁自动释放）。</p></li></ol><h2 id="行锁、表锁和间隙锁有什么区别" tabindex="-1">行锁、表锁和间隙锁有什么区别 <a class="header-anchor" href="#行锁、表锁和间隙锁有什么区别" aria-label="Permalink to “行锁、表锁和间隙锁有什么区别”">​</a></h2><p>行锁、表锁和间隙锁是 InnoDB 中实现事务隔离级别的基本锁类型。</p><ul><li>行锁：指对表中的某一行数据进行锁定，当有事务修改该行数据时，其他事务无法同时修改该行数据，从而保证数据的一致性。行锁的粒度最细，对并发性能的影响最小。</li><li>表锁：指对整张表进行锁定，当有事务对表中任意一行数据进行修改时，其他事务无法修改整张表中的任意一行数据，从而保证数据的一致性。表锁的粒度最大，对并发性能的影响最大。</li><li>间隙锁：指对一个索引范围中的“空隙”进行锁定，防止其他事务在这个范围内插入新数据。间隙锁用于解决幻读问题，例如在某个事务中执行了一个范围查询，然后在范围内的间隙处插入了新数据，这时再次执行相同的查询，会发现有一些行出现了两次，这就是幻读。通过间隙锁，可以防止其他事务插入新的数据，从而避免幻读。</li><li>临建锁是行锁和间隙锁的组合，可以理解为一种特殊的间隙锁，它等于行锁+间隙锁，除了锁住记录本身，还会锁住索引之间的间隙，即锁定一段左开右闭的索引区间。</li></ul><p>在 InnoDB 中，默认情况下是使用行锁实现事务隔离级别的。当需要锁定一整张表时，可以使用表锁；当需要解决幻读问题时，可以使用间隙锁。在使用间隙锁时，需要注意锁的范围，避免影响其他事务的正常操作。</p><h3 id="锁示例" tabindex="-1">锁示例 <a class="header-anchor" href="#锁示例" aria-label="Permalink to “锁示例”">​</a></h3><p>以下是一个示例，演示如何使用行锁、表锁和间隙锁。</p><p><strong>1.行锁</strong></p><p>行锁是在数据行级别上实现的锁，它可以防止多个事务同时修改同一行数据。下面是一个示例：</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 会话 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">BEGIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FOR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 对 id=1 的数据行进行修改</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 会话 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">BEGIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 因为会话 1 对 id=1 的数据行进行了行锁，所以会话 2 不能同时对该行进行修改，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 如果执行下面的语句会一直等待会话 1 的事务提交或回滚</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p><strong>2.表锁</strong></p><p>表锁是在表级别上实现的锁，它可以防止多个事务同时修改整个表。下面是一个示例：</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 会话 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">BEGIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LOCK TABLES orders WRITE;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 对整个表进行修改</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UNLOCK</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TABLES;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 会话 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">BEGIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 因为会话 1 对 orders 表进行了表锁，所以会话 2 不能同时对该表进行修改，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 如果执行下面的语句会一直等待会话 1 的事务提交或回滚</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SET</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> amount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p><strong>3.间隙锁</strong></p><p>间隙锁是在索引上实现的锁，它可以防止其他事务插入数据到锁定的范围内。下面是一个示例：</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 会话 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">BEGIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 对 id 大于 1 小于 10 的范围进行间隙锁定</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">SELECT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FROM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">WHERE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> AND</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FOR</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> UPDATE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 间隙锁会阻止其他事务在 id 大于 1 小于 10 的范围内插入数据，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 但允许其他事务在该范围之外的位置插入数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">COMMIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 会话 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">BEGIN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 因为会话 1 对 id 大于 1 小于 10 的范围进行了间隙锁定，所以会话 2 不能在该范围内插入数据，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 如果执行下面的语句会一直等待会话 1 的事务提交或回滚</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">INSERT INTO</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> orders (id, amount) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">VALUES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">500</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h2 id="说一说mvcc的执行原理" tabindex="-1">说一说MVCC的执行原理 <a class="header-anchor" href="#说一说mvcc的执行原理" aria-label="Permalink to “说一说MVCC的执行原理”">​</a></h2><p>MVCC（Multi-Version Concurrency Control）是一种并发控制机制，用于解决数据库并发访问中，数据一致性问题。它通过在读写操作期间保存多个数据版本，以提供并发事务间的隔离性，从而避免了传统的锁机制所带来的资源争用和阻塞问题。</p><blockquote><p>所谓的一致性问题，就是在并发事务执行时，应该看到那些数据和不应该看到那些数据。</p></blockquote><p>在 MVCC 机制中，每个事务的读操作都能看到事务开始之前的一致性数据快照，而不受其他并发事务的修改的影响。核心思想是<strong>通过创建多个数据版本，保持事务的一致性和隔离性</strong>。</p><p>使用 MVCC 机制解决了 RR 隔离级别中，部分幻读问题，但又没把全部幻读问题都解决。</p><ul><li>MVCC 解决了 RR 隔离级别中，快照读的幻读问题。多次查询快照读时，因为 RR 级别是复用 Read View（读视图），所以没有幻读问题。</li><li>但 MVCC 解决不了 RR 隔离级别中，如果遇到快照读和当前读（读取当前最新的数据）中间发生过添加操作，那么 Read View 不能复用，就出现了幻读的问题。</li></ul><p><strong>快照读和当前读</strong></p><p><strong>快照读</strong>：是指在一个事务中，读取的数据版本是在事务开始时已经存在的数据版本，而不是最新的数据版本。这种读取方式提供了事务在执行期间看到的数据视图的一致性，<strong>select 查询就是快照读</strong>。</p><p><strong>当前读</strong>：是指在事务中读取最新的数据版本，以下几种操作都是当前读：</p><ul><li>select ... for update;</li><li>select ... lock in share mode;</li><li>insert ...</li><li>update ...</li><li>delete ...</li></ul><h3 id="mvcc-实现原理" tabindex="-1"><strong>MVCC 实现原理</strong> <a class="header-anchor" href="#mvcc-实现原理" aria-label="Permalink to “MVCC 实现原理”">​</a></h3><p>MVCC 主要是依靠以下两部分实现的：</p><ol><li>隐藏字段：每个执行的 SQL 命令都有几个隐藏的字段，其中有一个事务 ID 字段，很重要。</li><li>Undo Log 链： 里面记录了 SQL 命令执行的历史数据 。</li><li>Read View（读视图或者叫一致性视图）： 包含快照读（一个快照，保存了数据库某个时刻的数据）和一些重要的属性。</li></ol><p>它的实现原理简单来说，是通过 SQL 中隐藏的字段事务 ID（自己的版本号）和 Read View 中的属性版本号进行对比，对比之后决定使用 Read View 中的快照或 undo log 中的历史数据（对比的规则是 MVCC 机制的规定，本文不展开讨论），最后再将符合的数据返回。</p><p><strong>Undo Log 链</strong></p><p>我们知道 Undo Log 主要是用于数据库中事务回滚的，但在 MVCC 机制中也发挥着重要的作用，那什么是 Undo Log 链呢？</p><p>Undo Log 链是指在每个数据对象上维护的 Undo Log 记录链表。每张表都会有与之相对应的 Undo Log 链，用于记录修改前的数据信息（以方便数据进行回滚）。</p><p><img src="`+h+'" alt=""></p><p><strong>Read View</strong></p><p>Read View（读视图）用于管理事务之间数据可见性的一种机制。Read View 在特定时刻为事务创建的一个快照，该快照包含了在该时刻所有未提交事务的事务标识符，以及其他一些辅助信息。</p><p>在 Read View 中包含了以下 4 个主要的字段：</p><ol><li>m_ids：当前活跃的事务编号集合。</li><li>min_trx_id：最小活跃事务编号。</li><li>max_trx_id：预分配事务编号，当前最大事务编号+1。</li><li>creator_trx_id：ReadView 创建者的事务编号。</li></ol><p>RC 级别中，每次快照读都会生成一个全新的 Read View，而 RR 级别中同一个事务会复用一个 Read View。</p><p>有了 Read View 和 Undo Log 链之后，并发事务在查询时就知道要读取那些数据了。</p><p><strong>判断方法</strong></p><p>判断方法是根据 Read View 中的 4 个重要字段，先去 Undo Log 中最新的数据行进行比对，如果满足下面 Read View 的判断条件，则返回当前行的数据，如果不满足则继续查找 Undo Log 的下一行数据，直到找到满足的条件的数据为止，如果查询完没有满足条件的数据，则返回 NULL。</p><p><strong>判断规则</strong></p><ol><li><p><strong>trx_id==creator_trx_id</strong>：先将 Undo Log 最新数据行中的 trx_id 和 ReadView 中的 creator_trx_id 进行对比，如果他们两个值相同，则说明是在同一个事务中执行，那么直接返回当前 Undo Log 的数据行即可，如果不相等，则继续下面流程。</p></li><li><p>**trx_id：如果 trx_id 小于 min_trx_id，则说明在执行查询时，其他事务已经提交此行数据了，那么直接返回此行数据即可，如果大于等于，则继续下面流程。</p></li><li><p><strong>trx_id&gt;max_trx_id</strong>：如果 trx_id 如果大于等于 max_trx_id，则说明该行数据比当前操作执行的晚，当前行数据不可见，继续执行后续流程。</p></li><li><p>min_trx_id&lt;=trx_id&lt;max_trx_id</p><p>：trx_id 在 min_trx_id 和 max_trx_id 之间还分为以下两种情况：</p><ol><li><strong>trx_id 在 m_ids 中</strong>：说明事务尚未执行完，该行数据不可被访问。</li><li><strong>trx_id 未在 m_ids 中</strong>：说明事务已经执行完，可以返回该行数据。</li></ol></li></ol><p>以上判断规则从 Undo Log 最新的行数据，逐行对比，直到找到匹配的数据，否则查询完未匹配上，则返回 NULL。</p><p><strong>小结</strong></p><p>MVCC 的实现主要依赖读视图 Read View 和 Undo Log 链，通过 Read View 中的 4 个字段，判断要读取 Undo Log 中数据，从而解决了数据库并发访问中，数据一致性的问题。</p><blockquote><p>MVCC 主要应用于 InnoDB 引擎中的 RC 事务隔离级别和 RR 隔离级别，其中 RC 隔离级别每次快照读都会生成一个新的 Read View，而 RR 隔离级别只在第一次快照读时生成 Read View，之后会复用 Read View，从而解决了（部分）幻读问题。</p></blockquote>',101)])])}const D=s(e,[["render",k]]);export{y as __pageData,D as default};
