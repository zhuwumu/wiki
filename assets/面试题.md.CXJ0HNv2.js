import{_ as l,c as a,a2 as i,o}from"./chunks/framework.6NRZc4eo.js";const u=JSON.parse('{"title":"了解线程池么？谈谈线程池","description":"","frontmatter":{},"headers":[],"relativePath":"面试题.md","filePath":"面试题.md","lastUpdated":null}'),r={name:"面试题.md"};function t(p,e,n,d,s,h){return o(),a("div",null,e[0]||(e[0]=[i('<h1 id="了解线程池么-谈谈线程池" tabindex="-1">了解线程池么？谈谈线程池 <a class="header-anchor" href="#了解线程池么-谈谈线程池" aria-label="Permalink to &quot;了解线程池么？谈谈线程池&quot;">​</a></h1><ol><li><p>为什么要用线程池</p><p>线程的创建、销毁比较消耗性能，采用池化的思想，复用线程，提高性能、方便管理，将任务的提交和执行进行解耦，降低使用复杂度。在处理批量任务、异步任务</p></li><li><p>实现原理</p><p>就是一个线程集合(HashSet)workerset，和一个阻塞队列workQueue。当提交一个任务时，线程池会将任务放入workQueue中，workerset会不断的从workQueue中获取任务执行，如果queue中没有，则worker阻塞，直到有了新任务。</p></li><li><p>JUC提供的ThreadPoolExecutor，对应的核心参数</p><ul><li><p>corePoolSize</p><p>大致的规则是CPU密集：N + 1</p><p>IO密集型：2N。但是要根据实际业务去调整，不算银弹。</p></li><li><p>maxPoolSize</p></li><li><p>keepAliveTime：线程空闲存活时间</p></li><li><p>unit：单位</p></li><li><p>factory：线程工厂，自定义设置一个具有辨识度的线程名</p></li><li><p>queue：队列</p><ul><li>ArrayBlockingQueue，基于数组的有界队列，FIFO</li><li>LinkedBlockingQueue，FIFO，基于链表队列，默认大小是Integer.max_value，所以也成为无界队列，采用独立锁，读写分离，性能要高于ArrayBlockingQueue。</li><li>SynchronousQueue：不存储元素的阻塞队列</li><li>PriorityBlockingQueue ：具有优先级的无界堵塞队列</li></ul></li><li><p>handler：饱和策略</p><ul><li>AbortPolicy：直接抛出异常，默认</li><li>由调用者线程去执行</li><li>将最前面的任务丢弃，并且运行当前任务</li><li>直接丢弃</li></ul></li></ul></li><li><p>execute()执行过程</p><p>当前线程&lt;核心，执行addWoker(command,true)，创建新线程来处理任务</p><p>核心&lt;当前线程，且队列未满时，将任务加入到阻塞队列中，调用queue.offer(command)方法</p><p>核心线程数&lt;当前线程&lt;最大线程数时，且队列已满时，创建新的线程来执行任务</p><p>最大线程数&lt;当前线程时，且队列已满，则执行拒绝策略reject()方法</p></li><li><p>Worker 线程模型继承 AQS 实现了锁机制 。ThreadPoolExecutor内部维护了ReentrantLock类型的mainLock，在访问worker成员变量以及进行相关数据统计记账时需要获取该重入锁。为什么用锁呢？因为workers变量用的是Hashset是线程不安全的，largestpoolsize变量也是没有用volatile修饰的，需要在锁的保护下进行访问。</p></li><li><p>创建线程池</p><p>阿里规范要求必须手动创建，因为自带的可能导致OOM，同时更方便同学理解线程池的运行规则，避免风险</p><ul><li>commons-lang3包</li><li>guava包</li><li>spring配置线程池</li></ul></li><li><p>关闭线程池</p><p>遍历线程池中所有线程，调用线程的<code>interrupt()</code>方法来中断线程。</p><p>shutdown：未执行的立刻停止，正在执行的会继续执行完。</p><p>shutdownNow：立刻停止</p></li><li><p>线程池监控</p><p>可以利用get、set方法以及一些钩子函数，动态调参、监控告警，使用开源项目dynamic tp</p></li><li><p>使用线程池的注意点</p><p>自定义线程池，防止OOM</p><p>任务异常丢失，可以加入trycath捕获。</p><p>ThreadLocal在线程池下会失效，可以考虑阿里开源的TTl类解决</p><p>现在基本上用的是spring框架，可以考虑Spring提供的ThreadPoolTaskExecutor类，与Spring有更好的集成，能够在spring关闭上下文时优雅的关闭线程，避免资源泄露的问题。</p></li></ol><h1 id="threadlocal" tabindex="-1">ThreadLocal <a class="header-anchor" href="#threadlocal" aria-label="Permalink to &quot;ThreadLocal&quot;">​</a></h1><h1 id="volatile原理" tabindex="-1">Volatile原理 <a class="header-anchor" href="#volatile原理" aria-label="Permalink to &quot;Volatile原理&quot;">​</a></h1><h1 id="netty" tabindex="-1">Netty <a class="header-anchor" href="#netty" aria-label="Permalink to &quot;Netty&quot;">​</a></h1><p>netty的线程模型是基于多Reactor模式，该模式是对经典Reactor模式的改进和扩展。</p><ol><li><p>自定义协议方式通讯</p><p>TCP：解决粘包和粘包问题，面向流的协议，使用<strong>长度字段解码器</strong></p><p>udp：固定大小，默认是65535字节，但是由于MTU的1500等限制，一般在1024字节以下，面向消息的协议</p></li><li><p>心跳机制，如何实现心跳机制idleStateHandler类</p><p>在通道设置中，增加idleStateHandler，这个处理器会触发idleStateEvent事件，该事件表示连接可能由于超时而变为不活跃状态，设置读写的空闲时间。写45，读60，最大允许超时次数3次就断开</p><p>然后在自定义的<code>ChannelInboundHandlerAdapter</code>中检测<code>IdleStateEvent</code>事件。当检测到写空闲时，可以选择发送一个心跳消息到对端。</p><ul><li>服务端采用 <code>IdleStateHandler</code>，在一段时间内(默认15s)没有读到客户端消息则说明客户端已离线，服务器会触发读超时事件断开连接</li><li>客户端采用定时(默认10s)任务方式向服务端发送一个ping消息作为心跳包，避免服务器读超时事件的发生。</li><li>服务端在收到客户端的ping消息后，将回复一条pong消息给客户端，双方都能检测对方是否活跃。</li></ul></li><li><p>重连机制</p><p>重连策略包含2个维度</p><ul><li><p>是否重连</p><p>设置重连次数来判断是否重连，重连次数耗尽则停止重连并关闭客户端</p></li><li><p>多长时间重连</p><p>短时间内频繁重连既消耗资源又没有必要，好的重连策略希望因为网络抖动偶然断开时能短时间内重连，由于服务器、网络故障长时间断开时，又能在足够大的间隔后重连。因此，默认重连策略的间隔时间随着次数的增加呈指数增长，直到达到最大为止。</p></li></ul></li><li><p>在线设备</p><p>统计在线设备，有客户端连接数时计数器加1，有客户端断开时，计数器减一，计数器保证线程安全</p></li></ol><p>注意点</p><p>防止内存泄漏</p><h1 id="jwt" tabindex="-1">JWT <a class="header-anchor" href="#jwt" aria-label="Permalink to &quot;JWT&quot;">​</a></h1><h1 id="redisson源码" tabindex="-1">Redisson源码 <a class="header-anchor" href="#redisson源码" aria-label="Permalink to &quot;Redisson源码&quot;">​</a></h1><h1 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h1><h1 id="请对比hashmap和concurrenthashmap的线程安全实现机制" tabindex="-1">请对比<code>HashMap</code>和<code>ConcurrentHashMap</code>的线程安全实现机制 <a class="header-anchor" href="#请对比hashmap和concurrenthashmap的线程安全实现机制" aria-label="Permalink to &quot;请对比`HashMap`和`ConcurrentHashMap`的线程安全实现机制&quot;">​</a></h1><h1 id="mysql的事务" tabindex="-1">MYSQL的事务 <a class="header-anchor" href="#mysql的事务" aria-label="Permalink to &quot;MYSQL的事务&quot;">​</a></h1><h1 id="如何保证mysql和redis中的数据一致性" tabindex="-1">如何保证Mysql和redis中的数据一致性？ <a class="header-anchor" href="#如何保证mysql和redis中的数据一致性" aria-label="Permalink to &quot;如何保证Mysql和redis中的数据一致性？&quot;">​</a></h1>',15)]))}const m=l(r,[["render",t]]);export{u as __pageData,m as default};
