import{_ as e,c as o,a2 as n,o as r}from"./chunks/framework.6NRZc4eo.js";const b=JSON.parse('{"title":"关键字：synchronized详解","description":"","frontmatter":{},"headers":[],"relativePath":"01.后端技术栈/多线程/关键字synchronized.md","filePath":"01.后端技术栈/多线程/关键字synchronized.md","lastUpdated":null}'),i={name:"01.后端技术栈/多线程/关键字synchronized.md"};function l(h,a,c,t,d,s){return r(),o("div",null,a[0]||(a[0]=[n('<h1 id="关键字-synchronized详解" tabindex="-1">关键字：synchronized详解 <a class="header-anchor" href="#关键字-synchronized详解" aria-label="Permalink to &quot;关键字：synchronized详解&quot;">​</a></h1><h2 id="synchronized的使用" tabindex="-1">synchronized的使用 <a class="header-anchor" href="#synchronized的使用" aria-label="Permalink to &quot;synchronized的使用&quot;">​</a></h2><p>在应用Sychronized关键字时需要把握如下注意点：</p><ul><li>一把锁只能同时被一个线程获取，没有获得锁的线程只能等待；</li><li>每个实例都对应有自己的一把锁(this),不同实例之间互不影响；例外：锁对象是*.class以及synchronized修饰的是static方法的时候，所有对象公用同一把锁</li><li>synchronized修饰的方法，无论方法正常执行完毕还是抛出异常，都会释放锁</li></ul><h3 id="对象锁" tabindex="-1">对象锁 <a class="header-anchor" href="#对象锁" aria-label="Permalink to &quot;对象锁&quot;">​</a></h3><h3 id="类锁" tabindex="-1">类锁 <a class="header-anchor" href="#类锁" aria-label="Permalink to &quot;类锁&quot;">​</a></h3><h2 id="synchronized原理分析" tabindex="-1">Synchronized原理分析 <a class="header-anchor" href="#synchronized原理分析" aria-label="Permalink to &quot;Synchronized原理分析&quot;">​</a></h2><h3 id="加锁和释放锁的原理" tabindex="-1">加锁和释放锁的原理 <a class="header-anchor" href="#加锁和释放锁的原理" aria-label="Permalink to &quot;加锁和释放锁的原理&quot;">​</a></h3><h3 id="可重入原理-加锁次数计数器" tabindex="-1">可重入原理：加锁次数计数器 <a class="header-anchor" href="#可重入原理-加锁次数计数器" aria-label="Permalink to &quot;可重入原理：加锁次数计数器&quot;">​</a></h3><h3 id="保证可见性原理-内存模型和happens-before规则" tabindex="-1">保证可见性原理：内存模型和Happens-before规则 <a class="header-anchor" href="#保证可见性原理-内存模型和happens-before规则" aria-label="Permalink to &quot;保证可见性原理：内存模型和Happens-before规则&quot;">​</a></h3><h2 id="jvm中锁的优化" tabindex="-1">JVM中锁的优化 <a class="header-anchor" href="#jvm中锁的优化" aria-label="Permalink to &quot;JVM中锁的优化&quot;">​</a></h2><h3 id="锁的类型" tabindex="-1">锁的类型 <a class="header-anchor" href="#锁的类型" aria-label="Permalink to &quot;锁的类型&quot;">​</a></h3><h3 id="自旋锁与自适应自旋锁" tabindex="-1">自旋锁与自适应自旋锁 <a class="header-anchor" href="#自旋锁与自适应自旋锁" aria-label="Permalink to &quot;自旋锁与自适应自旋锁&quot;">​</a></h3><h3 id="锁消除" tabindex="-1">锁消除 <a class="header-anchor" href="#锁消除" aria-label="Permalink to &quot;锁消除&quot;">​</a></h3><h3 id="锁粗化" tabindex="-1">锁粗化 <a class="header-anchor" href="#锁粗化" aria-label="Permalink to &quot;锁粗化&quot;">​</a></h3><h3 id="轻量级锁" tabindex="-1">轻量级锁 <a class="header-anchor" href="#轻量级锁" aria-label="Permalink to &quot;轻量级锁&quot;">​</a></h3><h3 id="偏向锁" tabindex="-1">偏向锁 <a class="header-anchor" href="#偏向锁" aria-label="Permalink to &quot;偏向锁&quot;">​</a></h3><h3 id="锁的优缺点对比" tabindex="-1">锁的优缺点对比 <a class="header-anchor" href="#锁的优缺点对比" aria-label="Permalink to &quot;锁的优缺点对比&quot;">​</a></h3><h2 id="synchronized与lock" tabindex="-1">Synchronized与Lock <a class="header-anchor" href="#synchronized与lock" aria-label="Permalink to &quot;Synchronized与Lock&quot;">​</a></h2><h3 id="synchronized的缺陷" tabindex="-1">synchronized的缺陷 <a class="header-anchor" href="#synchronized的缺陷" aria-label="Permalink to &quot;synchronized的缺陷&quot;">​</a></h3><ul><li><code>效率低</code>：锁的释放情况少，只有代码执行完毕或者异常结束才会释放锁；试图获取锁的时候不能设定超时，不能中断一个正在使用锁的线程，相对而言，Lock可以中断和设置超时</li><li><code>不够灵活</code>：加锁和释放的时机单一，每个锁仅有一个单一的条件(某个对象)，相对而言，读写锁更加灵活</li><li><code>无法知道是否成功获得锁</code>，相对而言，Lock可以拿到状态，如果成功获取锁，....，如果获取失败，.....</li></ul><h3 id="lock解决相应问题" tabindex="-1">Lock解决相应问题 <a class="header-anchor" href="#lock解决相应问题" aria-label="Permalink to &quot;Lock解决相应问题&quot;">​</a></h3><p>Lock类这里不做过多解释，主要看里面的4个方法:</p><ul><li><code>lock()</code>: 加锁</li><li><code>unlock()</code>: 解锁</li><li><code>tryLock()</code>: 尝试获取锁，返回一个boolean值</li><li><code>tryLock(long,TimeUtil)</code>: 尝试获取锁，可以设置超时</li></ul><p>Synchronized加锁只与一个条件(是否获取锁)相关联，不灵活，后来<code>Condition与Lock的结合</code>解决了这个问题。</p><p>多线程竞争一个锁时，其余未得到锁的线程只能不停的尝试获得锁，而不能中断。高并发的情况下会导致性能下降。ReentrantLock的lockInterruptibly()方法可以优先考虑响应中断。 一个线程等待时间过长，它可以中断自己，然后ReentrantLock响应这个中断，不再让这个线程继续等待。有了这个机制，使用ReentrantLock时就不会像synchronized那样产生死锁了。</p><blockquote><p><code>ReentrantLock</code>为常用类，它是一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</p></blockquote><h2 id="再深入理解" tabindex="-1">再深入理解 <a class="header-anchor" href="#再深入理解" aria-label="Permalink to &quot;再深入理解&quot;">​</a></h2><p>synchronized是通过软件(JVM)实现的，简单易用，即使在JDK5之后有了Lock，仍然被广泛的使用。</p><ul><li><strong>使用Synchronized有哪些要注意的？</strong><ul><li>锁对象不能为空，因为锁的信息都保存在对象头里</li><li>作用域不宜过大，影响程序执行的速度，控制范围过大，编写代码也容易出错</li><li>避免死锁</li><li>在能选择的情况下，既不要用Lock也不要用synchronized关键字，用java.util.concurrent包中的各种各样的类，如果不用该包下的类，在满足业务的情况下，可以使用synchronized关键，因为代码量少，避免出错</li></ul></li><li><strong>synchronized是公平锁吗？</strong></li></ul><p>synchronized实际上是非公平的，新来的线程有可能立即获得监视器，而在等待区中等候已久的线程可能再次等待，这样有利于提高性能，但是也可能会导致饥饿现象。</p>',31)]))}const k=e(i,[["render",l]]);export{b as __pageData,k as default};
