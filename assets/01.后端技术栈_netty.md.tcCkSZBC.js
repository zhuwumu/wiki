import{_ as l}from"./chunks/1699669677755.B4FROfId.js";import{_ as n,c as a,a2 as t,o as i}from"./chunks/framework.6NRZc4eo.js";const r="/wiki/images/netty/1720614498473.png",o="/wiki/images/netty/1720614577524.png",p="/wiki/images/Java/1699671228517.png",C=JSON.parse('{"title":"netty","description":"","frontmatter":{},"headers":[],"relativePath":"01.后端技术栈/netty.md","filePath":"01.后端技术栈/netty.md","lastUpdated":null}'),c={name:"01.后端技术栈/netty.md"};function s(h,e,d,u,m,b){return i(),a("div",null,e[0]||(e[0]=[t('<h1 id="netty" tabindex="-1">netty <a class="header-anchor" href="#netty" aria-label="Permalink to &quot;netty&quot;">​</a></h1><p>要求掌握技术</p><ul><li>OOP编程</li><li>多线程</li><li>IO编程</li><li>网络编程</li><li>常用的JAVA设计模式（观察者模式、命令模式、职责链模式）</li><li>常用的数据结构（双向链表）</li></ul><p>在线文档文档，实战<a href="https://waylau.com/essential-netty-in-action/" target="_blank" rel="noreferrer">https://waylau.com/essential-netty-in-action/</a></p><h2 id="io模型" tabindex="-1">IO模型 <a class="header-anchor" href="#io模型" aria-label="Permalink to &quot;IO模型&quot;">​</a></h2><ul><li><p>BIO（阻塞），适用场景，连接数较少，代码简单，易于理解。</p><p><img src="'+r+'" alt="1720614498473"></p></li><li><p>NIO（同步非阻塞），连接数多且短，代码复杂</p><p><img src="'+o+'" alt="1720614577524"></p></li><li><p>AIO（异步非阻塞，暂未广泛使用），连接数多且长，代码复杂，相册服务器。</p></li></ul><h2 id="nio" tabindex="-1">NIO <a class="header-anchor" href="#nio" aria-label="Permalink to &quot;NIO&quot;">​</a></h2><p>面向缓冲区编程，事件驱动</p><ul><li>selectot</li><li>channel</li><li>buffer（容器对象，数组）</li></ul><h3 id="bytebuffer" tabindex="-1">ByteBuffer <a class="header-anchor" href="#bytebuffer" aria-label="Permalink to &quot;ByteBuffer&quot;">​</a></h3><p><img src="'+l+'" alt="1699669677755"></p><h3 id="channel" tabindex="-1">channel <a class="header-anchor" href="#channel" aria-label="Permalink to &quot;channel&quot;">​</a></h3><ul><li>FileChannel 的读和写都复制了2次</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><h3 id="selector" tabindex="-1">selector <a class="header-anchor" href="#selector" aria-label="Permalink to &quot;selector&quot;">​</a></h3><p><img src="'+p+'" alt="1699671228517"></p><p>为了实现Selector管理多个SocketChannel，必须将具体的SocketChannel对象注册到Selector，并声明需要监听的事件（这样Selector才知道需要记录什么数据），一共有4种事件：</p><ul><li>connetc：客户端连接服务器事件， 对应值为SelectionKey.OPCONNECT(8)</li><li>accept：服务端接收客户端连接事件，对应值为SelectionKey.OPACCEPT(16)</li><li>read：读事件 ，对应值为SelectionKey.OPREAD(1)</li><li>write：写事件，对应值为SelectionKey.OPWRITE(4)</li></ul><blockquote><p>参数调优</p></blockquote><p><a href="https://blog.csdn.net/weixin_44680802/article/details/128462846" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_44680802/article/details/128462846</a></p><p>针对ScoketChannel，7个，通过.childOption设置，常用的两个如下：</p><ul><li>SO_KEEPALIVE，tcp层keepalvie，默认关闭，一般选择关闭tcp keepalive 而使用应keepalive</li><li>TCP_NODELAY：设置是否启用nagle算法，该算法是tcp在发送数据时将小的、碎片化的数据拼接成一个大的报文一起发送，以此来提高效率，默认是false（启用），如果启用可能会导致有些数据有延时，如果业务不能忍受，小报文也需要立即发送则可以禁用该算法</li></ul><p>针对ServerScoketChannel，3个，通过.Option设置，常用的一个如下：</p><ul><li>.option(ChannelOption.SO_BACKLOG, 1024) // 等待最大连接数量</li><li>.childOption(ChannelOption.SO_KEEPALIVE, true) // 服务端开启tcp keepalive</li><li>.childOption(ChannelOption.TCP_NODELAY, true) // 关闭nagle算法，tcp发送小数据时，直接发送，不再拼装，减少延迟</li></ul><blockquote><p>出现io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1的原因及解决办法 <a href="http://www.manongjc.com/detail/21-cvkttljmlbmamsz.html" target="_blank" rel="noreferrer">http://www.manongjc.com/detail/21-cvkttljmlbmamsz.html</a></p></blockquote><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">msg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">release</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>从以上的分析文章中发现，SimpleChannelInboundHandler会自动释放内存（虽然这是一种软释放）即是refCnt引用数减一。</p><p>而本人在使用SimpleChannelInboundHandler作为Server端的时候，自己手动释放了一次msg的内存，导致refCnt引用数为0，这个时候框架试图去释放一</p><p>次，就报如上错误。释放代码如：</p><p>当然前提是你使用了SimpleChannelInboundHandler作为Handler处理事务，使用AbstractChannelInboundHandler是不会主动释放内容的，这个时候需要你自己手动释放一次。</p><blockquote><p>SimpleChannelInboundHandler和ChannelInboundHandlerAdapter区别<a href="https://www.pianshen.com/article/46501669845/" target="_blank" rel="noreferrer">https://www.pianshen.com/article/46501669845/</a></p></blockquote><ul><li>SimpleChannelInboundHandler继承ChannelInboundHandlerAdapter</li><li>SimpleChannelInboundHandler自动释放内存，ChannelInboundHandlerAdapter不自动释放</li><li>在Netty中客户端的Handler一般继承SimpleChannelInboundHandler抽象类，服务端Handler一般继承ChannelInboundHandlerAdapter抽象类</li><li>在客户端，当 channelRead0() 方法完成时，你已经有了传入消息，并且已经处理完它了。当该方法返回时，SimpleChannelInboundHandler负责释放指向保存该消息的ByteBuf的内存引用。</li><li>服务端：在EchoServerHandler中，你仍然需要将传入消息回送给发送者，而 write() 操作是异步的，直到 channelRead() 方法返回后可能仍然没有完成。为此，EchoServerHandler扩展了 ChannelInboundHandlerAdapter ，其在这个时间点上不会释放消息。</li></ul><blockquote><p>示例<a href="https://mp.weixin.qq.com/s/RPTETiULRAkOS-ZTd6xM2A" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/RPTETiULRAkOS-ZTd6xM2A</a></p></blockquote>',32)]))}const g=n(c,[["render",s]]);export{C as __pageData,g as default};
