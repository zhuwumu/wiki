import{_ as l,c as a,o as r,j as e}from"./chunks/framework.DVT8N-ZV.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01.后端技术栈/多线程/JUC线程池-CompletableFuture.md","filePath":"01.后端技术栈/多线程/JUC线程池-CompletableFuture.md","lastUpdated":null}'),o={name:"01.后端技术栈/多线程/JUC线程池-CompletableFuture.md"};function n(p,t,s,u,c,d){return r(),a("div",null,[...t[0]||(t[0]=[e("p",null,[e("a",{href:"https://blog.csdn.net/2401_85648342/article/details/139976604",target:"_blank",rel:"noreferrer"},"https://blog.csdn.net/2401_85648342/article/details/139976604")],-1),e("p",null,"使用 CompletableFuture 需要配合线程池一起使用吗？为什么？CompletableFuture 默认的线程池是如何实现的？",-1),e("p",null,"CompletableFuture 使用 supplyAsync 来执行异步任务的话，可通过调用 get 或 join方法便可获取异步线程的执行结果。",-1),e("p",null,"不同：get方法返回结果，抛出的是检查异常，必须用户throw或者try/catch处理，join返回结果，抛出未检查异常。",-1)])])}const _=l(o,[["render",n]]);export{m as __pageData,_ as default};
