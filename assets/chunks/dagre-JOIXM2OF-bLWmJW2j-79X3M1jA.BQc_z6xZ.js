import{S as h,x as F,g as K,b as L,f as M,u as i,m as Y,F as Z,a as j,o as $,K as H,V,y as D,$ as W,e as q,Z as z}from"./theme.RPdm8EwZ.js";import{y as G}from"./graph-B-AWyffc-o7GFeZ6f.B-p3a5d9.js";import{i as Q}from"./layout-qaTDQOtH-Dkws4XZQ.C9AEAGt4.js";import{O as b}from"./baseUniq-D-4w9BQh-CXDlGfTI.yXZQX0xT.js";import{n as U}from"./clone-pm6OfDjU-WrCLsCa7.O8r9DURP.js";import{l as k}from"./basePickBy-DRTm9oBc-BeRiPSDA.DKAmE2VQ.js";import"./framework.BQ4u5zW0.js";function w(e){var n={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:_(e),edges:ee(e)};return b(e.graph())||(n.value=U(e.graph())),n}function _(e){return k(e.nodes(),function(n){var t=e.node(n),s=e.parent(n),r={v:n};return b(t)||(r.value=t),b(s)||(r.parent=s),r})}function ee(e){return k(e.edges(),function(n){var t=e.edge(n),s={v:n.v,w:n.w};return b(n.name)||(s.name=n.name),b(t)||(s.value=t),s})}var d=new Map,X=new Map,P=new Map,te=h(()=>{X.clear(),P.clear(),d.clear()},"clear"),I=h((e,n)=>{const t=X.get(n)||[];return i.trace("In isDescendant",n," ",e," = ",t.includes(e)),t.includes(e)},"isDescendant"),ne=h((e,n)=>{const t=X.get(n)||[];return i.info("Descendants of ",n," is ",t),i.info("Edge is ",e),e.v===n||e.w===n?!1:t?t.includes(e.v)||I(e.v,n)||I(e.w,n)||t.includes(e.w):(i.debug("Tilt, ",n,",not in descendants"),!1)},"edgeInCluster"),B=h((e,n,t,s)=>{i.warn("Copying children of ",e,"root",s,"data",n.node(e),s);const r=n.children(e)||[];e!==s&&r.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",r),r.forEach(o=>{if(n.children(o).length>0)B(o,n,t,s);else{const c=n.node(o);i.info("cp ",o," to ",s," with parent ",e),t.setNode(o,c),s!==n.parent(o)&&(i.warn("Setting parent",o,n.parent(o)),t.setParent(o,n.parent(o))),e!==s&&o!==e?(i.debug("Setting parent",o,e),t.setParent(o,e)):(i.info("In copy ",e,"root",s,"data",n.node(e),s),i.debug("Not Setting parent for node=",o,"cluster!==rootId",e!==s,"node!==clusterId",o!==e));const g=n.edges(o);i.debug("Copying Edges",g),g.forEach(f=>{i.info("Edge",f);const u=n.edge(f.v,f.w,f.name);i.info("Edge data",u,s);try{ne(f,s)?(i.info("Copying as ",f.v,f.w,u,f.name),t.setEdge(f.v,f.w,u,f.name),i.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):i.info("Skipping copy of edge ",f.v,"-->",f.w," rootId: ",s," clusterId:",e)}catch(m){i.error(m)}})}i.debug("Removing node",o),n.removeNode(o)})},"copy"),J=h((e,n)=>{const t=n.children(e);let s=[...t];for(const r of t)P.set(r,e),s=[...s,...J(r,n)];return s},"extractDescendants"),ae=h((e,n,t)=>{const s=e.edges().filter(g=>g.v===n||g.w===n),r=e.edges().filter(g=>g.v===t||g.w===t),o=s.map(g=>({v:g.v===n?t:g.v,w:g.w===n?n:g.w})),c=r.map(g=>({v:g.v,w:g.w}));return o.filter(g=>c.some(f=>g.v===f.v&&g.w===f.w))},"findCommonEdges"),C=h((e,n,t)=>{const s=n.children(e);if(i.trace("Searching children of id ",e,s),s.length<1)return e;let r;for(const o of s){const c=C(o,n,t),g=ae(n,t,c);if(c)if(g.length>0)r=c;else return c}return r},"findNonClusterChild"),O=h(e=>!d.has(e)||!d.get(e).externalConnections?e:d.has(e)?d.get(e).id:e,"getAnchorId"),ie=h((e,n)=>{if(!e||n>10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");e.nodes().forEach(function(t){e.children(t).length>0&&(i.warn("Cluster identified",t," Replacement id in edges: ",C(t,e,t)),X.set(t,J(t,e)),d.set(t,{id:C(t,e,t),clusterData:e.node(t)}))}),e.nodes().forEach(function(t){const s=e.children(t),r=e.edges();s.length>0?(i.debug("Cluster identified",t,X),r.forEach(o=>{const c=I(o.v,t),g=I(o.w,t);c^g&&(i.warn("Edge: ",o," leaves cluster ",t),i.warn("Descendants of XXX ",t,": ",X.get(t)),d.get(t).externalConnections=!0)})):i.debug("Not a cluster ",t,X)});for(let t of d.keys()){const s=d.get(t).id,r=e.parent(s);r!==t&&d.has(r)&&!d.get(r).externalConnections&&(d.get(t).id=r)}e.edges().forEach(function(t){const s=e.edge(t);i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(e.edge(t)));let r=t.v,o=t.w;if(i.warn("Fix XXX",d,"ids:",t.v,t.w,"Translating: ",d.get(t.v)," --- ",d.get(t.w)),d.get(t.v)||d.get(t.w)){if(i.warn("Fixing and trying - removing XXX",t.v,t.w,t.name),r=O(t.v),o=O(t.w),e.removeEdge(t.v,t.w,t.name),r!==t.v){const c=e.parent(r);d.get(c).externalConnections=!0,s.fromCluster=t.v}if(o!==t.w){const c=e.parent(o);d.get(c).externalConnections=!0,s.toCluster=t.w}i.warn("Fix Replacing with XXX",r,o,t.name),e.setEdge(r,o,s,t.name)}}),i.warn("Adjusted Graph",w(e)),A(e,0),i.trace(d)},"adjustClustersAndEdges"),A=h((e,n)=>{if(i.warn("extractor - ",n,w(e),e.children("D")),n>10){i.error("Bailing out");return}let t=e.nodes(),s=!1;for(const r of t){const o=e.children(r);s=s||o.length>0}if(!s){i.debug("Done, no node has children",e.nodes());return}i.debug("Nodes = ",t,n);for(const r of t)if(i.debug("Extracting node",r,d,d.has(r)&&!d.get(r).externalConnections,!e.parent(r),e.node(r),e.children("D")," Depth ",n),!d.has(r))i.debug("Not a cluster",r,n);else if(!d.get(r).externalConnections&&e.children(r)&&e.children(r).length>0){i.warn("Cluster without external connections, without a parent and with children",r,n);let o=e.graph().rankdir==="TB"?"LR":"TB";d.get(r)?.clusterData?.dir&&(o=d.get(r).clusterData.dir,i.warn("Fixing dir",d.get(r).clusterData.dir,o));const c=new G({multigraph:!0,compound:!0}).setGraph({rankdir:o,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",w(e)),B(r,e,c,r),e.setNode(r,{clusterNode:!0,id:r,clusterData:d.get(r).clusterData,label:d.get(r).label,graph:c}),i.warn("New graph after copy node: (",r,")",w(c)),i.debug("Old graph after copy",w(e))}else i.warn("Cluster ** ",r," **not meeting the criteria !externalConnections:",!d.get(r).externalConnections," no parent: ",!e.parent(r)," children ",e.children(r)&&e.children(r).length>0,e.children("D"),n),i.debug(d);t=e.nodes(),i.warn("New list of nodes",t);for(const r of t){const o=e.node(r);i.warn(" Now next level",r,o),o?.clusterNode&&A(o.graph,n+1)}},"extractor"),R=h((e,n)=>{if(n.length===0)return[];let t=Object.assign([],n);return n.forEach(s=>{const r=e.children(s),o=R(e,r);t=[...t,...o]}),t},"sorter"),re=h(e=>R(e,e.children()),"sortNodesByHierarchy"),T=h(async(e,n,t,s,r,o)=>{i.warn("Graph in recursive render:XAX",w(n),r);const c=n.graph().rankdir;i.trace("Dir in recursive render - dir:",c);const g=e.insert("g").attr("class","root");n.nodes()?i.info("Recursive render XXX",n.nodes()):i.info("No nodes found for",n),n.edges().length>0&&i.info("Recursive edges",n.edge(n.edges()[0]));const f=g.insert("g").attr("class","clusters"),u=g.insert("g").attr("class","edgePaths"),m=g.insert("g").attr("class","edgeLabels"),v=g.insert("g").attr("class","nodes");await Promise.all(n.nodes().map(async function(l){const a=n.node(l);if(r!==void 0){const p=JSON.parse(JSON.stringify(r.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,l,`
 data=`,p.height,`
Parent cluster`,r.height),n.setNode(r.id,p),n.parent(l)||(i.trace("Setting parent",l,r.id),n.setParent(l,r.id,p))}if(i.info("(Insert) Node XXX"+l+": "+JSON.stringify(n.node(l))),a?.clusterNode){i.info("Cluster identified XBX",l,a.width,n.node(l));const{ranksep:p,nodesep:E}=n.graph();a.graph.setGraph({...a.graph.graph(),ranksep:p+25,nodesep:E});const N=await T(v,a.graph,t,s,n.node(l),o),S=N.elem;Z(a,S),a.diff=N.diff||0,i.info("New compound node after recursive render XAX",l,"width",a.width,"height",a.height),j(S,a)}else n.children(l).length>0?(i.trace("Cluster - the non recursive path XBX",l,a.id,a,a.width,"Graph:",n),i.trace(C(a.id,n)),d.set(a.id,{id:C(a.id,n),node:a})):(i.trace("Node - the non recursive path XAX",l,v,n.node(l),c),await $(v,n.node(l),{config:o,dir:c}))})),await h(async()=>{const l=n.edges().map(async function(a){const p=n.edge(a.v,a.w,a.name);i.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(a)),i.info("Edge "+a.v+" -> "+a.w+": ",a," ",JSON.stringify(n.edge(a))),i.info("Fix",d,"ids:",a.v,a.w,"Translating: ",d.get(a.v),d.get(a.w)),await H(m,p)});await Promise.all(l)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(w(n))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),Q(n),i.info("Graph after layout:",JSON.stringify(w(n)));let y=0,{subGraphTitleTotalMargin:x}=V(o);return await Promise.all(re(n).map(async function(l){const a=n.node(l);if(i.info("Position XBX => "+l+": ("+a.x,","+a.y,") width: ",a.width," height: ",a.height),a?.clusterNode)a.y+=x,i.info("A tainted cluster node XBX1",l,a.id,a.width,a.height,a.x,a.y,n.parent(l)),d.get(a.id).node=a,D(a);else if(n.children(l).length>0){i.info("A pure cluster node XBX1",l,a.id,a.x,a.y,a.width,a.height,n.parent(l)),a.height+=x,n.node(a.parentId);const p=a?.padding/2||0,E=a?.labelBBox?.height||0,N=E-p||0;i.debug("OffsetY",N,"labelHeight",E,"halfPadding",p),await W(f,a),d.get(a.id).node=a}else{const p=n.node(a.parentId);a.y+=x/2,i.info("A regular node XBX1 - using the padding",a.id,"parent",a.parentId,a.width,a.height,a.x,a.y,"offsetY",a.offsetY,"parent",p,p?.offsetY,a),D(a)}})),n.edges().forEach(function(l){const a=n.edge(l);i.info("Edge "+l.v+" -> "+l.w+": "+JSON.stringify(a),a),a.points.forEach(S=>S.y+=x/2);const p=n.node(l.v);var E=n.node(l.w);const N=q(u,a,d,t,p,E,s);z(a,N)}),n.nodes().forEach(function(l){const a=n.node(l);i.info(l,a.type,a.diff),a.isGroup&&(y=a.diff)}),i.warn("Returning from recursive render XAX",g,y),{elem:g,diff:y}},"recursiveRender"),pe=h(async(e,n)=>{const t=new G({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:e.config?.nodeSpacing||e.config?.flowchart?.nodeSpacing||e.nodeSpacing,ranksep:e.config?.rankSpacing||e.config?.flowchart?.rankSpacing||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),s=n.select("g");F(s,e.markers,e.type,e.diagramId),K(),L(),M(),te(),e.nodes.forEach(o=>{t.setNode(o.id,{...o}),o.parentId&&t.setParent(o.id,o.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(o=>{if(o.start===o.end){const c=o.start,g=c+"---"+c+"---1",f=c+"---"+c+"---2",u=t.node(c);t.setNode(g,{domId:g,id:g,parentId:u.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),t.setParent(g,u.parentId),t.setNode(f,{domId:f,id:f,parentId:u.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),t.setParent(f,u.parentId);const m=structuredClone(o),v=structuredClone(o),y=structuredClone(o);m.label="",m.arrowTypeEnd="none",m.id=c+"-cyclic-special-1",v.arrowTypeStart="none",v.arrowTypeEnd="none",v.id=c+"-cyclic-special-mid",y.label="",u.isGroup&&(m.fromCluster=c,y.toCluster=c),y.id=c+"-cyclic-special-2",y.arrowTypeStart="none",t.setEdge(c,g,m,c+"-cyclic-special-0"),t.setEdge(g,f,v,c+"-cyclic-special-1"),t.setEdge(f,c,y,c+"-cyc<lic-special-2")}else t.setEdge(o.start,o.end,{...o},o.id)}),i.warn("Graph at first:",JSON.stringify(w(t))),ie(t),i.warn("Graph after XAX:",JSON.stringify(w(t)));const r=Y();await T(s,t,e.type,e.diagramId,void 0,r)},"render");export{pe as render};
