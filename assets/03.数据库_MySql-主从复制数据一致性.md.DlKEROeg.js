import{_ as l,c as i,o,ah as e,au as r,av as t,aw as n}from"./chunks/framework.Dgw6jcLr.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"03.数据库/MySql-主从复制数据一致性.md","filePath":"03.数据库/MySql-主从复制数据一致性.md","lastUpdated":null}'),s={name:"03.数据库/MySql-主从复制数据一致性.md"};function h(p,a,d,g,_,c){return o(),i("div",null,[...a[0]||(a[0]=[e('<h2 id="_1-什么是数据一致性" tabindex="-1">1.什么是数据一致性？ <a class="header-anchor" href="#_1-什么是数据一致性" aria-label="Permalink to “1.什么是数据一致性？”">​</a></h2><p>数据一致性是指在一个系统中，数据在不同的部分、不同的时间点，以及不同的操作之间保持一致的状态。</p><p>数据一致性通常体现在以下几点：</p><ol><li><strong>数据一致性</strong>：确保数据的完整性意味着数据在存储和传输过程中没有被损坏或丢失。这包括数据的准确性、完整性和有效性。例如，在一个电商系统中，商品的库存数量应该是准确的。如果一个用户购买了一件商品，库存数量应该相应地减少。如果库存数量显示不正确，就会导致数据不一致。</li><li><strong>事务一致性</strong>：在数据库系统中，事务是一组操作的集合，这些操作要么全部成功执行，要么全部回滚。事务一致性确保在一个事务中对数据的修改在事务提交后对所有用户都是可见的，并且如果事务失败，数据将恢复到事务开始之前的状态。例如，在一个在线预订系统中，用户预订了一个酒店房间，系统应该确保这个房间在预订期间不能被其他用户预订。如果出现多个用户同时预订同一个房间的情况，就会导致数据不一致。</li><li><strong>多副本一致性</strong>：在分布式系统中，数据通常会存储在多个副本中，以提高系统的可用性和性能。多副本一致性确保不同副本之间的数据保持一致。例如，在一个云存储服务中，用户上传了一个文件，这个文件会被存储在多个数据中心的服务器上。如果用户对文件进行了修改，云存储服务应该确保所有副本都被更新，以保证用户在任何地方访问文件时都能看到最新的版本。</li><li><strong>时间一致性</strong>：时间一致性要求数据在不同的时间点上保持一致，这包括数据的时效性和顺序性。例如，在一个股票交易系统中，交易订单的处理应该按照时间顺序进行。如果订单的处理顺序出现错误，就会导致交易数据不一致。</li></ol><blockquote><p>PS：我们本文主要讨论的是多副本在同一时间上的数据一致性问题。</p></blockquote><h2 id="_2-主从复制" tabindex="-1">2.主从复制 <a class="header-anchor" href="#_2-主从复制" aria-label="Permalink to “2.主从复制”">​</a></h2><p>MySQL 主从复制是一种将 MySQL 主数据库的数据，同步到其他的数据库的一种机制，从而实现数据的冗余备份和负载均衡，平行扩展了数据库的查询能力。</p><p>主从数据库基本概念：</p><ol><li><strong>主数据库（Master）</strong>：主数据库是数据的主要来源，负责接收和处理所有的写操作（INSERT、UPDATE、DELETE 等）。主数据库将所有的写操作记录到二进制日志（Binary Log）中，这些日志记录了数据库的变更历史。</li><li><strong>从数据库（Slave）</strong>：从数据库通过复制主数据库的二进制日志来同步数据。从数据库可以处理读操作（SELECT），从而分担主数据库的负载。</li></ol><p>MySQL 主从复制流程如下：</p><p><img src="'+r+'" alt=""></p><p>它的主要执行流程如下：</p><ol><li>主数据库接收到一个写操作（如 INSERT、UPDATE、DELETE）时，会将这个操作记录到二进制日志（Binary Log）中，将数据修改的操作按顺序记录下来。</li><li>从数据库 IO 线程会自动连接主服务，从二进制中读取同步数据，记录到中继日志（Relay Log）中。</li><li>从数据库的 SQL 线程会定期从中继日志中获取同步数据，写入到从数据库中。</li></ol><h2 id="_3-mysql主从同步类型" tabindex="-1">3.MySQL主从同步类型 <a class="header-anchor" href="#_3-mysql主从同步类型" aria-label="Permalink to “3.MySQL主从同步类型”">​</a></h2><p>MySQL 主从同步方式有以下三种：</p><h3 id="_3-1-异步复制" tabindex="-1">3.1 异步复制 <a class="header-anchor" href="#_3-1-异步复制" aria-label="Permalink to “3.1 异步复制”">​</a></h3><p>异步复制默认的主从同步复制模式，在这种模式下，<strong>主服务器提交事务后立即返回客户端，无需等待从服务器确认是否成功接收并应用了事务</strong>，从服务器会在后台独立地接收并应用事务日志。</p><p>异步同步流程如下（红色部分为主要执行流程）：</p><p><img src="'+r+'" alt=""></p><h4 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to “优点”">​</a></h4><ol><li><strong>性能</strong>：异步复制模式下，主服务器的写操作不会因为等待从服务器的确认而被阻塞，因此可以提供更高的写入吞吐量。</li><li><strong>简单</strong>：配置和管理相对简单。</li><li><strong>成本</strong>：不需要额外的硬件资源支持，因为不需要高速的网络连接来保证同步。</li></ol><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to “缺点”">​</a></h4><p><strong>数据丢失问题</strong>：在主服务器故障的情况下，可能存在数据未完全同步到从服务器的情况，导致数据丢失或不一致。</p><h3 id="_3-2-同步复制" tabindex="-1">3.2 同步复制 <a class="header-anchor" href="#_3-2-同步复制" aria-label="Permalink to “3.2 同步复制”">​</a></h3><p>同步复制是一种最为严格的复制模式，它要求<strong>主服务器在提交一个事务之前，必须等待所有从服务器确认确认接收到并应用了事务之后，主服务器才会向客户端返回事务提交成功的消息</strong>。</p><p>同步复制执行流程如下：</p><p><img src="'+t+'" alt=""></p><h4 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to “优点”">​</a></h4><ol><li><strong>数据一致性</strong>：提供了更高的数据一致性保障，因为主服务器必须等待从服务器确认才能完成事务提交。</li><li><strong>容错性</strong>：即使主服务器发生故障，至少有一个从服务器拥有最新的数据，从而减少了数据丢失的风险。</li></ol><h4 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to “缺点”">​</a></h4><ol><li><strong>性能开销大</strong>：主库需要等待所有从库的响应，这会导致事务提交的延迟增加，尤其是在从库数量较多或网络状况不佳时，性能下降明显。</li><li><strong>单点故障风险</strong>：如果一个从库出现故障，可能会导致整个系统的阻塞，因为主库需要等待所有从库的确认。</li></ol><h3 id="_3-3-半同步复制" tabindex="-1">3.3 半同步复制 <a class="header-anchor" href="#_3-3-半同步复制" aria-label="Permalink to “3.3 半同步复制”">​</a></h3><p>半同步复制是一种折衷方案，它结合了异步复制的高性能和同步复制的高可靠性。在半同步复制模式下，主服务器在提交一个事务之前，需要等待至少一个从服务器确认接收到该事务的日志，但不需要等待从服务器完成应用。</p><p>半同步执行流程如下：</p><p><img src="'+n+'" alt=""></p><h4 id="优点-2" tabindex="-1">优点 <a class="header-anchor" href="#优点-2" aria-label="Permalink to “优点”">​</a></h4><ol><li><strong>数据一致性较好</strong>：相比异步复制，提供了更好的数据一致性保障。</li><li><strong>性能影响较小</strong>：相比同步复制，半同步复制的性能开销较小，因为只需要等待一个从库的确认。</li><li><strong>灵活性较高</strong>：可以根据需要调整等待的从服务器数量，以适应不同的性能和可靠性需求。</li></ol><h4 id="缺点-2" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-2" aria-label="Permalink to “缺点”">​</a></h4><ol><li><strong>性能波动风险</strong>：在网络延迟较高或从库负载较大的情况下，可能会导致主库等待从库确认的时间过长，从而影响性能。</li><li><strong>配置复杂</strong>：相比异步复制，配置和管理稍微复杂一些。</li></ol><h2 id="_4-小结" tabindex="-1">4.小结 <a class="header-anchor" href="#_4-小结" aria-label="Permalink to “4.小结”">​</a></h2><p>因此，<strong>想要保证数据完全一致性需要使用同步复制</strong>，但这会牺牲一定的性能；因此在生产环境我们可以使用半同步保证较好的数据一致性即可；而默认的异步方式实现最简单、性能最好，但可能存在数据不一致的风险，虽然发生的概率极低（生产环境也可以使用）。</p>',41)])])}const f=l(s,[["render",h]]);export{b as __pageData,f as default};
