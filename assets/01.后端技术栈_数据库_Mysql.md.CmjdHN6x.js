import{_ as e,c as a,a2 as i,o as t}from"./chunks/framework.6NRZc4eo.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01.后端技术栈/数据库/Mysql.md","filePath":"01.后端技术栈/数据库/Mysql.md","lastUpdated":null}'),r={name:"01.后端技术栈/数据库/Mysql.md"};function s(n,l,o,p,c,h){return t(),a("div",null,l[0]||(l[0]=[i('<h3 id="_1、说说什么是事务" tabindex="-1">1、说说什么是事务 <a class="header-anchor" href="#_1、说说什么是事务" aria-label="Permalink to &quot;1、说说什么是事务&quot;">​</a></h3><p><a href="https://www.cnblogs.com/binghe001/p/13620501.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/binghe001/p/13620501.html</a></p><p>本质考察：事务的四大特性</p><p>事务：单个逻辑工作单元组成的一系列操作，要么全部执行，要么全部不不执行。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性、持久性）属性。</p><ul><li>A：原子性，Atomicity</li><li>C：一致性，Consistency</li><li>I：隔离性，Isolation</li><li>D：持久性，Durability</li></ul><h3 id="_2、并发事务带来的问题" tabindex="-1">2、并发事务带来的问题 <a class="header-anchor" href="#_2、并发事务带来的问题" aria-label="Permalink to &quot;2、并发事务带来的问题&quot;">​</a></h3><p>本质考察：带来哪些问题，有哪些解决方案</p><p>带来的问题：</p><ul><li>脏写：多个事务对数据进行更新，互相不知道对方的存在， 最后的更新将重写由其它事务所做的更新，这将导致数据丢失。</li><li>脏读：一个事务在更新时，在完成提交前，另一个事务读取同一条数据，如果不加控制，第二条事务就读到了“脏”数据， 并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做”脏读” 。</li><li>不可重复读：</li><li>幻读：</li></ul><p>问题的解决方案：</p><p>为避免上面出现的几种情况，在标准SQL规范中，定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。以下4种隔离级别限制从低到高，性能从高到低。高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。</p><ul><li>读未提交：允许脏读，但不允许更新丢失，一个事务写时，不允许其他事务写，可以读。该隔离级别可通过“排他写锁”实现。</li><li>读已提交： 这可以通过“瞬间共享读锁”和“排他写锁”实现 。 可避免 脏读，不可避免 不可重复读、虚读。Oracle采用读已提交。</li><li>可重复读： 可避免 脏读、不可重复读， 不可避免 虚读。MySQL采用可重复读。</li><li>序列化： 可避免 脏读、不可重复读、幻读情况的发生。</li></ul><h3 id="_3、mysql最左匹配的原理从索引结构解释一下" tabindex="-1">3、mysql最左匹配的原理从索引结构解释一下 <a class="header-anchor" href="#_3、mysql最左匹配的原理从索引结构解释一下" aria-label="Permalink to &quot;3、mysql最左匹配的原理从索引结构解释一下&quot;">​</a></h3><p><a href="https://www.zhihu.com/question/52536048/answer/3568300352" target="_blank" rel="noreferrer">https://www.zhihu.com/question/52536048/answer/3568300352</a></p><p>联合索引：先导列（最左边的列）选择区分度高的，同时也需要考虑查询命中率的问题。</p><p>在一定条件下可以不遵循最左前缀原则，Mysql8.0引入了index skip scan。a、b、c种where b=5也是会走索引的。</p><p>原理：使用了穷举法，有局限性，适用于区分度比较小的字段。</p><p>讲一下联合索引的最左前缀原则，为什么得最左匹配，不按照这个来为什么失效？</p><p>最左前缀原则就是只要查询的是联合索引的最左 N 个字段，就可以利用该联合索引来加速查询。 不按照最左匹配来为什么失效，其原因就在于联合索引的 B+ 树中的键值是排好序的。不过，这里指的排好序，其实是相对的，举个例子，有 (a, b, c) 联合索引，a 首先是排序好的，而 b 列是在 a 列排序的基础上做的排序，同样的 c 是在 a,b 有序的基础上做的排序。所以说，如果有 <code>where a = xxx order by b = xxx</code> 这种请求的话，是可以直接在这颗联合索引树上查出来的，不用对 b 列进行额外的排序；而如果是 <code>where a = xxx order by c = xxx</code> 这种请求的话，还需要额外对 c 列进行一次排序才行。 另外，如果有对 a,b,c 的联合条件查询的话，并且 a 是模糊匹配或者说是范围查询的话，其实并不能完全踩中联合索引（a,b,c），a 列右边的所有列都无法使用索引进行快速定位了。所以这个时候就需要进行回表判断。也就是说数据库会首先根据索引来查找记录，然后再根据 where 条件来过滤记录。 不过在 MySQL 5.6 中支持了索引下推 ICP，数据库在取出索引的同时，会根据 where 条件直接过滤掉不满足条件的记录，减少回表次数</p><h3 id="_4、mysql如果要平滑不停机的情况下分库分表怎么做" tabindex="-1">4、mysql如果要平滑不停机的情况下分库分表怎么做？ <a class="header-anchor" href="#_4、mysql如果要平滑不停机的情况下分库分表怎么做" aria-label="Permalink to &quot;4、mysql如果要平滑不停机的情况下分库分表怎么做？&quot;">​</a></h3><p><a href="https://blog.csdn.net/weixin_37057698/article/details/141238107" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_37057698/article/details/141238107</a></p><p><a href="https://blog.csdn.net/kefengwang/article/details/81213050" target="_blank" rel="noreferrer">https://blog.csdn.net/kefengwang/article/details/81213050</a></p><ul><li>第一阶段：在线双写，查询走老库 <ul><li>建立好新的库表结构，数据写入老库的同时，也写入拆分的新库。</li><li>数据迁移，使用数据迁移程序，将旧库中的历史数据迁移到新库。</li><li>使用定时任务，新旧库的数据对比，把差异补齐。</li></ul></li><li>第二阶段：在线双写，查询走新库 <ul><li>完成了历史数据的同步和校验。</li><li>把数据的读切换到新库。</li></ul></li><li>第三阶段：旧库下线 <ul><li>旧库不再写入新的数据</li><li>经过一段时间，确定旧库没有请求之后，可以下线老库。</li></ul></li></ul><h3 id="介绍一下mysql索引-为什么用b-树" tabindex="-1">介绍一下mysql索引？ 为什么用B+树？ <a class="header-anchor" href="#介绍一下mysql索引-为什么用b-树" aria-label="Permalink to &quot;介绍一下mysql索引？ 为什么用B+树？&quot;">​</a></h3>',24)]))}const u=e(r,[["render",s]]);export{b as __pageData,u as default};
