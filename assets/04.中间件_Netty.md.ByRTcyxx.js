import{_ as l,c as a,o as t,aj as n,b2 as i,b3 as r,aw as o,b4 as h}from"./chunks/framework.Ce8QDWxt.js";const f=JSON.parse('{"title":"netty","description":"","frontmatter":{},"headers":[],"relativePath":"04.中间件/Netty.md","filePath":"04.中间件/Netty.md","lastUpdated":null}'),s={name:"04.中间件/Netty.md"};function p(c,e,d,b,m,u){return t(),a("div",null,[...e[0]||(e[0]=[n('<h1 id="netty" tabindex="-1">netty <a class="header-anchor" href="#netty" aria-label="Permalink to “netty”">​</a></h1><p>要求掌握技术</p><ul><li>OOP编程</li><li>多线程</li><li>IO编程</li><li>网络编程</li><li>常用的JAVA设计模式（观察者模式、命令模式、职责链模式）</li><li>常用的数据结构（双向链表）</li></ul><p>在线文档文档，实战<a href="https://waylau.com/essential-netty-in-action/" target="_blank" rel="noreferrer">https://waylau.com/essential-netty-in-action/</a></p><h2 id="netty详解" tabindex="-1">Netty详解 <a class="header-anchor" href="#netty详解" aria-label="Permalink to “Netty详解”">​</a></h2><p><a href="https://blog.csdn.net/golove666/article/details/137263541" target="_blank" rel="noreferrer">https://blog.csdn.net/golove666/article/details/137263541</a></p><h2 id="io模型" tabindex="-1">IO模型 <a class="header-anchor" href="#io模型" aria-label="Permalink to “IO模型”">​</a></h2><ul><li><p>BIO（阻塞），适用场景，连接数较少，代码简单，易于理解。</p><p><img src="'+i+'" alt="1720614498473"></p></li><li><p>NIO（同步非阻塞），连接数多且短，代码复杂</p><p><img src="'+r+'" alt="1720614577524"></p></li><li><p>AIO（异步非阻塞，暂未广泛使用），连接数多且长，代码复杂，相册服务器。</p></li></ul><h2 id="nio" tabindex="-1">NIO <a class="header-anchor" href="#nio" aria-label="Permalink to “NIO”">​</a></h2><p>面向缓冲区编程，事件驱动</p><ul><li>selectot</li><li>channel</li><li>buffer（容器对象，数组）</li></ul><h3 id="bytebuffer" tabindex="-1">ByteBuffer <a class="header-anchor" href="#bytebuffer" aria-label="Permalink to “ByteBuffer”">​</a></h3><p><img src="'+o+'" alt="1699669677755"></p><h3 id="channel" tabindex="-1">channel <a class="header-anchor" href="#channel" aria-label="Permalink to “channel”">​</a></h3><ul><li>FileChannel 的读和写都复制了2次</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><h3 id="selector" tabindex="-1">selector <a class="header-anchor" href="#selector" aria-label="Permalink to “selector”">​</a></h3><p><img src="'+h+'" alt="1699671228517"></p><p>为了实现Selector管理多个SocketChannel，必须将具体的SocketChannel对象注册到Selector，并声明需要监听的事件（这样Selector才知道需要记录什么数据），一共有4种事件：</p><ul><li>connetc：客户端连接服务器事件， 对应值为SelectionKey.OPCONNECT(8)</li><li>accept：服务端接收客户端连接事件，对应值为SelectionKey.OPACCEPT(16)</li><li>read：读事件 ，对应值为SelectionKey.OPREAD(1)</li><li>write：写事件，对应值为SelectionKey.OPWRITE(4)</li></ul><blockquote><p>参数调优</p></blockquote><p><a href="https://blog.csdn.net/weixin_44680802/article/details/128462846" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_44680802/article/details/128462846</a></p><p>针对ScoketChannel，7个，通过.childOption设置，常用的两个如下：</p><ul><li>SO_KEEPALIVE，tcp层keepalvie，默认关闭，一般选择关闭tcp keepalive 而使用应keepalive</li><li>TCP_NODELAY：设置是否启用nagle算法，该算法是tcp在发送数据时将小的、碎片化的数据拼接成一个大的报文一起发送，以此来提高效率，默认是false（启用），如果启用可能会导致有些数据有延时，如果业务不能忍受，小报文也需要立即发送则可以禁用该算法</li></ul><p>针对ServerScoketChannel，3个，通过.Option设置，常用的一个如下：</p><ul><li>.option(ChannelOption.SO_BACKLOG, 1024) // 等待最大连接数量</li><li>.childOption(ChannelOption.SO_KEEPALIVE, true) // 服务端开启tcp keepalive</li><li>.childOption(ChannelOption.TCP_NODELAY, true) // 关闭nagle算法，tcp发送小数据时，直接发送，不再拼装，减少延迟</li></ul><blockquote><p>出现io.netty.util.IllegalReferenceCountException: refCnt: 0, decrement: 1的原因及解决办法 <a href="http://www.manongjc.com/detail/21-cvkttljmlbmamsz.html" target="_blank" rel="noreferrer">http://www.manongjc.com/detail/21-cvkttljmlbmamsz.html</a></p></blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">msg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">release</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><p>从以上的分析文章中发现，SimpleChannelInboundHandler会自动释放内存（虽然这是一种软释放）即是refCnt引用数减一。</p><p>而本人在使用SimpleChannelInboundHandler作为Server端的时候，自己手动释放了一次msg的内存，导致refCnt引用数为0，这个时候框架试图去释放一</p><p>次，就报如上错误。释放代码如：</p><p>当然前提是你使用了SimpleChannelInboundHandler作为Handler处理事务，使用AbstractChannelInboundHandler是不会主动释放内容的，这个时候需要你自己手动释放一次。</p><blockquote><p>SimpleChannelInboundHandler和ChannelInboundHandlerAdapter区别<a href="https://www.pianshen.com/article/46501669845/" target="_blank" rel="noreferrer">https://www.pianshen.com/article/46501669845/</a></p></blockquote><ul><li>SimpleChannelInboundHandler继承ChannelInboundHandlerAdapter</li><li>SimpleChannelInboundHandler自动释放内存，ChannelInboundHandlerAdapter不自动释放</li><li>在Netty中客户端的Handler一般继承SimpleChannelInboundHandler抽象类，服务端Handler一般继承ChannelInboundHandlerAdapter抽象类</li><li>在客户端，当 channelRead0() 方法完成时，你已经有了传入消息，并且已经处理完它了。当该方法返回时，SimpleChannelInboundHandler负责释放指向保存该消息的ByteBuf的内存引用。</li><li>服务端：在EchoServerHandler中，你仍然需要将传入消息回送给发送者，而 write() 操作是异步的，直到 channelRead() 方法返回后可能仍然没有完成。为此，EchoServerHandler扩展了 ChannelInboundHandlerAdapter ，其在这个时间点上不会释放消息。</li></ul><blockquote><p>示例<a href="https://mp.weixin.qq.com/s/RPTETiULRAkOS-ZTd6xM2A" target="_blank" rel="noreferrer">https://mp.weixin.qq.com/s/RPTETiULRAkOS-ZTd6xM2A</a></p></blockquote><h2 id="心跳demo" tabindex="-1">心跳demo <a class="header-anchor" href="#心跳demo" aria-label="Permalink to “心跳demo”">​</a></h2><p><a href="https://github.com/yongshun/some_java_code/tree/master/NettyHeartbeatDemo" target="_blank" rel="noreferrer">https://github.com/yongshun/some_java_code/tree/master/NettyHeartbeatDemo</a></p>',36)])])}const _=l(s,[["render",p]]);export{f as __pageData,_ as default};
