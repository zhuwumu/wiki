import{_ as i,c as a,o as l,ah as t}from"./chunks/framework.Dgw6jcLr.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"07.代码人生/开发注意事项.md","filePath":"07.代码人生/开发注意事项.md","lastUpdated":null}'),e={name:"07.代码人生/开发注意事项.md"};function p(n,s,h,k,r,d){return l(),a("div",null,[...s[0]||(s[0]=[t(`<h2 id="mysql" tabindex="-1">MySql <a class="header-anchor" href="#mysql" aria-label="Permalink to “MySql”">​</a></h2><ol><li><p>分页排序时，排序字段值如果存在大量相同数据，第二页查询可能导致重复，因为值相同，排序会混乱</p><p>追加id排序</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sex,id</span></span></code></pre></div></li><li><p>GROUP_CONCAT聚合</p><p>语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator &#39;分隔符&#39;] )。可以使用分隔符。</p><p>一、报错原因</p><ol><li><p>数据超出默认长度。通常是1024字节，当超出时，字符串被截断，导致数据不完整或报错。</p><p>解决办法：修改配置文件group_concat_max_len = 102400，重启生效。</p><p>查看：SHOW VARIABLES LIKE &quot;group_concat_max_len&quot;;</p></li><li><p>排序和去重问题。不正确的使用ORDER BY和DISTINCT，可能导致结果顺序错乱或数据重复。</p><p>解决办法：加上去重和排序。</p><p>SELECT GROUP_CONCAT(DISTINCT column_name ORDER BY column_name)FROM table_nameGROUP BY some_column;</p></li></ol><p>二、用法</p><ol><li><p>标准SQL中使用聚合函数，查询字段必须在group by 下显性显示。严格模式下</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sys_user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">group by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id #正确执行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sys_user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">group by</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> # 报错this </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">is</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incompatible </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">with</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sql_mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">only_full_group_by</span></span></code></pre></div><p>解释：这是mysql对group by 对主键的豁免权。</p><p>当使用主键（如<code>id</code>）作为分组字段时，由于主键的唯一性保证每组仅包含一条记录，此时<code>SELECT *</code>中的非聚合字段（如<code>name</code>）天然具有确定性值，因此MySQL允许省略这些字段的显式声明。这是对标准SQL的扩展优化‌</p></li></ol></li><li></li></ol>`,2)])])}const g=i(e,[["render",p]]);export{c as __pageData,g as default};
