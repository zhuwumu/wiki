import{_ as e,c as r,o as l,ah as i,c8 as t}from"./chunks/framework.DVT8N-ZV.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"05.架构/架构900讲/MQ.md","filePath":"05.架构/架构900讲/MQ.md","lastUpdated":null}'),o={name:"05.架构/架构900讲/MQ.md"};function c(s,a,n,_,d,h){return l(),r("div",null,[...a[0]||(a[0]=[i('<h2 id="_038、mq中间件是如何实现可靠性投递的" tabindex="-1">038、MQ中间件是如何实现可靠性投递的 <a class="header-anchor" href="#_038、mq中间件是如何实现可靠性投递的" aria-label="Permalink to “038、MQ中间件是如何实现可靠性投递的”">​</a></h2><p>无论什么产品，设计基本都是这样的。</p><p><img src="'+t+'" alt="4e220c2a-9035-466e-a2d7-3a87a395e5c0"></p><ol><li>发送阶段：遇到高延迟，producer会多次重发消息，直到broker ack确认，过程中broker 会自动去重，超时producer产生异常，应用进行捕获提示。</li><li>存储阶段：Broker先刷盘再ack确认，即便ack失败，消息不会丢失，多次重试，知道producer 接收，会导致消息积压。</li><li>消费阶段：broker想customer发数据，一段时间未接收，自动重发，直到Consumer Ack确认，consumer注意幂等设计。</li></ol><p>常见问题及解决方法：</p><ol><li>异步刷盘（默认NSYNC_FLUSH），改为同步刷盘。只有真正的写入到磁盘之后，再发送acK请求</li><li>存储介质损坏，建议采用Raid10或分布式存储。</li><li>不要启用自动ACK，customer要手动提交ack确认。RabbitMQ存在此问题。</li></ol><h2 id="_045" tabindex="-1">045 <a class="header-anchor" href="#_045" aria-label="Permalink to “045”">​</a></h2><h2 id="_046" tabindex="-1">046 <a class="header-anchor" href="#_046" aria-label="Permalink to “046”">​</a></h2><h2 id="_047" tabindex="-1">047 <a class="header-anchor" href="#_047" aria-label="Permalink to “047”">​</a></h2><h2 id="_048" tabindex="-1">048 <a class="header-anchor" href="#_048" aria-label="Permalink to “048”">​</a></h2>',10)])])}const k=e(o,[["render",c]]);export{p as __pageData,k as default};
