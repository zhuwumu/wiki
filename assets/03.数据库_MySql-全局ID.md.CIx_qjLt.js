import{_ as a,c as r,o as i,ah as t}from"./chunks/framework.Dgw6jcLr.js";const g=JSON.parse('{"title":"水平分表如何保持id的唯一","description":"","frontmatter":{},"headers":[],"relativePath":"03.数据库/MySql-全局ID.md","filePath":"03.数据库/MySql-全局ID.md","lastUpdated":null}'),o={name:"03.数据库/MySql-全局ID.md"};function n(l,e,d,s,h,p){return i(),r("div",null,[...e[0]||(e[0]=[t('<h1 id="水平分表如何保持id的唯一" tabindex="-1">水平分表如何保持id的唯一 <a class="header-anchor" href="#水平分表如何保持id的唯一" aria-label="Permalink to “水平分表如何保持id的唯一”">​</a></h1><p>分库分表之后，需要保证ID唯一，既然是分库分表，所以不能使用ID自增。常见方案如下及各自优缺点。</p><h2 id="uuid" tabindex="-1"><strong>UUID</strong> <a class="header-anchor" href="#uuid" aria-label="Permalink to “UUID”">​</a></h2><p>JDK自带工具类，生成无序的36位字符串，一般去掉中间的4个-，使用32位。</p><ul><li>优点：简单方便，本地生成，出错率低。</li><li>缺点：32个字符串，占用空间较大，无序，写入性能较差，可读性差。</li></ul><h2 id="雪花算法" tabindex="-1"><strong>雪花算法</strong> <a class="header-anchor" href="#雪花算法" aria-label="Permalink to “雪花算法”">​</a></h2><p>生成19位long类型整数。组成部分，主要是由毫秒时间戳+5位房间号+5位机器号+12位不同的ID</p><ul><li><p>优点：有序递增</p></li><li><p>缺点：</p><ul><li><p><strong>服务器时钟回拨</strong>，导致生成相同ID</p></li><li><p><strong>节点 ID 依赖问题</strong>：雪花算法需要为每个节点分配唯一的节点 ID 来保证生成的 ID 的全局唯一性。节点 ID 的分配需要有一定的管理和调度，特别是在动态扩容或缩容时，节点 ID 的管理可能较为复杂。</p></li></ul></li></ul><h2 id="百度uidgenerator-推荐" tabindex="-1"><strong>百度Uidgenerator</strong>（推荐） <a class="header-anchor" href="#百度uidgenerator-推荐" aria-label="Permalink to “百度Uidgenerator（推荐）”">​</a></h2><p>类似雪花算法，相比较雪花算法，时间bit变少了，而机器ID的bit变多了。</p><p>时间回拨产生的原因：分布式系统中，各机器同步服务器时间，一般每2小时同步一次，在 10ms 以内完成。</p><p>解决时钟回拨：传统的雪花算法都是通过<code>System.currentTimeMillis()</code>来获取时间并与上一次时间进行比对，这样严重依赖服务器时间。而百度的时间类型是<code>AtomicLong</code>，且通过<code>incrementAndGet()</code>方法获取下一次时间，从而脱离了对服务器的依赖，也不会有时间回拨的问题（这种做法也有一个小问题，即分布式ID中的时间信息可能并不是这个ID真正产生的时间点）</p><p>源码： <a href="https://github.com/baidu/uid-generator" target="_blank" rel="noreferrer">https://github.com/baidu/uid-generator</a></p><p>UidGenerator 是这样解决时间回拨问题的：UidGenerator 的每个实例中，都维护一个本地时钟缓存，用于记录当前时间戳。这个本地时钟会定期与系统时钟进行同步，如果检测到系统时钟往前走了（出现了时钟回拨），则将本地时钟调整为系统时钟。</p><h2 id="redis通过自增命令来生成分布式id" tabindex="-1"><strong>Redis通过自增命令来生成分布式ID</strong> <a class="header-anchor" href="#redis通过自增命令来生成分布式id" aria-label="Permalink to “Redis通过自增命令来生成分布式ID”">​</a></h2><ul><li>优点：单调递增，不影响数据库写入性能，可读性高</li><li>缺点：需要额外引入redis，链路变长导致出错概率增加。开发成本相对较高。</li></ul><h2 id="数据库号段" tabindex="-1"><strong>数据库号段</strong> <a class="header-anchor" href="#数据库号段" aria-label="Permalink to “数据库号段”">​</a></h2><p>数据库号段，是在“数据库⾃增ID”⽅案上做的优化，实现⽅式如下：</p><p>（1）从中央数据库中获取出⼀批分布式ID，并缓存到分布式ID服务本地，业务系统获取分布式ID的时 候，可直接在这个批次内递增取值。</p><p>（2）若该批次分布式ID的号段⽤完，则需要更新数据库中的初始值，再次获取新批次的分布式ID，并重 新缓存到分布式ID服务本地，以供使用</p><p>优点：趋势递增，不会影响数据库的数据写入性能，数据库压力小，可读性高</p><p>缺点：开发成本极高，需要额外引入分布式ID服务和中央数据库，链路边长导致出错率增加。</p><h2 id="美团leaf" tabindex="-1"><strong>美团Leaf</strong> <a class="header-anchor" href="#美团leaf" aria-label="Permalink to “美团Leaf”">​</a></h2><p>改动点：将本地jar变成独立服务，并引入zookeeper来解决时钟回拨问题</p><p>优点：解决了时钟回拨问题。</p><p>缺点：引入zookeeper，增加程序复杂性，链路变长导致出错率增加。</p><h2 id="滴滴tinyid" tabindex="-1"><strong>滴滴Tinyid</strong> <a class="header-anchor" href="#滴滴tinyid" aria-label="Permalink to “滴滴Tinyid”">​</a></h2><p>号段模式的优化</p><h2 id="mongodb的objectid" tabindex="-1"><strong>MongoDB的ObjectID</strong> <a class="header-anchor" href="#mongodb的objectid" aria-label="Permalink to “MongoDB的ObjectID”">​</a></h2><p>类似雪花算法，通过时间+机器码+pid+inc共12个字节，通过4+3+2+3的方式最终标识成一个24长度的十六进制字符。</p><h2 id="zookeeper生成唯一id-不推荐" tabindex="-1"><strong>zookeeper生成唯一ID</strong> （不推荐） <a class="header-anchor" href="#zookeeper生成唯一id-不推荐" aria-label="Permalink to “zookeeper生成唯一ID （不推荐）”">​</a></h2><h2 id="参考文章" tabindex="-1">参考文章 <a class="header-anchor" href="#参考文章" aria-label="Permalink to “参考文章”">​</a></h2><ul><li><a href="https://tech.meituan.com/dianping_order_db_sharding.html" target="_blank" rel="noreferrer">大众点评订单系统分库分表实践</a></li></ul>',33)])])}const b=a(o,[["render",n]]);export{g as __pageData,b as default};
