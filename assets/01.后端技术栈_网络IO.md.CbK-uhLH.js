import{_ as e,c as l,o as a,ah as i,aq as r}from"./chunks/framework.Dgw6jcLr.js";const P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01.后端技术栈/网络IO.md","filePath":"01.后端技术栈/网络IO.md","lastUpdated":null}'),o={name:"01.后端技术栈/网络IO.md"};function p(n,t,s,d,h,c){return a(),l("div",null,[...t[0]||(t[0]=[i('<h2 id="io" tabindex="-1">IO <a class="header-anchor" href="#io" aria-label="Permalink to “IO”">​</a></h2><ol><li><h4 id="通道" tabindex="-1">通道 <a class="header-anchor" href="#通道" aria-label="Permalink to “通道”">​</a></h4><ul><li>FileChannel：操作文件</li><li>DatagramChannel：通过UDP读写网络中数据</li><li>SocketChannel：通过TCP读写网络中数据</li><li>ServerSocketChannel： 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel</li></ul></li><li><h4 id="缓冲区" tabindex="-1">缓冲区 <a class="header-anchor" href="#缓冲区" aria-label="Permalink to “缓冲区”">​</a></h4><p><img src="'+r+'" alt="1703511759538"></p></li></ol><h3 id="i-o多路复用讲一下-epoll优势在哪-为什么-epoll水平触发-lt-与边缘触发-et" tabindex="-1">I/O多路复用讲一下，epoll优势在哪，为什么，epoll水平触发（LT）与边缘触发(ET) <a class="header-anchor" href="#i-o多路复用讲一下-epoll优势在哪-为什么-epoll水平触发-lt-与边缘触发-et" aria-label="Permalink to “I/O多路复用讲一下，epoll优势在哪，为什么，epoll水平触发（LT）与边缘触发(ET)”">​</a></h3><ul><li>select 、poll、epoll接口，并非堵塞在IO上，而是在其中一个系统上，堵塞于select调用，等待数据报套接字变为可读，select监听所有注册好的IO，优点可以等待多个描述符就绪</li><li>select和poll采用<strong>轮训</strong>的方式检查就绪事件，每次都扫描整个文件描述符，复杂度O(n)</li><li>epoll采用<strong>回调</strong>方式检查就绪事件，复杂度O(1)</li><li>select只工作在低效的LT模式，epoll可以工作在高效的ET模式</li><li>epoll是linux特有，select是规定，一般操作系统都有</li><li>select单个进程监听端口有限，64位是2048个，epoll没有最大并发连接限制，1G大约监听10万个端口</li><li>select内核需要将消息传递到用户空间，都需要内核拷贝动作；epoll通过内核和用户空间共享一块内存来实现</li></ul><h2 id="网络编程" tabindex="-1">网络编程 <a class="header-anchor" href="#网络编程" aria-label="Permalink to “网络编程”">​</a></h2><p>1、网络结构是7层国际标准（OSI）、4层模型、5层结构</p><p>2、每一层对应常见协议</p><table tabindex="0"><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>应用层</td><td>http、ftp</td><td></td></tr><tr><td>传输层</td><td>TCP、UDP</td><td></td></tr><tr><td>网络层</td><td>IP</td><td></td></tr><tr><td>网络接口层</td><td></td><td></td></tr></tbody></table><h3 id="http" tabindex="-1">http <a class="header-anchor" href="#http" aria-label="Permalink to “http”">​</a></h3><p><strong>1、输入URl到返回页面的解析过程</strong></p><p>大致6步，</p><p>1、DNS解析，获取域名对应IP</p><p>2、TCP连接，3次握手，建立TCP连接</p><p>3、发送Http数据</p><p>4、服务器处理数据，返回http请求结果</p><p>5、浏览器渲染</p><p>6、断开TCP，4次挥手</p><h3 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to “TCP”">​</a></h3><p><strong>1、握手为什么不是2次或4次</strong></p><ul><li>防止服务器端开启无用连接，增加服务器开销</li><li>防止已失效连接请求报文突然传到服务器，产生错误。</li><li>3次已经足够，没有必要再增加一次</li></ul><p><strong>2、挥手4次</strong></p><ul><li>需要等待完成数据的发送和接收，ack和FIN是分开发送的</li></ul><h3 id="udp" tabindex="-1">UDP <a class="header-anchor" href="#udp" aria-label="Permalink to “UDP”">​</a></h3><blockquote><p>关于netty UDP不能发送大于2048字节包的问题<a href="https://blog.csdn.net/KokJuis/article/details/72864018" target="_blank" rel="noreferrer">https://blog.csdn.net/KokJuis/article/details/72864018</a></p></blockquote><ul><li><p>udp理论上支持最大发送64K的包，那为什么netty udp不能发送大于2048字节呢？实际上网络通信中，还受到很多其他因素的影响，netty udp并非不能发送大于2048字节的包。而是收到MTU的影响。MTU【最大传输单元（Maximum Transmission Unit，MTU）是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）】。</p></li><li><p>MTU国际默认规定是1500，不同的网络接入方式，不同地区的网络运营商，甚至不同的路由器，它们的MTU值都可能是不同的，例如：ADSL接入时MTU为1492字节。操作系统中可以通过命令查看：netsh interface ipv4 show subinterfaces</p></li><li><p>最后说一下netty udp每次发送包大小的建议，因为国内很多用户的上网方式都是ADSL。而ADSL的MTU值1492。但每个UDP包都包含28字节的“数据包报头”，所以实际你每次只能发送的数据是1464个字节。</p></li></ul><h3 id="socket" tabindex="-1">socket <a class="header-anchor" href="#socket" aria-label="Permalink to “socket”">​</a></h3><p><strong>1、socket和websocket有啥区别</strong></p><p>socket就是ip+port+协议，是一套网络标准接口，完成了对TCP/IP的高度封装，屏蔽了网络细节，方便开发者更好的进行网络编程。</p><p>websocket是解决http不支持持久化连接的问题，伴随H5而出的持久化的协议，属于应用层通信协议。</p>',29)])])}const u=e(o,[["render",p]]);export{P as __pageData,u as default};
