import{_ as l,c as t,o as n,j as e,a as r}from"./chunks/framework.Cy-ZmcqA.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01.后端技术栈/算法.md","filePath":"01.后端技术栈/算法.md","lastUpdated":1762179876000}'),o={name:"01.后端技术栈/算法.md"};function s(d,a,i,c,p,u){return n(),t("div",null,[...a[0]||(a[0]=[e("h3",{id:"_2、移除元素",tabindex:"-1"},[r("2、移除元素 "),e("a",{class:"header-anchor",href:"#_2、移除元素","aria-label":"Permalink to “2、移除元素”"},"​")],-1),e("ul",null,[e("li",null,[e("p",null,"双指针法（快慢指针）快指针的值不等于目标的值，则将快指针的值赋给慢指针，表明是相持的，下标逐渐递增，如果不相等，则不处理，此时，慢指针等待下一次相等，然后下标再递增。用一个for循环，解决2个循环的问题。"),e("ul",null,[e("li",null,[e("p",null,"快指针：新数组的元素，即不包含有目标元素的数组下标。")]),e("li",null,[e("p",null,"慢指针：新数组的下标位置。")])])])],-1)])])}const m=l(o,[["render",s]]);export{f as __pageData,m as default};
