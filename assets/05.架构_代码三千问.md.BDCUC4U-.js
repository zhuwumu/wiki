import{_ as e,c as l,o as i,ay as r}from"./chunks/framework.C19qILHO.js";const b=JSON.parse('{"title":"代码三千问","description":"","frontmatter":{},"headers":[],"relativePath":"05.架构/代码三千问.md","filePath":"05.架构/代码三千问.md","lastUpdated":1762179876000}'),t={name:"05.架构/代码三千问.md"};function o(h,a,n,d,s,p){return i(),l("div",null,[...a[0]||(a[0]=[r('<h1 id="代码三千问" tabindex="-1">代码三千问 <a class="header-anchor" href="#代码三千问" aria-label="Permalink to “代码三千问”">​</a></h1><h2 id="java是值传递还是引用传递" tabindex="-1">JAVA是值传递还是引用传递 <a class="header-anchor" href="#java是值传递还是引用传递" aria-label="Permalink to “JAVA是值传递还是引用传递”">​</a></h2><p>什么叫值传递？</p><p>当一个参数，在2个方法之间传递时，调用者和被调用者其实用的是2个不同的变量--被调用者中的变量是调用者中变量的拷贝，对他们当中的任何一个参数进行修改，都不会影响到另外一个。</p><p>什么叫引用传递？</p><p>当一个参数在方法之间传递时，调用者和被调用者用的是同一个变量，当该变量被修改时，双方都可见。</p><p><strong>结论：</strong>JAVA只有值传递。</p><p><strong>原因：</strong></p><p>AJVA中分为8种基本数据类型，比如int，其他为引用类型，例如String。分别探讨</p><ol><li>当为基本数据类型时，变量存储的都是实际的值，放在栈（stack）中。每当作为参数传递时，都会复制一份，给形参用，在调用方法结束时，从栈中清除。</li><li>当为引用类型时，变量存储的是对象的地址引用（对象在内存中的地址），引用存储在栈中，而对象存储在堆（heap）中。当作参数传递时，复制的一份，给形参用，这个时候，实际复制的是对象的地址引用，实参和形参本质上引用的都是同一个对象。故而在方法体内修改了对象的值，方法外对应的变量对应的对象值也会改变。但是如果重新给形参赋予新的对象。则不会影响方法外的对象。因为此时已经是2个对象了。</li></ol><p>之所以有这个区别，是因为：</p><ul><li>栈的优势是，存取速度比堆要快，仅次于直接位于 CPU 中的寄存器。但缺点是，栈中的数据大小与生存周期必须是确定的。</li><li>堆的优势是可以动态地分配内存大小，生存周期也不必事先告诉编译器，Java 的垃圾回收器会自动收走那些不再使用的数据。但由于要在运行时动态分配内存，存取速度较慢。</li></ul><h2 id="ood" tabindex="-1">OOD <a class="header-anchor" href="#ood" aria-label="Permalink to “OOD”">​</a></h2><blockquote><p>面向对象设计</p></blockquote><h2 id="ddd" tabindex="-1">DDD <a class="header-anchor" href="#ddd" aria-label="Permalink to “DDD”">​</a></h2><blockquote><p>Domain-Driven Design的缩写。主要思想，我们在设计软件时，理解真正的业务含义，将业务中的一些概念吸收到软件建模中，避免造出“大而无用”软件。也避免软件设计没有内在联系，否则一团散沙，无法继续演进。</p></blockquote><h3 id="要求" tabindex="-1">要求 <a class="header-anchor" href="#要求" aria-label="Permalink to “要求”">​</a></h3><ol><li>非常熟悉业务的教练</li><li>依赖导致</li><li>语义维护</li></ol><h3 id="失败案例" tabindex="-1">失败案例 <a class="header-anchor" href="#失败案例" aria-label="Permalink to “失败案例”">​</a></h3><ol><li>中国移动X公司承认DDD转型失败，原有项目重构失败。</li><li>京东到家只采用了DDD的领域分析，技术因无法与现有系统衔接无法落地。</li><li>某四大行研发中心内部推行两年，程序员依然在MVC开发。</li></ol><h1 id="微服务" tabindex="-1">微服务 <a class="header-anchor" href="#微服务" aria-label="Permalink to “微服务”">​</a></h1><h2 id="gateway" tabindex="-1">Gateway <a class="header-anchor" href="#gateway" aria-label="Permalink to “Gateway”">​</a></h2><p><a href="https://zhuanlan.zhihu.com/p/629271214" target="_blank" rel="noreferrer">Spring Cloud Gateway描述</a></p><p><a href="https://www.zhihu.com/question/360613960/answer/3076555812" target="_blank" rel="noreferrer">spring cloud中gateway存在的意义是什么？</a></p><h3 id="一、作用" tabindex="-1">一、作用 <a class="header-anchor" href="#一、作用" aria-label="Permalink to “一、作用”">​</a></h3><ol><li>统一入口和路由转发。</li><li>负载均衡与容错。自动分摊容量到多个服务实例（随机、轮询、权重），并在服务故障时触发熔断降级，防止雪崩效应。</li><li>安全控制与权限校验。集中处理认证（JWT、OAuth2）、IP黑名单、访问频率控制等安全策略，无需每个服务重复实现。</li><li>流量治理与限流。通过令牌桶或漏桶算法限制请求速率（如每秒100次），保护后端服务不被突发流量击垮，支持基于服务、IP的多维度限流。</li><li>协议转换与请求增强。统一处理Https卸载、请求重写（如路径添加前缀）、相应内容修改等，简化微服务的开发。</li></ol><h3 id="二、为什么不能随意移除网关" tabindex="-1">二、为什么不能随意移除网关？ <a class="header-anchor" href="#二、为什么不能随意移除网关" aria-label="Permalink to “二、为什么不能随意移除网关？”">​</a></h3><ol><li>架构耦合风险 若去掉网关，客户端需直接感知所有微服务地址和端口。服务实例动态扩展/缩容时，客户端无法自动适配变化，导致服务发现机制失效。</li><li>安全防线瓦解 认证逻辑需在每个服务重复实现，权限漏洞风险陡增。攻击者可绕过安全控制直接访问内部服务。</li><li>运维复杂度飙升 跨域处理、限流、日志监控等能力需在每个服务独立实现，维护成本呈指数级增长。</li><li>性能瓶颈转移 网关的非阻塞式架构（WebFlux+Netty）可处理万级并发。若移除，高并发压力将直接冲击业务服务，而普通服务线程阻塞模型易崩溃</li></ol><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to “结论”">​</a></h3><p>网关是微服务架构的“守门人”与“调度器”，承担流量编排、安全屏障、系统稳定的核心职责。移除网关将导致架构退化到分布式单体（Distributed Monolith），显著增加系统脆弱性。合理做法是优化网关配置（如动态路由、细粒度限流），而非去除。在微服务架构中，网关是必选项而非可选项。</p>',30)])])}const _=e(t,[["render",o]]);export{b as __pageData,_ as default};
