import{_ as a,c as t,j as e,a as n,o as r}from"./chunks/framework.6NRZc4eo.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"01.后端技术栈/算法.md","filePath":"01.后端技术栈/算法.md","lastUpdated":null}'),o={name:"01.后端技术栈/算法.md"};function s(d,l,i,u,c,p){return r(),t("div",null,l[0]||(l[0]=[e("h3",{id:"_2、移除元素",tabindex:"-1"},[n("2、移除元素 "),e("a",{class:"header-anchor",href:"#_2、移除元素","aria-label":'Permalink to "2、移除元素"'},"​")],-1),e("ul",null,[e("li",null,[e("p",null,"双指针法（快慢指针）快指针的值不等于目标的值，则将快指针的值赋给慢指针，表明是相持的，下标逐渐递增，如果不相等，则不处理，此时，慢指针等待下一次相等，然后下标再递增。用一个for循环，解决2个循环的问题。"),e("ul",null,[e("li",null,[e("p",null,"快指针：新数组的元素，即不包含有目标元素的数组下标。")]),e("li",null,[e("p",null,"慢指针：新数组的下标位置。")])])])],-1)]))}const m=a(o,[["render",s]]);export{f as __pageData,m as default};
