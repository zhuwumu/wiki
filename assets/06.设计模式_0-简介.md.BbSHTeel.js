import{_ as i,c as a,o as e,aj as r}from"./chunks/framework.DA_nFhhl.js";const g=JSON.parse('{"title":"简介","description":"","frontmatter":{},"headers":[],"relativePath":"06.设计模式/0-简介.md","filePath":"06.设计模式/0-简介.md","lastUpdated":1762179876000}'),n={name:"06.设计模式/0-简介.md"};function t(o,l,s,h,c,d){return e(),a("div",null,[...l[0]||(l[0]=[r('<h1 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to “简介”">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to “前言”">​</a></h2><blockquote><p>设计模式的本质是对面向对象设计原则的实际运用，是对类的封装性、继承性、多态性以及类的关联关系和组合关系的充分理解。</p></blockquote><h3 id="正确使用设计模式具有以下优点" tabindex="-1">正确使用设计模式具有以下优点 <a class="header-anchor" href="#正确使用设计模式具有以下优点" aria-label="Permalink to “正确使用设计模式具有以下优点”">​</a></h3><ol><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ol><h3 id="要素" tabindex="-1">要素 <a class="header-anchor" href="#要素" aria-label="Permalink to “要素”">​</a></h3><ol><li>名称</li><li>问题</li><li>解决方案</li><li>效果</li></ol><p>“设计模式”被公认为是软件开发的最佳实践，但也一直是“高深、玄妙”的代名词，这也导致很多人对其望而生畏，缺乏对其概念的基本认识。</p><p>旨在让你对23种“设计模式”有所了解，能知道其基本骨架，初步认识设计模式的使用场景。</p><p>区别于网上其他教程，本教程的特点是:</p><ul><li><strong>23种设计模式全覆盖</strong>，涵盖了所有Gang of Four设计模式，包括创建型、结构型和行为型设计模式。</li><li>通过23道简单而实用的例子，<strong>以刷算法题的形式了解每种设计模式的概念、结构和应用场景</strong>。</li><li><strong>为每个设计模式提供清晰的文字解释、结构图和代码演示</strong>，帮助你更好地理解和实践。</li><li><strong>难度安排循序渐进</strong>，从基础的、常用的设计模式逐步深入。</li></ul><p>设计模式大纲：</p><p><img src="https://kstar-1253855093.cos.ap-nanjing.myqcloud.com/baguwen1.0/image-20240103193726391.png" alt="image-20240103193726391"></p><p>23种设计模式的讲解，同时给出对应的练习题目，在：<a href="https://kamacoder.com/designpattern.php" target="_blank" rel="noreferrer">设计模式专属练习题库</a></p><h2 id="oop七大原则" tabindex="-1">OOP七大原则 <a class="header-anchor" href="#oop七大原则" aria-label="Permalink to “OOP七大原则”">​</a></h2><ol><li>单一职责原则：控制类的粒度大小、将对象解耦，提高其内聚性。一个方法 一个类只负责一个职责，各个职责的程序改动，不影响其它程序。</li><li>开闭原则：对扩展开放，对修改关闭。即在不修改一个软件实体的基础上去扩展其他功能。</li><li>里氏替换原则：在软件系统中，一个可以接受基类对象的地方必然可以接受一个子类对象。</li><li>依赖倒置原则：针对于接口编程，依赖于抽象而不依赖于具体。</li><li>接口隔离原则：为各个类建立它们需要的专用接口。降低类与类之间的耦合度。</li><li>迪米特原则：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，建立中间类。</li><li>合成复用原则：尽量先使用组合或聚合等关联关系来实现，其次才考虑使用继承关系来实现。</li></ol><h2 id="_23种设计模式" tabindex="-1">23种设计模式 <a class="header-anchor" href="#_23种设计模式" aria-label="Permalink to “23种设计模式”">​</a></h2><h3 id="创建型" tabindex="-1"><strong>创建型</strong> <a class="header-anchor" href="#创建型" aria-label="Permalink to “创建型”">​</a></h3><ul><li>单例模式： 保证被创建一次，节省系统开销 <ul><li>核心思想：保证一个类只有一个实例，并且提供一个全局访问点来访问该实例。</li><li>饿汉模式：线程安全，类加载时就创建实例；比如JackSon对象的全局实例。</li><li>懒汉模式：线程不安全，可以使用<code>synchronized</code>互斥锁来解决（将<code>getInstance()</code>设置为同步方法），可能影响性能，可以使用<strong>双重检查</strong>锁（<code>getInstance()</code>设置为普通方法，只锁当前对象，颗粒度变小，性能提高）来提高性能。</li><li>静态内部类（既可以懒加载，又线程安全）</li><li>如Runtim，getRunTime()。</li></ul></li><li>工厂模式（简单工厂、抽象工厂）：解耦代码。被用于不可变的类，如Boolean.valueOf()</li><li>原型模式</li><li>建造者模式</li></ul><h3 id="结构型" tabindex="-1"><strong>结构型</strong> <a class="header-anchor" href="#结构型" aria-label="Permalink to “结构型”">​</a></h3><ul><li>适配器模式。不同的日志框架适配为统一接口。</li><li>代理模式。Spring框架的AOP模块使用了代理模式来实现切面编程。</li><li>装饰器设计模式。用于IO，bufferRead</li><li>外观模式： 提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。 <ul><li>集合所有操作到一个类，降低耦合；例如<code>ApplicationContext</code></li></ul></li><li>桥接模式（数据库驱动桥接），JDBC提供统一接口</li><li>组合模式 <ul><li>树形文件目录</li></ul></li><li>享元模式（共享池、数据库连接池），目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用，如果有就直接返回对象，如果没有，再创建</li></ul><h3 id="行为型" tabindex="-1"><strong>行为型</strong> <a class="header-anchor" href="#行为型" aria-label="Permalink to “行为型”">​</a></h3><ul><li>观察者模式（发布-订阅模式）： 定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新 <ul><li>事件的监听中listener</li></ul></li><li>策略模式（多种算法封装）。统一接口，jvm根据不同的实现类调用不同实现类的方法</li><li>命令模式（实现请求和执行的解耦）。command命令|行为解耦 <ul><li>撤销操作：需要支持撤销操作，命令模式可以存储历史命令，轻松实现撤销功能。</li><li>队列请求：命令模式可以将请求排队，形成一个命令队列，依次执行命令。</li><li>可扩展性</li></ul></li><li>中介模式。降低耦合，类似Spring容器的作用。</li><li>备忘录模式（保存和恢复对象状态）</li><li>模板方法模式： 定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤</li><li>迭代器模式（遍历集合）</li><li>状态模式（对象状态改变时改变其行为）</li><li>责任链模式（多任务形成一条链，请求在链上传递）。Filter，doFilter()</li><li>解释器模式。正则表达式</li><li>访问者模式（数据接口稳定，但算法易变）</li></ul><h2 id="spring中设计模式" tabindex="-1">Spring中设计模式 <a class="header-anchor" href="#spring中设计模式" aria-label="Permalink to “Spring中设计模式”">​</a></h2><ul><li>单例模式：Spring下默认的bean均为singleton</li><li>代理模式：SpringAop功能的实现</li><li>工厂模式。BeanFactory就是工厂模式的体现。</li><li>观察者模式：ApplicationListener</li><li>模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式；</li><li>装饰器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源；</li><li>适配器模式：Spring AOP 的增强或通知（Advice）使用到了适配器模式、SpringMVC 中也是用到了适配器模式适配 Controller。</li></ul><h2 id="参考" tabindex="-1">参考 <a class="header-anchor" href="#参考" aria-label="Permalink to “参考”">​</a></h2><ul><li><a href="https://github.com/youngyangyang04/kama-DesignPattern" target="_blank" rel="noreferrer">https://github.com/youngyangyang04/kama-DesignPattern</a></li></ul>',27)])])}const u=i(n,[["render",t]]);export{g as __pageData,u as default};
