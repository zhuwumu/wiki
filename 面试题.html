<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Netty | Java全栈知识体系</title>
    <meta name="description" content="A VitePress site">
    <meta name="generator" content="VitePress v2.0.0-alpha.12">
    <link rel="preload stylesheet" href="/wiki/assets/style.DEL9oLmP.css" as="style">
    <link rel="preload stylesheet" href="/wiki/vp-icons.css" as="style">
    
    <script type="module" src="/wiki/assets/app.CBjJy-2n.js"></script>
    <link rel="preload" href="/wiki/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/wiki/assets/chunks/theme.DZd7A-GY.js">
    <link rel="modulepreload" href="/wiki/assets/chunks/framework.Dgw6jcLr.js">
    <link rel="modulepreload" href="/wiki/assets/面试题.md.vXECt2eo.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-1df9f90f><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-1df9f90f data-v-9f75dce3><div class="VPNavBar" data-v-9f75dce3 data-v-2a96a3d0><div class="wrapper" data-v-2a96a3d0><div class="container" data-v-2a96a3d0><div class="title" data-v-2a96a3d0><div class="VPNavBarTitle" data-v-2a96a3d0 data-v-1e38c6bc><a class="title" href="/wiki/" data-v-1e38c6bc><!--[--><!--]--><!--[--><img class="VPImage logo" src="/wiki/logo.svg" alt data-v-8426fc1a><!--]--><span data-v-1e38c6bc>Java全栈知识体系</span><!--[--><!--]--></a></div></div><div class="content" data-v-2a96a3d0><div class="content-body" data-v-2a96a3d0><!--[--><!--]--><div class="VPNavBarSearch search" data-v-2a96a3d0><!--[--><!----><div id="local-search"><button type="button" aria-label="Search" aria-keyshortcuts="/ control+k meta+k" class="DocSearch DocSearch-Button"><span class="DocSearch-Button-Container"><span class="vpi-search DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key"></kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-2a96a3d0 data-v-39714824><span id="main-nav-aria-label" class="visually-hidden" data-v-39714824> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/wiki/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%84%9A%E6%89%8B%E6%9E%B6.html" tabindex="0" data-v-39714824 data-v-e56f3d57><!--[--><span data-v-e56f3d57>后台管理系统脚手架</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-39714824 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-42cb505d><span class="text" data-v-42cb505d><!----><span data-v-42cb505d>JAVA</span><span class="vpi-chevron-down text-icon" data-v-42cb505d></span></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><div class="items" data-v-25a6cce8><!--[--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/01.%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/JAVA%E5%9F%BA%E7%A1%80.html" data-v-cd834e02><!--[--><span data-v-cd834e02>JAVA基础</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/01.%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%A0%88/%E5%A4%9A%E7%BA%BF%E7%A8%8B/JAVA%E5%B9%B6%E5%8F%91-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html" data-v-cd834e02><!--[--><span data-v-cd834e02>多线程</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-39714824 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-42cb505d><span class="text" data-v-42cb505d><!----><span data-v-42cb505d>Spring全家桶</span><span class="vpi-chevron-down text-icon" data-v-42cb505d></span></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><div class="items" data-v-25a6cce8><!--[--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/02.Spring/Spring-@Transactional%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF.html" data-v-cd834e02><!--[--><span data-v-cd834e02>Spring</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/02.Spring/SpringBoot.html" data-v-cd834e02><!--[--><span data-v-cd834e02>SpringBoot</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-39714824 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-42cb505d><span class="text" data-v-42cb505d><!----><span data-v-42cb505d>数据库</span><span class="vpi-chevron-down text-icon" data-v-42cb505d></span></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><div class="items" data-v-25a6cce8><!--[--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/03.%E6%95%B0%E6%8D%AE%E5%BA%93/MySql-%E7%B4%A2%E5%BC%95.html" data-v-cd834e02><!--[--><span data-v-cd834e02>Mysql</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/03.%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E7%A1%80.html" data-v-cd834e02><!--[--><span data-v-cd834e02>Redis</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-39714824 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-42cb505d><span class="text" data-v-42cb505d><!----><span data-v-42cb505d>中间件</span><span class="vpi-chevron-down text-icon" data-v-42cb505d></span></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><div class="items" data-v-25a6cce8><!--[--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka.html" data-v-cd834e02><!--[--><span data-v-cd834e02>Kafka</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/Zookeeper.html" data-v-cd834e02><!--[--><span data-v-cd834e02>Zookeeper</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/04.%E4%B8%AD%E9%97%B4%E4%BB%B6/Netty.html" data-v-cd834e02><!--[--><span data-v-cd834e02>Netty</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/wiki/03.%E5%B7%A5%E5%85%B7-%E9%83%A8%E7%BD%B2/linux%E8%BF%90%E7%BB%B4%E7%AC%94%E8%AE%B0.html" tabindex="0" data-v-39714824 data-v-e56f3d57><!--[--><span data-v-e56f3d57>工具|部署</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/wiki/06.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0-%E7%AE%80%E4%BB%8B.html" tabindex="0" data-v-39714824 data-v-e56f3d57><!--[--><span data-v-e56f3d57>设计模式</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-39714824 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-42cb505d><span class="text" data-v-42cb505d><!----><span data-v-42cb505d>方法论</span><span class="vpi-chevron-down text-icon" data-v-42cb505d></span></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><div class="items" data-v-25a6cce8><!--[--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/04.%E6%96%B9%E6%B3%95%E8%AE%BA/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.html" data-v-cd834e02><!--[--><span data-v-cd834e02>代码规范</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-39714824 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-42cb505d><span class="text" data-v-42cb505d><!----><span data-v-42cb505d>架构</span><span class="vpi-chevron-down text-icon" data-v-42cb505d></span></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><div class="items" data-v-25a6cce8><!--[--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/05.%E6%9E%B6%E6%9E%84/%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF%E7%82%B9/JWT.html" data-v-cd834e02><!--[--><span data-v-cd834e02>常用技术点</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-cd834e02><a class="VPLink link" href="/wiki/05.%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84300%E8%AE%B2.html" data-v-cd834e02><!--[--><span data-v-cd834e02>架构300讲</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/wiki/07.%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/%E7%94%9F%E6%B4%BB%E5%B0%8F%E6%8A%80%E5%B7%A7.html" tabindex="0" data-v-39714824 data-v-e56f3d57><!--[--><span data-v-e56f3d57>代码人生</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-2a96a3d0 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-2a96a3d0 data-v-0394ad82 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-2a96a3d0 data-v-bb2aa2f0 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-42cb505d><span class="vpi-more-horizontal icon" data-v-42cb505d></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/vuejs/vitepress" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-2a96a3d0 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-2a96a3d0><div class="divider-line" data-v-2a96a3d0></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-1df9f90f data-v-8acdfeb5><div class="container" data-v-8acdfeb5><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-8acdfeb5 data-v-0bf0e06f><button data-v-0bf0e06f>Return to top</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-1df9f90f data-v-aff0b8d7><div class="VPDoc has-aside" data-v-aff0b8d7 data-v-7011f0d8><!--[--><!--]--><div class="container" data-v-7011f0d8><div class="aside" data-v-7011f0d8><div class="aside-curtain" data-v-7011f0d8></div><div class="aside-container" data-v-7011f0d8><div class="aside-content" data-v-7011f0d8><div class="VPDocAside" data-v-7011f0d8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-60d5052e><div class="content" data-v-60d5052e><div class="outline-marker" data-v-60d5052e></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-60d5052e>On this page</div><ul class="VPDocOutlineItem root" data-v-60d5052e data-v-2d0bdf9b><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-7011f0d8><div class="content-container" data-v-7011f0d8><!--[--><!--]--><main class="main" data-v-7011f0d8><div style="position:relative;" class="vp-doc _wiki_%E9%9D%A2%E8%AF%95%E9%A2%98" data-v-7011f0d8><div><p>我对于这类问题，建立的索引一般有几个：</p><ol><li>它是什么</li><li>它能解决什么问题 ，为什么会出现它</li><li>它有哪些特点和优势、特性</li><li>他有哪些缺点或者注意事项</li><li>它的核心原理，为什么能解决这类问题</li></ol><h2 id="自我介绍" tabindex="-1">自我介绍 <a class="header-anchor" href="#自我介绍" aria-label="Permalink to “自我介绍”">​</a></h2><ul><li>第一段</li></ul><p>面试官您好，我叫朱森林，来自河北衡水，17年本科毕业于华北理工大学，到目前为止，有三家工作经历。第三家，是在中国电科十五所，在这家公司的6年期间，主事JAVA研发工作，担任过项目经理，带领过3-6人的研发小组。</p><ul><li>我有3点核心竞争力</li></ul><p>1、能一定的架构能力，独立设计研发了四级传输链路中间件，支撑了200多个单位节点的数据可靠稳定传输。 2、能从全局考虑问题，有产品思维。整合现有资源，对部门后台管理系统脚手架进行升级，组件抽离，制定规范，研发代码生成器，提高了团队交付效率。 3、较强的实战能力，最重要的是遇到问题，能解决问题，做事踏实，有冲劲，也乐于分享，能够对初级开发者提供一定的指导帮助。</p><ul><li>第三段</li></ul><p>未来职业规划，首先还是继续加强常用技术栈的学习，可能会换一种方式，之前都是碎片化的学习，未来想以JAVA为开发背景，构筑自己的知识体系，归纳、总结，然后输出，目前也在着手去尝试。其次，国内来讲，技术是要为业务赋能的，所以想深耕产品业务，成为业务领域的专家，用技术为企业创造价值。</p><ul><li>第四段</li></ul><p>这次应聘的是JAVA研发岗位，我看了岗位对候选人的要求，在技术栈和能力要求这两块，我觉得匹配度还是蛮高的，Saas产品也是我个人希望长期深耕的一个领域，像目前ERP、CRM这些也比较流行，服务订阅未来是一种趋势，<strong>跟之前的项目可能会有一些不同的侧重点，但是我适应能力和责任心都不错，我还是有信心能胜任的</strong>。其次我对京东这家公司的企业文化，以及在抗震救灾面前所体现出来的社会责任感，是比较推崇的，希望能有幸加入这家伟大的公司，和优秀的人一起奋斗。</p><h2 id="你觉得自己的面试表现" tabindex="-1">你觉得自己的面试表现 <a class="header-anchor" href="#你觉得自己的面试表现" aria-label="Permalink to “你觉得自己的面试表现”">​</a></h2><p>7-8分吧，说明为什么这么打分。做的好的+不足的+感谢</p><p>如果10分的话，我给自己今天的面试表现打7-8分。我感觉我做的比较好的有2点，第一，我清晰的呈现了我过往的项目经验，跟您交流的过程中，我也积极去回答问题，尽管有些不足。第二，我提前对岗位充分的研究，所以跟您聊起来，能够很快的理解岗位的需求。扣掉的分数，是因为我觉得如果再给我一次机会的话，我肯定能做的更好。目前只投了京东，所以对今天的面试也是非常重视，面试前虽然也有积极准备。每个人对自己在意的事情，多少会有点紧张，但一紧张，导致有些表达不是很流畅。整体来讲，非常感谢您的时间，整个面试也是受益匪浅，也很期待未来能够与您共事。</p><p><strong>自己的缺点和离职原因：</strong></p><p><strong>自己的缺点：</strong></p><p>技术方面，受限于碎片化学习，目前还没有完整的构建成自己的知识体系，知识的表达能力还是需要提高的，目前也在去尝试做。</p><p>性格方面，可能由于太过认真，导致在代码规范或推进项目时，比较较真，忽略了其他人的感受，目前也在注意这种情况。</p><p><strong>离职原因：</strong></p><ol><li>一个是受限于业务发展，军工项目，想换个长期深耕的领域。</li><li>另一个是技术成长，没有那么大的体量，希望参与更具用户规模和技术挑战的项目，想在更大的平台去挑战更难更有意思的事。</li></ol><p><strong>你有什么想问的么</strong></p><p>面试官</p><ol><li>岗位的主要内容，做哪些事</li><li>长期发展的话，岗位未来的成长晋升路线</li><li>部门对于新人快速上手项目，会有什么策略呢</li><li>这个岗位除了技术，更看重候选人哪块的能力呢</li><li>项目进展情况及重点技术路线</li><li>如何有幸入职，应该提前做好什么准备工作，比如技术方面要重点关注哪些，以便能更顺利的开展工作。</li><li>领导对这个岗位的工作者有什么期待</li><li>部门的架构和团队的情况是怎么样的</li><li>除了上面聊到的工作内容，还会接触到哪些工作内容呢</li></ol><p>BOSS</p><ol><li>您接触过的候选人中，哪些能力特质是最重要，是最吸引您的呢</li><li>您最喜欢什么样风格的下属</li><li>您希望候选人在入职半年和一年后，分别能达到什么样的成绩。</li><li>我未来想在xx领域发展，您作为行业资深的前辈，可以给我一些职业发展的建议么</li></ol><p>HR</p><ol><li>部门的规模</li><li>大家的分工，我在部门的定位</li><li>我想在一家公司沉淀和成长，咱们这个岗位的晋升路径是怎么样的</li><li>我的leader的做事风格是怎样的，他喜欢什么样的沟通协作方式</li></ol><ul><li><p>加入的意愿</p><p>感谢您的时间，那关于这个岗位，我已经理解非常清楚了，我的技能和经验，也非常和公司的这个要求匹配，那您这边，后续有任何需要我补充的材料和信息呢，请随时联系我。</p></li></ul><p><strong>薪水低一点可以吗</strong></p><p>薪水的确很重要，但是这不是我最看重的因素，因为，更期待加入一家能够长期发展的公司，合适自己的平台。合适的薪资也是对我能力的认可，同样也能更激励我为公司创造更多的价值。</p><h2 id="项目亮点" tabindex="-1">项目亮点 <a class="header-anchor" href="#项目亮点" aria-label="Permalink to “项目亮点”">​</a></h2><p>要求：叶子结点往非叶子结点传输数据，直到根结点。叶子结点通过非叶子结点之间也可以互相通讯，特定端口通讯。</p><p>1、上级能查看下级的在线状态及统计断开的时间，并进行分析</p><p>2、业务系统，能通过这个传输链路，结点之间进行数据传输，比如状态的更改，消息的发送及附件传输。</p><p>要解决的问题：</p><ol><li><p>TCP粘包：</p><ul><li><p>TCP是面向流的，没有边界，发送TCP数据时，会通过缓冲区来优化，例如缓冲区大小为1024字节。UDP是有消息保护边界的，所以不存在下列情况。</p></li><li><p>粘包：如果一次数据量没有达到缓冲区大小，TCP会将多个请求合并成一个请求进行发送，造成粘包。</p></li><li><p>拆包：如果一次数据量达到最大缓冲区，TCP会将一个请求拆分成多个请求进行发送，造成拆包。</p><p><strong>解决办法：</strong></p><ul><li>文本协议使用， 采用分隔符的方式。</li><li>二进制协议使用，采用长度+数据的方式。Netty中对应解码器 <a href="https://zhida.zhihu.com/search?content_id=660510993&amp;content_type=Answer&amp;match_order=1&amp;q=LenghtFieldBasedFrameDecode&amp;zhida_source=entity" target="_blank" rel="noreferrer">LenghtFieldBasedFrameDecode</a> ，消息头包含长度的。但是有个小问题就是如果客户端第一个数据包数据长度封装的有错误，那么很可能就会导致后面接收到的所有数据包都解析出错（由于TCP建立连接后流式传输机制），只有客户端关闭连接后重新打开才可以消除此问题，我在处理这个问题的时候对数据长度做了校验，会适时的对接收到的有问题的包进行人为的丢弃处理（客户端有自动重发机制，故而在应用层不会导致数据的不完整性）；</li></ul></li></ul></li><li><p>消息头部包含哪些信息？</p><p>ID：本次数据的ID。用于接收成功发送的反馈。</p><p>发送地址：</p><p>目标地址：</p><p>指令类型：0：ping，1：pong，2：ack，3：data</p><p>业务CODE：如果指令类型是data的话，需要指定对应的业务系统标识。</p><p>数据格式：0：JSON、文件</p><p>文件校验值：</p><p>数据长度：（来解决粘包问题）</p><p>数据内容（长度不定）：</p></li><li><p>如何确定对方收到了数据？</p><ol><li>确认应答：当接收方成功收到数据，则反方向发送ack确认消息，告诉发送方已经收到，发送方收到ack确认之后，需要回复我已收到，否则接收方会重试ack发送，进行3次来回的ack确认，才可以保证数据正确被接收。</li><li>超时重试机制：设置重试次数和重试间隔。重试时间是指数级增长，防止过于频繁，消耗带宽。 <ul><li>网络抖动：</li><li>网络断开：</li></ul></li></ol></li><li><p>如何验证文件是正确传输的：校验文件的完整性。</p><ol><li>MD5：使用哈希算法，生成一个128位（16字节）的哈希值。优点：计算速度快，实现简单。不足：安全性较低，不适用高安全性场景。</li><li>SHA-256：生成256位（32字节）的哈希值。优点：安全性高，适用于高安全性场景，缺点：速度较慢，占用更多空间。</li><li>CRC32：生成32位（4个字节）的校验值，优点：计算速度快，占用空间少，缺点：安全性低，不适用于高安全性的场景。</li></ol></li><li><p>每个结点的逻辑判断</p><p>收到数据之后，解析消息头中的目标地址，是否为当前结点。如果不是，则直接转发，如果是，则进行业务处理，根据头部解析的业务CODE，查询数据库中对应的注册信息（可以从缓存中获取，提高性能），调用对应的Http接口，处理成功或失败之后，都要进行ACK确认。</p></li><li><p>如何利用数据传输链路，给业务系统推送消息</p><p>每个对应的业务，需要在链路系统中注册一个数据接收地址和唯一的业务CODE：用于结点收到数据后的一个推送。</p></li><li><p>如何保证高可用：副本方式，提供j集群服务。场景的并发不是很高，所以主要侧重于高可以用，以及运维的复杂性。</p><ul><li><p>2个实例集群部署，足够用</p></li><li><p>Nginx负载均衡。理论上单台支持5的并发，基本满足，它本身2个进程，能保证高可以用。实在要做集群的话，可用使用 keepalived ，设置主从，但是如果主不故障的话。从就会浪费。一般也不使用。第二种，互为主从。如果需要更高的性能，上硬件F5。</p><ul><li>轮询：默认策略。如果后端服务器down掉，能自动剔除，就不在分配</li><li>权重：适用于服务器硬件差异比较大。</li><li>ip_hash：解决session，无法负载均衡</li><li>fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配</li><li>Url_hash：按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</li></ul><p>nginx负载均衡策略要用轮询，这样连接可以均匀的分散到各个实例上，也就是每个实例都有一个客户端的长连接，这样给客户端发送消息时直接从当前实例内存里取对应的链接即可，如果不存在，则通过redis的stream消息队列进行推送，手动提交ack。如果服务端其中一个实例挂掉了，会导致请求全部集中在另一个实例上，这个时候需要将nginx重启，是客户端的请求再次均匀分配到服务实例上</p></li><li><p>MYsql数据库主从复制，一主一从，利用MHA工具实现高可用。</p><ul><li>异步复制：直接返回，容易丢失数据。</li><li>同步复制：等待所有从库返回，其中一个崩溃了，会导致一直堵塞。</li><li>半同步复制：只需要等待一个从库返回即可。</li></ul></li><li><p>健康检查<strong>Prometheus</strong> + 可视化工具 Grafana</p></li><li><p>Redis：可持久化</p><ul><li>主从复制：最少3台，一主两从。缺点：需要手动执行。</li><li>哨兵模式：最少3台，故障时要能进行正确选举。 缺点：从节点一旦故障，读会受到影响</li><li>集群模式6个： 缺点： 它解决了哨兵的写操作的<a href="https://so.csdn.net/so/search?q=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&amp;spm=1001.2101.3001.7020" target="_blank" rel="noreferrer">负载均衡</a>，它较为完善的高可用方案。 保证高可用，但对数据的完整性要求不高</li></ul></li></ul></li><li><p>集群部署下，会存在一个问题，结点如何找到Netty对应的channel，对应的channel可能存在别的实例上，类似于session问题。</p><p>多台实例应该使用同一台redis和mysql实例。</p><p>利用发布订阅，监听同一个频道，然后实例监听，基于内存管理的channel组，从组中根据根据目标地址，找到对应的channel，然后进行发送。</p><p>发布订阅的缺点：</p><p>无持久性：redis服务重启，可能导致数据丢失</p><p>无确认机制：无法确认消息已经被所有订阅者获取。虽然咱们自定义了ack机制，</p><p>广播风暴：订阅数量太大的话导致网络宽带和CPU资源过度使用</p><p>实时性受限：高负载的情况下，消息会延迟。</p><p><strong>解决方案：</strong></p><p>使用Redis Streams而不是传统的发布订阅模式，后者提供了更强的持久性和消费者群组管理功能。</p><p>使用代理或消息队列中间件。</p><p>发布订阅模式会带来一个问题：客户端下线，客户端不会自动剔除。</p></li><li><p>使用发布订阅模式，如果客户端和服务端都是集群的话，多个服务端实例都有一个客户端，使用发布订阅模式的话，就导致重复发送了。1个服务端可能会有多个客户端连接（需要去重），也可能均匀分布，所以不可靠。去存储单位和实例对应的的map，要选用key:code，然后值是多个，因为可能有多个客户端实例，所以，推送时，选择一个即可。客户端断开时，会触发服务端的异常，此时将其移除。连接的时候，将对应的值放到缓存中。</p></li><li><p>使用乐观锁</p></li><li><p>java - Netty 通道怎么区分对应的用户？ - 个人文章 - SegmentFault 思否<a href="https://segmentfault.com/a/1190000040308397" target="_blank" rel="noreferrer">https://segmentfault.com/a/1190000040308397</a></p></li><li></li></ol><p><strong>集群会话方案：集群中存在session共享的问题，常见方案有如下三种</strong></p><p><a href="https://blog.csdn.net/qq_35363507/article/details/121992530" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_35363507/article/details/121992530</a></p><ol><li><p>Session保持：也叫session粘滞，设置nginx的通过ip_hash的负载均衡策略。缺点：ip基本上都是固定，导致负载失衡。</p></li><li><p>Session复制：在集群之间同步复制Session数据。缺点：任意一个服务器的Session数据发生改变，都会拷贝到其他服务器上去，若存在很多的情况下，不仅会消耗宽带数据，还会占用大量的资源，而且效率低，也有很严重的延迟。<strong>实现方式：</strong>Tomcat集群配置，对每个tomcat节点的server.xml进行配置。</p></li><li><p>Session共享： 与上面相比2种方式相比，Session共享的实用性和可靠性就比较高。使用redis，可持久化，不会丢失，和<code>Spring Session</code>进行集成。</p></li><li><p>使用Token： 能够记住当前用户的信息。使用Token可以避免CSRF攻击，且完美的契合移动端的需求。</p></li><li><p>集群下Session问题：</p></li><li><p>如何保证高可用。</p></li><li><p>中心结点是如何进行备份、热备、冷备、主从。集群方案怎么做</p></li><li><p>防止挂掉，如何监控这些软件的运行。</p></li><li><p>Nginx集群如何判定挂掉</p></li><li><p>Nginx集群负载均衡策略：轮询、权重、ip_hash可以解决session问题</p></li><li><p>Redis相当于注册中心，结点挂了如何快速反馈到redis里面去。</p></li><li><p>如何保证线程的复用和数据污染</p></li></ol><p>确保可靠性：</p><ol><li>连接管理</li><li>确认应答</li><li>超时重传</li></ol><p>使用的技术栈是socket、Netty、tcp</p><p>针对tcp粘包/拆包的问题，面向流的协议，使用<strong>长度字段解码器</strong></p><p>自定义网关传输协议包括，ID、指令类型、发送部门编码、接收部门编码、数据长度，数据内容。指令类型包括发送数据、ping、pong，ack确认等</p><p>大致的传输流程，下级业务系统发送数据给-中间件，中间件逐级向上传输，根据数据包中的目标单位，如果是转发的，则直接继续寻找往下一个节点。如果到达本级，则进行ack回复，一次完整的数据传输，期间涉及到来回3次ack的回复，类似TCP的握手。</p><p>中间件有告警机制，如果和上级网络不通，则进行提醒（调用提醒接口），并进行持久化记录。</p><p>面对网络抖动或者网络不同，设计了重试次数和重试频率，重试时间是指数级增长，防止过于频繁，消耗带宽。同时设置定时任务，对于失败的数据进行定时顺序重发（按ID和时间戳）。</p><p>更新在线状态及时间，使用了乐观锁，加入了version字段，防止线程冲突。</p><p>保证大文件数据的完整性，采用 CRC32 算法（速度快，但是安全性低）校验文件的完整性。</p><ol><li><p>心跳机制，如何实现心跳机制idleStateHandler类</p><p>在通道设置中，增加idleStateHandler，这个处理器会触发idleStateEvent事件，该事件表示连接可能由于超时而变为不活跃状态，设置读写的空闲时间。写45，读60，最大允许超时次数3次就断开</p><p>然后在自定义的<code>ChannelInboundHandlerAdapter</code>中检测<code>IdleStateEvent</code>事件。当检测到写空闲时，可以选择发送一个心跳消息到对端。</p><ul><li>服务端采用 <code>IdleStateHandler</code>，在一段时间内(默认15s)没有读到客户端消息则说明客户端已离线，服务器会触发读超时事件断开连接</li><li>客户端采用定时(默认10s)任务方式向服务端发送一个ping消息作为心跳包，避免服务器读超时事件的发生。</li><li>服务端在收到客户端的ping消息后，将回复一条pong消息给客户端，双方都能检测对方是否活跃。</li></ul></li><li><p>重连机制</p><p>重连策略包含2个维度</p><ul><li><p>是否重连</p><p>设置重连次数来判断是否重连，重连次数耗尽则停止重连并关闭客户端</p></li><li><p>多长时间重连</p><p>短时间内频繁重连既消耗资源又没有必要，好的重连策略希望因为网络抖动偶然断开时能短时间内重连，由于服务器、网络故障长时间断开时，又能在足够大的间隔后重连。因此，默认重连策略的间隔时间随着次数的增加呈指数增长，直到达到最大为止。</p></li></ul></li></ol><p><strong>CIM集群部署</strong></p><p>①服务启动时，向Redis注册自己的节点信息，并指定监听频道。</p><p>​ ②客户端连接Netty Server成功后，并在Redis缓存中绑定用户加入的节点，以便后续信息转发，将信息转发到指定的频道。</p><p>​ ③在Channel转发时，判断如果当前用户在本节点，就直接转发，如果不在，从Redis获取到注册的节点信息，并将消息发布到指定的频道节点。</p><p>通过应用Redis发布订阅，Netty Server多个集群，追加多节点时，新增节点会自动注册监听对于的频道，消息转发时也会自动投递到新注册的节点频道上，可扩展性强。</p><p>项目难点、亮点</p><p>那我说一下这个部门后台管理系统脚手架的升级，我们的项目也是Tob的，通常关注的是系统的功能性、稳定性、可扩展性及个性化定制快速交付的能力。</p><p>升级的目的，标准化，后期规模化，降本增效。</p><p>统一技术栈：方便技术交流和后期技术的沉淀。</p><p>内置常见通用功能及功能组件化，轻量化，可拔插，减少重复开发，提高快速交付能力。</p><p>架构围绕SpringBoot和SpringCloud开展，引入市面上成熟的解决方案和中间件，引入的同时要考虑链路加长带来的问题及给运维带来的复杂性，避免大而全，争取小而美。</p><p>我参与过的项目比较多，承担过整个生命周期的相关工作，所以我在这个项目里我觉得是承担一个架构师的角色，确定功能，评估落地成本和运维的复杂度，并且了解了一下学习成本和团队的上手速度，调研了产品的开源力度，以及项目未来的可扩展性，结合我们的实际业务情况。有些方案不算完美，但综和评估下来，更适合我们目前的情况， 易于团队成员理解和维护的 。</p><p><strong>自己开发的组件</strong></p><p>有国产化的要求，根据databaseId，去适配不同的数据库</p><p>封装CRUD组件，后端代码生成器，基于idea的Mybatisx组件，类似velocity语法，自定义模板，一键在项目包下生成</p><p>自定义注解进行解耦，日志、防重复提交</p><p><strong>比如说在技术栈选型上</strong></p><p>任务调度框架对比了quartz（/kwɔːts/）和xxl-job（ 分布式任务调度 ）</p><p>分库分表框架：对了Mycat（只支持mysql）、 当当的<strong>Sharding-JDBC</strong> ，考虑到适配其他数据库的需要选择了Sharding-JDBC，而且也支持读写分离一些功能，方便后期扩展。</p><p>工作流比对，对比一些老牌的Activiti、 Flowable 等，决定采用国产飞龙工作流，是mybatis-plus的作者开源的，上手简单，更符合国内流程设计，目前也趋于稳定。</p><p><strong>架构是需要逐渐演进的，防止过度设计，合适才是最好的，留出扩展的余地就可以，对于分布式来说</strong></p><p>spring-cloud-starter-gateway做网关</p><p>Dubbo做RPC框架</p><p>nacos做注册中心</p><p>seata分布式事务（ 打的特点特色是AT 模式 ）</p><p>搜索引擎，使用ES</p><p>分布式ID：</p><p>分布式锁：</p><p>分布式缓存：redis</p><p>面对复杂的部署环境，部署用docker</p><p>Nginx 的反向代理和负载均衡配置</p><p><strong>去整理一些常见的解决方案：</strong></p><p>如果对数据特别敏感，则前后端数据需要加签验签。</p><p>保证可靠性，负载均衡，数据库主从复制、集群等</p><p>尽管不能全部精通项目中的所有技术点，但这是根据以往的经验，对软件整个生命周期的一次完整复盘，能从全局视野去看待问题。</p><h2 id="谈谈线程池" tabindex="-1">谈谈线程池 <a class="header-anchor" href="#谈谈线程池" aria-label="Permalink to “谈谈线程池”">​</a></h2><ol><li><p>为什么要用线程池</p><p>线程的创建、销毁比较消耗性能，采用池化的思想，复用线程，提高性能、方便管理，将任务的提交和执行进行解耦，降低使用复杂度。用在处理批量任务、异步任务</p></li><li><p>实现原理</p><p>就是一个线程集合(HashSet)workerset，和一个阻塞队列workQueue。当提交一个任务时，线程池会将任务放入workQueue中，workerset会不断的从workQueue中获取任务执行，如果queue中没有，则worker阻塞，直到有了新任务。</p></li><li><p>JUC提供的ThreadPoolExecutor，对应的核心参数</p><ul><li>corePoolSize。大致的规则是CPU密集：N + 1。IO密集型：2N。但是要根据实际业务去调整，不算银弹。</li></ul></li></ol><ul><li><p>maxPoolSize</p><ul><li>keepAliveTime：线程空闲存活时间</li><li>unit：单位</li><li>factory：线程工厂，自定义设置一个具有辨识度的线程名</li></ul></li><li><ul><li><p>阻塞queue：队列</p><ul><li><p>ArrayBlockingQueue，基于数组的有界队列，FIFO</p></li><li><p>LinkedBlockingQueue，FIFO，基于链表队列，默认大小是Integer.max_value，所以也称为无界队列，采用独立锁，读写分离，性能要高于ArrayBlockingQueue</p></li><li><p>SynchronousQueue：不存储元素的阻塞队列</p></li><li><p>PriorityBlockingQueue ：具有优先级的无界堵塞队列</p></li></ul></li><li><p>handler：饱和策略</p><ul><li>AbortPolicy：直接抛出异常，默认</li><li>由调用者线程去执行</li><li>将最前面的任务丢弃，并且运行当前任务</li><li>直接丢弃</li></ul></li></ul></li></ul><ol start="4"><li><p>execute()执行过程</p><p>当前线程&lt;核心，执行addWoker(command,true)，创建新线程来处理任务</p><p>核心&lt;当前线程&lt;最大线程数，且队列未满时，将任务加入到阻塞队列中，调用queue.offer(command)方法</p><p>核心线程数&lt;当前线程&lt;最大线程数时，且队列已满时，创建新的线程来执行任务</p><p>最大线程数&lt;当前线程时，且队列已满，则执行拒绝策略reject()方法</p></li><li><p>Worker 线程模型继承 AQS 实现了锁机制 。ThreadPoolExecutor内部维护了ReentrantLock类型的mainLock，在访问worker成员变量以及进行相关数据统计记账时需要获取该重入锁。为什么用锁呢？因为workers变量用的是Hashset是线程不安全的，largestpoolsize变量也是没有用volatile修饰的，需要在锁的保护下进行访问。</p></li><li><p>创建线程池</p><p>JAVA开发手册要求必须手动创建，因为自带的可能导致OOM，同时更方便同学理解线程池的运行规则，避免风险</p><ul><li>commons-lang3包</li><li>guava包</li><li>spring配置线程池</li></ul></li><li><p>关闭线程池</p><p>遍历线程池中所有线程，调用线程的<code>interrupt()</code>方法来中断线程。</p><p>shutdown：未执行的立刻停止，正在执行的会继续执行完。</p><p>shutdownNow：立刻停止</p></li><li><p>线程池监控</p><p>可以利用get、set方法以及一些钩子函数，动态调参、监控告警，使用开源项目dynamic tp</p></li><li><p>使用线程池的注意点</p><p>自定义线程池，防止OOM</p><p>任务异常丢失，可以加入trycath捕获。</p><p>ThreadLocal在线程池下会失效，可以考虑阿里开源的TTl类解决||||。线程池中复用线程时，将值传递给实际执行业务的线程，<strong>解决异步执行时的上下文传递问题</strong></p><p>现在基本上用的是spring框架，可以考虑Spring提供的ThreadPoolTaskExecutor类，与Spring有更好的集成，能够在spring关闭上下文时优雅的关闭线程，避免资源泄露的问题。</p></li></ol><h2 id="threadlocal" tabindex="-1">ThreadLocal <a class="header-anchor" href="#threadlocal" aria-label="Permalink to “ThreadLocal”">​</a></h2><p>是一种线程隔离机制，提供了多线程环境下对共享变量的安全访问。一般是需要加锁，性能差，所以以空间换时间。</p><p>当使用ThreadLocal来维护变量时, ThreadLocal会为每个线程创建单独的变量副本, 避免因多线程操作共享变量而导致的数据不一致的情况。</p><p>例如数据库链接管理， Connection变量在多线程下线程不安全，如果使用互斥同步的话，影响性能。这时候需要思考是否需要进行变量共享，这个时候就需要使用ThreadLocal，每个线程中都会对该变量创建一个副本，线程内的任何地方都可以使用，线程之间互不影响</p><p>**如何实现线程隔离 **</p><p>ThreadLocalMap</p><p>源码过程</p><ul><li><p><strong>首先获取当前线程对象t, 然后从线程t中获取到ThreadLocalMap的成员属性threadLocals</strong></p></li><li><p>如果当前线程的threadLocals已经初始化(即不为null) 并且存在以当前ThreadLocal对象为Key的值, 则直接返回当前线程要获取的对象(本例中为Connection);</p></li><li><p>如果当前线程的threadLocals已经初始化(即不为null)但是不存在以当前ThreadLocal对象为Key的的对象, 那么重新创建一个Connection对象, 并且添加到当前线程的threadLocals Map中,并返回</p></li><li><p>如果当前线程的threadLocals属性还没有被初始化, 则重新创建一个ThreadLocalMap对象, 并且创建一个Connection对象并添加到ThreadLocalMap对象中并返回。</p><p>那么我们看过代码之后; 其实就是用了Map的数据结构给当前线程缓存了, 要使用的时候就从本线程的threadLocals对象中获取就可以了, key就是当前线程;</p></li></ul><p><strong>ThreadLocalMap对象是什么</strong></p><p>本质上来讲, 它就是一个Map, 但是这个ThreadLocalMap与我们平时见到的Map有点不一样</p><ul><li>它没有实现Map接口;</li><li>它没有public的方法, 最多有一个default的构造方法, 因为这个ThreadLocalMap的方法仅仅在ThreadLocal类中调用, 属于静态内部类</li><li>ThreadLocalMap的Entry实现继承了WeakReference&lt;ThreadLocal&lt;?&gt;&gt;。好处：一旦不被强引用的时候，可以被回收。</li><li>该方法仅仅用了一个Entry数组来存储Key, Value; Entry并不是链表形式, 而是每个bucket里面仅仅放一个Entry;</li></ul><p><strong>内存泄漏</strong></p><p>用线程池来操作ThreadLocal对象确实会造成内存泄漏，因为线程池里不会销毁的线程，存在着强引用，因为用final static修饰的ThreadLocal并不会释放， 而ThreadLocalMap 对于 Key 虽然是弱引用, 但是强引用不会释放, 弱引用当然也会一直有值, 同时创建的LocalVariable对象也不会释放, 就造成了内存泄露。提供了remove方法来避免内存泄漏， 内部实现就是调用 ThreadLocalMap 的remove方法</p><p><strong>常见应用场景</strong></p><p>Session和数据库连接</p><p>开发手册中对日期格式化的使用， SimpleDateFormat 是线程不安全的。</p><p>Netty中设计了FastThreadLocal，提高性能和解决内存溢出问题</p><ol><li><strong>性能更高</strong>：FastThreadLocal 使用了数组的方式来存储元素，所以它的查询时间复杂度 O(1) 相比于 ThreadLocal 的哈希表操作效率更高。</li><li><strong>安全性更高</strong>：FastThreadLocal 中的 FastThreadLocalRunnable 在最后执行完之后会自动调用 removeAll() 将集合中所有对象都清理掉，可以避免内存泄漏的问题，所以它的安全性更高。</li></ol><p>在线程池下，异步执行时的上下文传递问题，ThreadLocal会失效，可以考虑阿里开源的TTl类解决</p><h2 id="synchronized保证线程安全" tabindex="-1">synchronized保证线程安全 <a class="header-anchor" href="#synchronized保证线程安全" aria-label="Permalink to “synchronized保证线程安全”">​</a></h2><ul><li>对象锁</li><li>方法锁</li><li>类锁</li></ul><p>synchronized 使用它可以实现对共享资源的互斥访问。当一个线程访问被 synchronized 修饰的方法或代码块时，它会自动获取锁，其他线程只能排队等待该线程释放锁。</p><p>synchronized 的底层是通过 Monitor（监视器）实现的。 Synchronized先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，重入的话就累加，任务结束后就会将计数器减一 ，直到计数器为0。</p><p>可见性：线程在释放锁之前，会把共享变量值都刷回主存。利用内存模型和happends-before规则</p><p>有序性：它们能保证那一块区域里的代码都是一次性执行完毕的</p><ol><li></li></ol><h2 id="transactional事务失效" tabindex="-1">@Transactional事务失效 <a class="header-anchor" href="#transactional事务失效" aria-label="Permalink to “@Transactional事务失效”">​</a></h2><p>事务的原理：</p><p>1、非pulic修饰的方法</p><ul><li>因为@Transactional使用的<strong>Spring Aop</strong>实现的，而Aop是通过Jdk或cglib<strong>动态代理</strong>实现的，在生成代理时判断，如果非public修饰的方法，则不生成代理对象。</li></ul><p>2、自定义try/catch导致事务失效</p><ul><li>@Transactional执行流程是：在方法执行前，会自动开启事务；方法执行中，如果有异常，捕获异常，则回滚事务；方法成功执行，则自动提交事务。从源码中看出，如果开发者自动添加了try/catch，则@Transactional不会捕获异常，也就是不会走事务回滚的代码，所以会导致失效。</li></ul><p>3、调用内部的@Transactional方法</p><ul><li>@Transactional是通过代理对象实现的，内部方法调用是通过this实现的，没有使用代理对象。通过 AopContext.currentProxy() 获取代理对象。</li></ul><p>4、多线程调用</p><ul><li>Spring的事务是通过数据库连接来实现的。当前线程中保存了一个map&lt;数据源，数据库连接&gt;。线程间的数据是隔离的，如果用多线程去调用另一个方法的话，就会产生多份ThreadLocal，从而产生多个数据库连接，数据库也就不一样了。同一个事务，是指同一个数据库连接，只有拥有同一个数据库连接，才能同时提交和回滚。</li></ul><p>5、方法用final或static修饰</p><ul><li>Aop是通过代理实现的的，final方法在代理类中无法重写，故而失效。</li></ul><p>5、timeout超时时间设置过小 6、数据库不支持事务 7、未开启事务 8、未被Spring管理 注意点@Transactional(rollbackFor = Exception.class) 一定要加上rollbackFor，大多数情况下是Exception.class 1、大事务问题，调用层级很深，造成整个事务非常耗时 2、编程式事务 TransactionTemplate</p><ol><li>避免由于 spring aop 问题导致事务失效的问题。</li><li>能够更小粒度地控制事务的范围，更直观。</li></ol><h2 id="volatile原理-可见性-有序" tabindex="-1">Volatile原理(可见性|有序） <a class="header-anchor" href="#volatile原理-可见性-有序" aria-label="Permalink to “Volatile原理(可见性|有序）”">​</a></h2><p>特性：1、保证了不同线程对该变量操作的内存可见性。2、禁止指令重排</p><p><strong>JMM(内存可见性、指令重排)</strong></p><p>java虚拟机定义了一种JAVA内存模型，来屏蔽掉各种硬件和操作系统的内存访问差异，让JAVA程序在各种平台上都能达到一致的内存访问模型，CPU加了缓存。每个线程都有自己的工作内存，对工作内存进行操作，然后工作和主存同步，同步不及时，会导致数据不一致，JMM就是解决并发过程中原子性、可见性、有序性这三个问题的。</p><p><strong>原子性：</strong> 对基本数据类型的读取和赋值操作是原子性操作</p><p><strong>可见性</strong>：java就是利用volatile来提供可见性的，当变量被volatile修饰时，对他的修改会立即刷新到主存，其他线程里对应变量的值会过期，直接去读主存。</p><p><strong>有序性</strong>： JMM是允许编译器和处理器对指令重排序的。多线程下，指令重排会导致数据不正确，加上volatile关键字，禁止重排序，保证程序的有序性。</p><p>JMM有8个happends-before规则</p><p><strong>程序顺序规则</strong> 、 <strong>监视器锁规则</strong> 、<strong>volatile变量规则</strong> 、 <strong>传递性</strong> 、</p><p><strong>volatile关键字如何满足并发编程的三大特性的</strong></p><p>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存 。 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量</p><p><strong>能保证原子性吗？</strong>只能对变量的读写保证原子性，对符合操作i++这种不行</p><p><strong>底层实现机制</strong></p><p>如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。</p><p>lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：</p><p>1 . 重排序时不能把后面的指令重排序到内存屏障之前的位置</p><p>2 . 使得本CPU的Cache写入内存</p><p>3 . 写入动作也会引起别的CPU或者别的内核无效化其Cache，相当于让新写入的值对别的线程可见。</p><p><strong>使用场景</strong>：单例模式</p><h1 id="netty" tabindex="-1">Netty <a class="header-anchor" href="#netty" aria-label="Permalink to “Netty”">​</a></h1><p>第一：Netty 是一个 基于 NIO 模型的高性能网络通信框架，其实可以认为它是对NIO网络模式的封装，提供了简单易用的 API，我们可以利用这些封装好的 API 快速开发自己的网络程序。</p><p>第二：Netty 在 NIO 的基础上做了很多优化，比如零拷贝机制、高性能无锁队列、内存池等，因此性能会比 NIO 更高。</p><p>第三：Netty 可以支持多种通信协议，如 Http、WebSocket 等，并且针对数据通信的拆包黏包问题，Netty 内置了拆包策略。</p><p><strong>Netty 线程模型被称为 Reactor（响应式）模型/模式，它是基于 NIO 多路复用模型的一种升级，它的核心思想是将 IO 事件和业务处理进行分离，使用一个或多个线程来执行任务的一种机制</strong>。</p><p><strong>Reactor（反应器）</strong>：Reactor 负责监听和分发事件，它是整个 Reactor 模型的调度中心</p><p><strong>Acceptor（接收器）</strong>：用于处理客户端连接请求 。</p><p><strong>Handlers（处理器）</strong>：Handlers 负责具体的事件处理逻辑，即执行与事件相关的业务操作 。</p><blockquote><p>IO 多路复用技术是一种允许单个线程管理多个网络连接的技术，它使得服务器能够高效地处理大量的并发连接而不需要为每个连接创建一个独立的线程或进程。 技术的实现有select 、 poll 、epoll</p></blockquote><p>netty的线程模型是基于多Reactor模式，该模式是对经典Reactor模式的改进和扩展。</p><ol><li><p>自定义协议方式通讯</p><p>TCP：解决粘包和拆包问题，面向流的协议，使用<strong>长度字段解码器</strong></p><p>udp：固定大小，默认是65535字节，但是由于MTU的1500等限制，一般在1024字节以下，面向消息的协议</p></li><li><p>心跳机制，如何实现心跳机制idleStateHandler类</p><p>在通道设置中，增加idleStateHandler，这个处理器会触发idleStateEvent事件，该事件表示连接可能由于超时而变为不活跃状态，设置读写的空闲时间。写45，读60，最大允许超时次数3次就断开</p><p>然后在自定义的<code>ChannelInboundHandlerAdapter</code>中检测<code>IdleStateEvent</code>事件。当检测到写空闲时，可以选择发送一个心跳消息到对端。</p><ul><li>服务端采用 <code>IdleStateHandler</code>，在一段时间内(默认15s)没有读到客户端消息则说明客户端已离线，服务器会触发读超时事件断开连接</li><li>客户端采用定时(默认10s)任务方式向服务端发送一个ping消息作为心跳包，避免服务器读超时事件的发生。</li><li>服务端在收到客户端的ping消息后，将回复一条pong消息给客户端，双方都能检测对方是否活跃。</li></ul></li><li><p>重连机制</p><p>重连策略包含2个维度</p><ul><li><p>重连次数</p><p>设置重连次数来判断是否重连，重连次数耗尽则停止重连并关闭客户端</p></li><li><p>多长时间重连</p><p>短时间内频繁重连既消耗资源又没有必要，好的重连策略希望因为网络抖动偶然断开时能短时间内重连，由于服务器、网络故障长时间断开时，又能在足够大的间隔后重连。因此，默认重连策略的间隔时间随着次数的增加呈指数增长，直到达到最大为止。</p></li></ul></li></ol><p>防止内存泄漏</p><h2 id="jwt-token" tabindex="-1">JWT|token <a class="header-anchor" href="#jwt-token" aria-label="Permalink to “JWT|token”">​</a></h2><p>json web token 一种安全的登录访问凭证，它通常被用于身份验证和授权机制。 JWT 由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。</p><p>JWT相较于传统的基于会话的Session，具备以下优势 <strong>无需服务器存储状态</strong> 、 <strong>跨域支持</strong>、 <strong>适应微服务架构</strong> 、 <strong>自包含</strong></p><p>使用JWT相较于传统的基于会话的认证机制，可以减少服务器的存储开销和管理复杂性，实现跨域支持和水平扩展，并且更适应无状态和微服务架构。</p><p><strong>实现原理：</strong>JWT本质是将密钥存放在服务器端，并通过某种手段进行加密和验证的机制 。加密签名=某加密算法(header+payload+服务器端私钥)，因为服务端私钥别人不能获取，所以 JWT 能保证自身其安全性。</p><p><strong>token注销问题</strong>：</p><p><strong>双token：</strong>在生成token时，同时生成一个refresh token。当token过期后，可以使用refresh token向服务器请求一个新的token。这样可以避免频繁登录，并且在用户注销登录时，同时使refresh token失效，从而达到注销的目的。</p><p>黑名单机制、设置短的过期时间，有状态的token</p><p>将JWT存储在缓存中，并设置过期时间，比如redis。注销时删除redis，同时可以设置缓存过期时间，到期后失效，每次请求都去更新缓存的有效期。</p><p>accessToken：过期时间短，包含用户信息</p><p>refreshToken：过期时间长</p><p>双token方案的优点：</p><p>增强安全性：</p><p>提升用户体验;</p><h2 id="cookie、session-和-token-区别" tabindex="-1">Cookie、Session 和 Token 区别？ <a class="header-anchor" href="#cookie、session-和-token-区别" aria-label="Permalink to “Cookie、Session 和 Token 区别？”">​</a></h2><p>Cookie、Session 和 Token 通常都是用来保存用户登录信息的技术，但三者有很大的区别，简单来说 <strong>Cookie 适用于简单的状态管理，Session 适用于需要保护用户敏感信息的场景，而 Token 适用于状态无关的身份验证和授权。</strong></p><p>具体来说，Cookie、Session 和 Token 的区别主要有以下几点区别：</p><ol><li><strong>存储位置不同</strong>：Cookie 存储在客户端，即浏览器中的文本文件，通过在 HTTP 头中传递给服务器来进行通信；Session 是服务器端的存储方式，通常存储在服务器的内存或数据库中；Token 也是存储在客户端，但是通常以加密的方式存储在客户端的 localStorage 或 sessionStorage 中。</li><li><strong>数据安全性不同</strong>：Cookie 存储在客户端，可能会被窃取或篡改，因此对敏感信息的存储需要进行加密处理；Session 存储在服务器端，通过一个 Session ID 在客户端和服务器之间进行关联，可以避免敏感数据直接暴露；Token 通常使用加密算法生成，有效期较短且单向不可逆，可以提供较高的安全性。</li><li><strong>跨域支持不同</strong>：为了防止安全事故，因此 Cookie 是不支持跨域传输的，也就是不同域名下的 Cookie 是不能相互访问的；而 Session 机制通常是通过 Cookie 来保存 Session ID 的，因此 Session ID 默认情况下也是不支持跨域的；但 Token 可以轻松实现跨域，因为 Token 是存储在客户端的 localStorage 或者作为请求头的一部分发送到服务器的，所以不同的域名 Token 信息传输通常是不受影响的。</li><li><strong>状态管理不同</strong>：Cookie 是应用程序通过在客户端存储临时数据，用于实现状态管理的一种机制；Session 是服务器端记录用户状态的方式，服务器会为每个会话分配一个唯一的 Session ID，并将其与用户状态相关联；Token 是一种用于认证和授权的一种机制，通常表示用户的身份信息和权限信息。</li></ol><p>Cookie、Session 和 Token 通常都是用来保存用户登录信息的技术，但三者的区别很大：Cookie 适用于简单的状态管理，Session 适用于需要保护用户敏感信息的场景，而 Token 适用于状态无关的身份验证和授权。默认情况下 Session 使用了 Cookie 机制来传递 Session ID，但在禁用 Cookie 的情况下，使用特殊的手段依然可以传递 Session ID，依然可以继续使用 Session 机制。<strong>而 Token 是不在服务器端保存会话信息的，因此更适用于大型项目和分布式项目</strong></p><h2 id="缓存穿透" tabindex="-1">缓存穿透 <a class="header-anchor" href="#缓存穿透" aria-label="Permalink to “缓存穿透”">​</a></h2><p>是指在缓存系统中，大量的请求查询不存在于缓存和数据库中的数据，导致这些请求直接访问数据库，占用数据库资源，而缓存无法发挥作用的现象。</p><p>缓存穿透可能发生的原因包括：</p><ol><li>恶意请求（异常情况）：攻击者发送大量恶意请求，故意查询不存在的数据，以触发缓存穿透。</li><li>高并发请求（正常业务）：当有大量的并发请求同时查询不存在的数据时，可能会导致缓存无法命中，从而触发缓存穿透。</li></ol><p>为了解决缓存穿透问题，可以采取以下策略：</p><ol><li>布隆过滤器（Bloom Filter）：布隆过滤器是一种高效的数据结构，可以用于快速判断一个元素是否存在于集合中。在缓存层引入布隆过滤器，可以在查询请求到达时，首先通过布隆过滤器判断该请求对应的数据是否存在于缓存或数据库中，从而避免无效的查询操作。</li><li>缓存空值处理：对于查询数据库返回的空结果，也可以将空结果缓存起来，设置一个较短的过期时间，避免频繁查询数据库。这样在下次查询相同的数据时，可以直接从缓存中获取空结果，而不需要再次查询数据库。</li><li>异步加载缓存：当缓存未命中时，可以异步加载数据到缓存中，避免在高并发场景下直接访问数据库。在异步加载过程中，可以通过互斥锁或分布式锁来保证只有一个线程去加载数据，避免重复加载。</li><li>限制恶意请求：通过访问频率控制、验证码等手段，限制对缓存的恶意请求，防止攻击者通过查询不存在的数据来触发缓存穿透。</li></ol><h2 id="缓存雪崩" tabindex="-1">缓存雪崩 <a class="header-anchor" href="#缓存雪崩" aria-label="Permalink to “缓存雪崩”">​</a></h2><p>缓存雪崩是指在缓存中大量的键同时过期或失效，导致请求直接访问数据库或后端服务，给数据库或后端服务造成巨大压力，导致系统性能下降甚至崩溃的现象。</p><p>缓存雪崩可能发生的原因包括：</p><ol><li>大量缓存键同时过期：当缓存键设置了相同的过期时间，或者由于某种原因导致大量的键同时失效，会导致缓存雪崩。</li><li>缓存服务器故障：当缓存服务器发生故障，无法提供服务时，请求将直接访问后端服务，导致压力集中在后端服务上。</li></ol><p>为了解决缓存雪崩问题，可以采取以下策略：</p><ol><li>设置随机过期时间：为缓存键设置随机的过期时间，避免大量键同时过期的情况发生，减少缓存雪崩的概率。</li><li>实现缓存预热：在系统启动或缓存失效前，提前加载热门数据到缓存中，避免在关键时刻大量请求直接访问后端服务。</li><li>使用分布式缓存：将缓存数据分布在多个缓存节点上，通过分散请求负载来减少单个缓存节点的压力，提高系统的可用性和抗压能力。</li><li>设置熔断机制：在缓存失效的情况下，通过设置熔断机制，直接返回默认值或错误信息，避免请求直接访问后端服务，减轻后端服务的压力。</li><li>实时监控和报警：监控缓存系统的状态和性能指标，及时发现异常情况，并通过报警机制通知运维人员进行处理，减少缓存雪崩的影响。</li></ol><h2 id="缓存击穿" tabindex="-1">缓存击穿 <a class="header-anchor" href="#缓存击穿" aria-label="Permalink to “缓存击穿”">​</a></h2><p>缓存击穿是指在缓存系统中，某个热点数据过期或失效时，同时有大量的请求访问该数据，导致请求直接访问数据库或后端服务，给数据库或后端服务造成巨大压力，导致系统性能下降甚至崩溃的现象。</p><p>缓存击穿可能发生的原因包括：</p><ol><li>在高并发环境下，访问同一个过期失效的热点数据，导致大量请求同时访问数据库，对数据库造成极大压力。</li></ol><p>为了解决缓存击穿问题，可以采取以下策略：</p><ol><li>设置热点数据永不过期或过期时间较长：对于一些热点数据，可以将其设置为永不过期，或者设置一个较长的过期时间，确保热点数据在缓存中可用，减少因为过期而触发的缓存击穿。</li><li>加互斥锁或分布式锁：在访问热点数据时，可以引入互斥锁或分布式锁，保证只有一个线程去访问后端服务或数据库，其他线程等待结果。当第一个线程获取到数据后，其他线程可以直接从缓存获取，避免多个线程同时访问后端服务，减轻压力。</li><li>限制并发访问：通过限制并发访问热点数据的请求量，可以控制请求的流量，避免过多请求同时访问热点数据。</li></ol><h1 id="mysql" tabindex="-1">MySQL <a class="header-anchor" href="#mysql" aria-label="Permalink to “MySQL”">​</a></h1><h2 id="mysql的事务acid或原理" tabindex="-1">MYSQL的事务ACID或原理 <a class="header-anchor" href="#mysql的事务acid或原理" aria-label="Permalink to “MYSQL的事务ACID或原理”">​</a></h2><p><strong>如何保证事务的四大特性？</strong></p><p>以默认的引擎 InnoDB 为例，它保证四大特性的手段分别是：</p><ol><li>A原子性： 由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql 。</li><li>C一致性：一般由代码层面来保证。数据库也提供了一些，比如主键的唯一约束，字段长度和类型的保证等等。</li><li>I隔离性：提供了4种隔离级别，默认隔离级别是RR（可重复读），是通过 MVCC（多版本并发控制）解决了脏读和不可重复读的问题， 锁机制的方式解决幻读的问题。</li><li>D持久性： 由<code>Buffer Pool缓冲区</code>+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</li></ol><h2 id="mvcc" tabindex="-1"><strong>MVCC</strong> <a class="header-anchor" href="#mvcc" aria-label="Permalink to “MVCC”">​</a></h2><p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种并发控制机制，用于在数据库系统中处理并发读写操作时保持数据的一致性和隔离性（<strong>主要是用来解决幻读问题的</strong>）。MVCC 通过在每个数据行上保存多个版本的数据来实现并发读取和写入的一致性。</p><p><strong>MVCC 的核心思想是将每个事务的读操作与写操作解耦，通过保存数据的历史版本来实现并发控制</strong>。每个事务在开始时会创建一个读视图（Read View），用于确定在事务开始时可见的数据版本。读视图包含一个事务开始时的系统版本号，用于与数据行的版本号进行比较，以确定数据行是否对事务可见。</p><p>在 MVCC 中，当一个事务执行写操作时，会生成一个新的数据版本，并将旧版本的数据保存在回滚日志（Undo Log）中。这样，其他事务在读取数据时仍然可以访问到旧版本的数据，从而避免了幻读问题。</p><p>update触发了<strong>当前读</strong>的情况下，导致在该事务中的前后查询的数据行不一致的情况。使用forupdate语句加锁</p><h2 id="mysql索引b-树" tabindex="-1">MYSQL索引B+树 <a class="header-anchor" href="#mysql索引b-树" aria-label="Permalink to “MYSQL索引B+树”">​</a></h2><p>MySQL 中默认的存储引擎 InnoDB 的索引是使用 B+ 树实现的。B+ 树是一种多路平衡搜索树，它的叶子节点存储了所有的数据行信息，叶子节点之间使用指针（双向链表）连接，方便范围查询和排序等操作，非叶子节点存储的是索引字段的值，这样就可以通过非叶子节点的索引值快速定位到叶子节点的数据 。高度就意味着磁盘IO的数量，减少磁盘IO的次数</p><h2 id="mysql最左匹配原则" tabindex="-1">Mysql最左匹配原则 <a class="header-anchor" href="#mysql最左匹配原则" aria-label="Permalink to “Mysql最左匹配原则”">​</a></h2><p>最左前缀原则就是只要查询的是联合索引的最左 N 个字段，就可以利用该联合索引来加速查询。 不按照最左匹配来为什么失效，其原因就在于联合索引的 B+ 树中的键值是排好序的。不过，这里指的排好序，其实是相对的，举个例子，有 (a, b, c) 联合索引，a 首先是排序好的，而 b 列是在 a 列排序的基础上做的排序，同样的 c 是在 a,b 有序的基础上做的排序。所以说，如果有 <code>where a = xxx order by b = xxx</code> 这种请求的话，是可以直接在这颗联合索引树上查出来的，不用对 b 列进行额外的排序；而如果是 <code>where a = xxx order by c = xxx</code> 这种请求的话，还需要额外对 c 列进行一次排序才行。 另外，如果有对 a,b,c 的联合条件查询的话，并且 a 是模糊匹配或者说是范围查询的话，其实并不能完全踩中联合索引（a,b,c），a 列右边的所有列都无法使用索引进行快速定位了。所以这个时候就需要进行回表判断。也就是说数据库会首先根据索引来查找记录，然后再根据 where 条件来过滤记录。 不过在 MySQL 5.6 中支持了索引下推 ICP，数据库在取出索引的同时，会根据 where 条件直接过滤掉不满足条件的记录，减少回表次数</p><p>联合索引：先导列（最左边的列）选择区分度高的，同时也需要考虑查询命中率的问题。</p><p>在一定条件下可以不遵循最左前缀原则，Mysql8.0引入了index skip scan。a、b、c种where b=5也是会走索引的。</p><p>skip scan的限定条件：联合索引、单表查询不能使用DISTINCT 和GROUP BY 关键字、只能使用<code>覆盖索引（最大的限制）</code>查询条件必须是常量。</p><p>原理：使用了穷举法，有局限性，适用于区分度比较小的字段。</p><h2 id="mysql什么情况下索引失效" tabindex="-1">Mysql什么情况下索引失效 <a class="header-anchor" href="#mysql什么情况下索引失效" aria-label="Permalink to “Mysql什么情况下索引失效”">​</a></h2><ol><li><p>未遵循最左匹配原则</p></li><li><p>使用列运算</p></li><li><p>使用函数方法</p></li><li><p>类型转换</p></li><li><p>使用 is not null</p></li><li><p>错误的模糊匹配</p></li><li><p>OR语句前后没有同时使用索引</p></li><li></li></ol><h1 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to “设计模式”">​</a></h1><h2 id="工厂-抽象模式" tabindex="-1">工厂|抽象模式 <a class="header-anchor" href="#工厂-抽象模式" aria-label="Permalink to “工厂|抽象模式”">​</a></h2><p>工厂方法模式也是一种创建型设计模式，简单工厂模式只有一个工厂类 ，负责创建所有产品，如果要添加新的产品，通常需要修改工厂类的代码。<strong>而工厂方法模式引入了抽象工厂和具体工厂的概念</strong>，每个具体工厂只负责创建一个具体产品，添加新的产品只需要添加新的工厂类而无需修改原来的代码，这样就使得产品的生产更加灵活，支持扩展，符合开闭原则。</p><h2 id="策略模式" tabindex="-1">策略模式 <a class="header-anchor" href="#策略模式" aria-label="Permalink to “策略模式”">​</a></h2><p>策略模式是一种行为型设计模式，它定义了一系列算法（这些算法完成的是相同的工作，只是实现不同），并将每个算法封装起来，使它们可以相互替换，而且算法的变化不会影响使用算法的客户。</p><p>举个例子，电商网站对于商品的折扣策略有不同的算法，这种情况下会产生大量的<code>if-else语句</code>, 并且如果优惠政策修改时，还需要修改原来的代码，不符合开闭原则。</p><p>这就可以将不同的优惠算法封装成独立的类来避免大量的条件语句，如果新增优惠算法，可以添加新的策略类来实现，客户端在运行时选择不同的具体策略，而不必修改客户端代码改变优惠策略。</p><p>策略模式包含下面几个结构：</p><ul><li>策略类<code>Strategy</code>: 定义所有支持的算法的公共接口。</li><li>具体策略类<code>ConcreteStrategy</code>: 实现了策略接口，提供具体的算法实现。</li><li>上下文类<code>Context</code>: 包含一个策略实例，并在需要时调用策略对象的方法。</li></ul><h2 id="观察者模式" tabindex="-1">观察者模式 <a class="header-anchor" href="#观察者模式" aria-label="Permalink to “观察者模式”">​</a></h2><p>观察者模式（发布-订阅模式）属于行为型模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象，当主题对象的状态发生变化时，所有依赖于它的观察者都得到通知并被自动更新。 像仿真推演种，时间轴驱动所有的Agent。</p><p>优点：观察者和被观察者之间建立一个抽象的耦合。观察者模式支持广播通信</p><p>缺点：观察者之间有过多的细节依赖，提高时间消耗及程序复杂度，使用要得当，避免循环调用。观察者太多的时候，就不合适。</p><h2 id="命令模式" tabindex="-1">命令模式 <a class="header-anchor" href="#命令模式" aria-label="Permalink to “命令模式”">​</a></h2><p>命令模式是一种行为型设计模式，其允许<strong>将请求封装成一个对象</strong>(命令对象，包含执行操作所需的所有信息)，<strong>并将命令对象按照一定的顺序存储在队列中，然后再逐一调用执行，这些命令也可以支持反向操作，进行撤销和重做。</strong> 像推演系统中每个agent执行的命令。</p><h2 id="中介者模式" tabindex="-1">中介者模式 <a class="header-anchor" href="#中介者模式" aria-label="Permalink to “中介者模式”">​</a></h2><p>中介者模式（Mediator Pattern）也被称为调停者模式，是一种行为型设计模式，它通过一个中介对象来封装一组对象之间的交互，从而使这些对象不需要直接相互引用。这样可以降低对象之间的耦合度，使系统更容易维护和扩展。 像仿真推演系统中agent之间的互相调用。</p><p>优点：将一对多转换成了一对一，降低程序复杂度，类之间解耦。</p><p>缺点：中介者过多，导致系统复杂。</p><h1 id="tcp和udp" tabindex="-1">TCP和UDP <a class="header-anchor" href="#tcp和udp" aria-label="Permalink to “TCP和UDP”">​</a></h1><h2 id="tcp和udp区别" tabindex="-1">TCP和UDP区别 <a class="header-anchor" href="#tcp和udp区别" aria-label="Permalink to “TCP和UDP区别”">​</a></h2><p><strong>TCP 有连接；UDP 无连接。</strong></p><p><strong>TCP 可靠；UDP 不可靠。</strong></p><p><strong>TCP 基于数据流；UDP 基于数据报。</strong></p><p>UDP 比 TCP 更高效。</p><p>TCP 发送缓冲区、接收缓冲区；UDP 只有接收缓冲区，没有发送缓冲区</p><h2 id="tcp三次握手-四次挥手" tabindex="-1">TCP三次握手|四次挥手 <a class="header-anchor" href="#tcp三次握手-四次挥手" aria-label="Permalink to “TCP三次握手|四次挥手”">​</a></h2><p><strong>TCP为什么需要三次挥手？</strong></p><p>TCP 通讯的双方都是全双工的，所以他们彼此要证明自己和对方的发送能力和接收能力。 TCP 如果两次握手不能证明服务器端的发送能力和客户端的接受能力 -&gt; 两次握手。 <strong>TCP 至少需要三次握手才能证明彼此的全双工能力。</strong></p><p><strong>TCP为什么需要四次挥手？</strong></p><ol><li>TCP 本身自带确认应答。</li><li>TCP 有接收缓冲区的任务可能没执行完。</li></ol><h1 id="jvm" tabindex="-1">JVM <a class="header-anchor" href="#jvm" aria-label="Permalink to “JVM”">​</a></h1><h2 id="jvm-分代年龄为什么是15-次-可以25次吗" tabindex="-1">JVM 分代年龄为什么是15 次？可以25次吗？ <a class="header-anchor" href="#jvm-分代年龄为什么是15-次-可以25次吗" aria-label="Permalink to “JVM 分代年龄为什么是15 次？可以25次吗？”">​</a></h2><p>4个bit，最大支持15</p><h2 id="jvm调优" tabindex="-1">JVM调优 <a class="header-anchor" href="#jvm调优" aria-label="Permalink to “JVM调优”">​</a></h2><p>要进行 JVM 调优无非就是以下两种情况：</p><p><strong>1. 目标驱动型的 JVM 调优</strong>，如，我们是为了最短的停顿时间所以要进行 JVM 调优（CMS或G1），或者是我们为了最大吞吐量（JDK8的）所以要进行 JVM 调优等。</p><ul><li>设置对应的垃圾收集器</li><li>JVM 常见的垃圾回收器有以下几个： <ol><li>Serial/Serial Old：单线程垃圾回收器；</li><li>ParNew：多线程的垃圾回收器（Serial 的多线程版本）；</li><li>Parallel Scavenge/Parallel Old：吞吐量优先的垃圾回收器【JDK8 默认的垃圾回收器】；</li><li>CMS：最小等待时间优先的垃圾收集器；</li><li>G1：可控垃圾回收时间的垃圾收集器【JDK 9 之后（HotSpot）默认的垃圾回收器】；</li><li>ZGC： 是 JDK 11 引入，JDK 15 之后默认的垃圾回收器，它可以实现毫秒级停顿和大内存支持，适用于需要低延迟和高吞吐量的场景</li></ol></li></ul><p><strong>2. 问题驱动型的 JVM 调优</strong>，因为生产环境出现了频繁的 FullGC 了，导致程序执行变慢，所以我们要进行 JVM 调优。</p><ul><li>分析JVM运行情况。 主流的监控工具 Prometheus + Grafana 和 JDK 自带的命令行工具。开源工具Arthas （阿尔萨斯） 等</li><li>主要分析的点是 Young GC 和 Full GC 的频率，以及垃圾回收的执行时间。</li></ul><p><strong>3.设置JVM调优参数</strong></p><ul><li>查看代码中，减少对象的创建和存活时间</li></ul><ul><li><strong>调整堆内存大小</strong>：通过设置 -Xms（初始堆大小）和 -Xmx（最大堆大小）参数来调整堆内存大小，避免频繁的垃圾回收。</li><li><strong>选择合适的垃圾回收器</strong>： 如CMS、ZGC</li><li><strong>调整新生代和老年代比</strong> ，通过newRatio参数来调整新生代和老年代的比例，优化内存分配。</li><li><strong>设置合适的堆中的各个区域比例</strong></li><li><strong>设置对象从年轻代进入老年代的年龄值</strong></li><li><strong>设置元空间大小等</strong>。通过设置 MaxMetaspaceSize 设置元空间最大容量。</li></ul><p><strong>4.压测观测调优后的效果</strong></p><p><strong>5.应用调优后的配置</strong></p><h1 id="kafka" tabindex="-1">Kafka <a class="header-anchor" href="#kafka" aria-label="Permalink to “Kafka”">​</a></h1><h2 id="为什么要用mq" tabindex="-1">为什么要用MQ <a class="header-anchor" href="#为什么要用mq" aria-label="Permalink to “为什么要用MQ”">​</a></h2><ol><li>异步：同步接口调用导致相应时间长的问题。</li><li>解耦：子系统之间耦合性太大。</li><li>削峰：</li></ol><h2 id="引入mq导致的问题" tabindex="-1">引入MQ导致的问题： <a class="header-anchor" href="#引入mq导致的问题" aria-label="Permalink to “引入MQ导致的问题：”">​</a></h2><ol><li>重复消息问题：消费者设计幂等。设计一张消费消息表，根据messageId，去查询是否存在，如果不存在，则执行业务和消息入库，在同一个事务中</li><li>数据一致性问题（分布式事务）：业务量比较小的场景，可以采用同步重试。大数据量：异步重试</li><li>消息丢失问题：概率很小。设计一张表，生产者发完消息后，往表中写入一条数据，状态为待确认。如果消费者已经读取完，调用生产者的API更新该消息的状态为已确认。有个JOB，每隔一段时间检查消息发送表，如果5分钟，有状态还是待确认，则认为消息丢失。进行重发。</li><li>消息顺序问题：有些情况，消费者不需要关注中间状态，只关注最终状态。如果需要最终的话，同一个订单号路由到同一个<code>partition</code>里面。</li><li>消息堆积：如果不需要保证顺序，读取消息之后，使用多线程处理业务逻辑。</li><li>系统复杂度提升：</li></ol><h2 id="kafka如何保证消息不丢失" tabindex="-1">Kafka如何保证消息不丢失 <a class="header-anchor" href="#kafka如何保证消息不丢失" aria-label="Permalink to “Kafka如何保证消息不丢失”">​</a></h2><ol><li><p>保证<strong>生产者消息不丢失</strong>。</p><ul><li>网络抖动（消息不可达）：解决方案是重试</li><li>消息确认设置 acks参数=all，最高可靠性，但性能较低， 只有当所有同步副本都确认接收到消息后，生产者才会收到确认，确保了消息的可靠性</li></ul></li><li><p>保证 <strong>Kafka 服务（器端）消息不丢失</strong>。</p><ul><li><p>副本机制： 通过副本（replica）来实现数据冗余</p></li><li><p>ISR机制： 只有在 ISR 中的副本都成功写入消息后，生产者才会收到确认（当 acks=-1 或 all 时）</p><p>引入ISR机制的原因：</p><ol><li>数据同步效率问题，同步效率不高的会被剔除ISR列表。</li><li>避免数据丢失，因为ISR里面的节点数据是和Leader副本最接近的。</li></ol></li></ul></li><li><p>保证<strong>消费者消息不丢失</strong>。</p><ul><li>手动提交偏移量offset。可能造成重复消费，注意幂等性</li></ul></li></ol><h2 id="kafka怎么避免消息重复" tabindex="-1">Kafka怎么避免消息重复 <a class="header-anchor" href="#kafka怎么避免消息重复" aria-label="Permalink to “Kafka怎么避免消息重复”">​</a></h2><p><strong>出现重复消费的情况：</strong></p><ol><li>默认自动提交offset，避免重复消费，在消费过程中，消费者宕机，没有提交offset。</li><li>Kafka里面有个Partition Blance机制，把多个Partition均衡的分配给多个消费者，如果5分钟之内，没有消费完成，触发Kafka的<code>Rebalance</code>机制，导致重复消费。</li></ol><p><strong>解决办法：</strong></p><ol><li>提高消费端的处理性能避免触发<code>Rebalance</code>机制，比如使用异步的方式来处理消息，缩短单个消费者的消费时长。减少一次性从Broker上拉取数据的条数。</li><li>消费者使用幂等机制，进行防重复提交。将请求的数据，进行MD5加密，存在redis或数据库中，进行唯一性校验。</li></ol><h2 id="kafka如何保证消息消费的顺序性" tabindex="-1">Kafka如何保证消息消费的顺序性 <a class="header-anchor" href="#kafka如何保证消息消费的顺序性" aria-label="Permalink to “Kafka如何保证消息消费的顺序性”">​</a></h2><p>为什么会存在无序消费</p><p>在同一个topic下，存在多个partition分区，生产者在生产消息时，会根据key进行取模，来决定把当前消息存储到哪个partition里面，并且消息是按照先后顺序的。</p><ol><li><p>如果被路由到不同的partition里面，因为消费者是独立的，就可能导致乱序的问题。</p><p>解决：自定义路由算法，将指定的key发送到同一个partition里面，指定一个消费者专门来消费某个分区里面的数据，这样就能保证消息的顺序消费了。</p></li><li><p>消费端会采用异步的方式来消费数据，提高消息的处理效率，每个线程的处理速度是不一样的，也会出现乱序</p><p>解决：在消费者加入一个阻塞队列，把获取到的消息先保存到阻塞队列中，然后再通过异步线程从阻塞队列里去消费。</p></li></ol><p><strong>如果我不想把消息路由到同一个分区，但是还想实现消息的顺序消费，怎么办？</strong></p><p>严格来说，Kafka只能保证单个分区有序，如果要实现，代价太大，没有必要。</p><h1 id="spring" tabindex="-1">Spring <a class="header-anchor" href="#spring" aria-label="Permalink to “Spring”">​</a></h1><h2 id="spring-boot-的约定优于配置-你的理解是什么" tabindex="-1"><strong>Spring Boot 的约定优于配置，你的理解是什么？</strong> <a class="header-anchor" href="#spring-boot-的约定优于配置-你的理解是什么" aria-label="Permalink to “Spring Boot 的约定优于配置，你的理解是什么？”">​</a></h2><p>我从 4 个方面来回答。</p><ol start="3"><li><p>首先， 约定优于配置是一种软件设计的范式，它的核心思想是减少软件开发人员对于配置项的维护，从而让开发人员更加聚焦在业务逻辑上。</p></li><li><p>Spring Boot 就是约定优于配置这一理念下的产物，它类似于 Spring 框架下的一个脚手架，通过Spring Boot，我们可以快速开发基于 Spring 生态下的应用程序。</p></li><li><p>基于传统的Spring框架开发web应用，我们需要做很多和业务开发无关并且只需要做一次的配置，比如</p><p>a. 管理 jar 包依赖</p><p>b. web.xml 维护</p><p>c. Dispatch-Servlet.xml 配置项维护</p><p>d. 应用部署到 Web 容器</p><p>e. 第三方组件集成到 Spring IOC 容器中的配置项维护 而在 Spring Boot 中，我们不需要再去做这些繁琐的配置，Spring Boot 已经自动帮我们完成了，这就是约定于配置思想的体现。</p></li><li><p>Spring Boot 约定优于配置的体现有很多，比如</p><p>a. Spring Boot Starter 启动依赖，它能帮我们管理所有 jar 包版本</p><p>b. 如果当前应用依赖了 spring mvc 相关的 jar，那么 Spring Boot 会自动内置Tomcat 容器来运行 web 应用，我们不需要再去单独做应用部署。</p><p>c. Spring Boot 的自动装配机制的实现中，通过扫描约定路径下的spring.factories 文件来识别配置类，实现 Bean 的自动装配。</p><p>d. 默认加载的配置文件 application.properties 等等。 总的来说，约定优于配置是一个比较常见的软件设计思想，它的核心本质都是为了更高效以及更便捷地实现软件系统的开发和维护。</p></li></ol><h2 id="ioc和aop" tabindex="-1">IOC和AOP <a class="header-anchor" href="#ioc和aop" aria-label="Permalink to “IOC和AOP”">​</a></h2><ol><li><p>IOC：实现方式是DI</p><p><strong>核心思想：</strong>将对象的管理交给IOC容器，设计的好处是降低了对象与对象之间的解耦，直接从容器里获取即可。</p><p><strong>工作流程：</strong></p><ol><li>容器的初始化。解析通过xml或者@Bean定义的对象，生成一个BeanDefinition实体，并保存到一个Map中。</li><li>Bean的初始化及依赖注入。通过反射将bean注入到IOC容器里</li><li>Bean的使用。通过DI注入的方式，获取制定bean的实例。</li></ol></li><li><p>AOP：面向切面编程</p><p>讲实现：</p><ol><li>框架添加 AOP 依赖</li><li>定义切面（@Aspect）并且将它放到 IoC 容器</li><li>定义切点 -&gt; @Pointcut 拦截规则</li><li>定义通知 -&gt; 拦截之后的执行方法</li></ol><p>讲原理：动态代理</p><ol><li>JDK代理</li><li>GCLib</li></ol></li></ol><h2 id="websocket" tabindex="-1">WebSocket <a class="header-anchor" href="#websocket" aria-label="Permalink to “WebSocket”">​</a></h2><p>WebSocket是一种网络通信协议，它提供了一种在<strong>单个TCP连接上进行全双工通信</strong>的方式 ，与传统的HTTP协议不同，WebSocket允许服务器和客户端之间的双向通信，而不需要每次都建立新的连接。这种通信方式使得实时应用变得更加容易实现，如在线聊天、实时数据更新等。</p><h2 id="oom内存溢出" tabindex="-1">OOM内存溢出 <a class="header-anchor" href="#oom内存溢出" aria-label="Permalink to “OOM内存溢出”">​</a></h2><p>驾驶员的系统，导出excel的需求，数据量增长，导致OOM</p><p>采用分页查询，分批次写入Excel的方式。</p><h2 id="http和https的区别" tabindex="-1">http和https的区别？ <a class="header-anchor" href="#http和https的区别" aria-label="Permalink to “http和https的区别？”">​</a></h2><ul><li>其实HTTPS就是从HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护</li></ul><p><strong>1、</strong> http需要拿到ca证书，需要钱的；</p><p><strong>2、</strong> 端口不一样，http是80，https443；</p><p><strong>3、</strong> http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议；</p><p><strong>4、</strong> http和https使用的是完全不同的连接方式（http的连接很简单，是无状态的；HTTPS协议是；由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。）</p><h2 id="https的执行流程" tabindex="-1">HTTPS的执行流程？ <a class="header-anchor" href="#https的执行流程" aria-label="Permalink to “HTTPS的执行流程？”">​</a></h2><p>HTTPS 执行流程：</p><ol><li>客户端（浏览器）发送 HTTPS 请求到服务器端。</li><li>服务器端使用非对称加密，产生一个公钥，将公钥和 CA 证书给到客户端。</li><li>客户端验证 CA 证书真伪，使用对称加密生成一个共享秘钥，使用刚才的公钥将共享秘钥进行加密，将加密信息发送给服务器端。</li><li>服务器端得到信息之后，使用非对称加密私钥进行解密，得到对称加密的共享秘钥进行通讯</li></ol><h1 id="redis" tabindex="-1">Redis <a class="header-anchor" href="#redis" aria-label="Permalink to “Redis”">​</a></h1><h2 id="常见场景" tabindex="-1">常见场景： <a class="header-anchor" href="#常见场景" aria-label="Permalink to “常见场景：”">​</a></h2><ol><li>密码错误次数</li><li>手机验证码的有效期</li><li>单位分类树的缓存</li><li>GEO地图圈选</li><li>分布式锁获取第三方接口的token</li><li>防重复提交</li></ol><h2 id="redisson分布式锁ap" tabindex="-1">Redisson分布式锁AP <a class="header-anchor" href="#redisson分布式锁ap" aria-label="Permalink to “Redisson分布式锁AP”">​</a></h2><p>redis实现分布式锁</p><ol><li>setnx存在死锁问题</li><li>setnx expire加入过期时间，存在误删除问题，不可重入问题、锁无法续期问题</li><li>lua脚本：实现复杂，且存在锁无法续期问题</li><li>redisson框架。默认非公平锁，实现简单，解决了锁重入和续期问题。</li></ol><p>续期问题： 一个线程拿到锁，另一个线程尝试加锁需要自旋去获取这把锁，；加锁这里有watch dog机制，能给锁续命，自旋这里会有阻塞、唤醒机制保证高性能。续命是使用的递归，方法嵌套。加锁和可重入还是用的lua脚本</p><p>加锁逻辑中式订阅了一个信道的，订阅信道目的是唤醒线程停止阻塞</p><p>唤醒机制：publish subscribe 发布订阅模型，这里理解成一个队列也可，在redis中叫做信道channel</p><p>原生分布式锁判断这个线程的唯一标识是用过uuid，redisson中靠的是uuid+threadId</p><p>分布式下可以使用redLock。因为性能和并发安全性问题，逐渐被废弃。现在依旧使用普通锁，保证最终一致性。</p><p><strong>Zookeeper实现分布式锁：</strong></p><ol><li>利用临时有序节点，属于CP理论，强一致性，适合做分布式锁。</li><li>如果获取不到锁，就添加一个监听器就可以了，不用一直轮询，性能消耗较少。</li><li>如果有较多的客户端频繁的申请加锁，释放锁，对于ZK集群的压力较大。</li></ol><h2 id="redis的哨兵模式和集群模式对比" tabindex="-1">redis的哨兵模式和集群模式对比 <a class="header-anchor" href="#redis的哨兵模式和集群模式对比" aria-label="Permalink to “redis的哨兵模式和集群模式对比”">​</a></h2><p><a href="https://blog.csdn.net/ttyy1112/article/details/145616282" target="_blank" rel="noreferrer">https://blog.csdn.net/ttyy1112/article/details/145616282</a></p><h2 id="谈谈你对aqs的理解" tabindex="-1"><strong>谈谈你对AQS的理解</strong> <a class="header-anchor" href="#谈谈你对aqs的理解" aria-label="Permalink to “谈谈你对AQS的理解”">​</a></h2><p>AQS 是多线程同步器，它是 J.U.C 包中多个组件的底层实现，如 Lock、CountDownLatch、Semaphore等都用到了 AQS. 从本质上来说，AQS 提供了两种锁机制，分别是排他锁，和 共享锁。排它锁，就是存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源，比如 Lock 中的 ReentrantLock 重入锁实现就是用到了AQS中的排它锁功能。 共享锁也称为读锁，就是在同一时刻允许多个线程同时获得锁资源，比如CountDownLatch和Semaphore 都是用到了 AQS 中的共享锁功能。</p><h2 id="fail-safe-机制与-fail-fast-机制分别有什么作用" tabindex="-1"><strong>fail-safe 机制与 fail-fast 机制分别有什么作用</strong> <a class="header-anchor" href="#fail-safe-机制与-fail-fast-机制分别有什么作用" aria-label="Permalink to “fail-safe 机制与 fail-fast 机制分别有什么作用”">​</a></h2><p>是线程并发操作集合时的一种失败处理机制。fail-fast在遍历集合时，一旦发现容器中的数据被修改，则直接抛出异常，java.util包下的集合类都是快速失败机制。fail-safe：失败安全，出现集合的修改，不会抛出异常，原因是采用失败安全的容器，都是对原集合进行了复制，在拷贝的集合上进行遍历，不能被迭代器检测到。java.util. concurrent 包下都是线程安全的。比如concurrentHashMap和copyonWriteArrayList</p><h2 id="谈谈你对-seata-的理解" tabindex="-1"><strong>谈谈你对 Seata 的理解</strong> <a class="header-anchor" href="#谈谈你对-seata-的理解" aria-label="Permalink to “谈谈你对 Seata 的理解”">​</a></h2><p>AT：基于本地事务+二阶段提交</p><p>TCC模型：最终一致性</p><p>Saga模式：长事务解决方案，业务中每个参与者都提交本地事务，当某个参与者失败则补偿前面已经成功的参与者。</p><p>XA：强一致性</p><p><strong>能回答一下 Spring Bean 生命周期的执行流程吗</strong></p><p>Spring Boot 中自动装配机制的原理</p><p>介绍一下自己对Netty 的认识吧</p><p><a href="https://developer.aliyun.com/article/1460045" target="_blank" rel="noreferrer">https://developer.aliyun.com/article/1460045</a></p><h1 id="怎么提升的代码质量呢" tabindex="-1">怎么提升的代码质量呢？ <a class="header-anchor" href="#怎么提升的代码质量呢" aria-label="Permalink to “怎么提升的代码质量呢？”">​</a></h1><p><a href="https://blog.csdn.net/fudaihb/article/details/144185302" target="_blank" rel="noreferrer">https://blog.csdn.net/fudaihb/article/details/144185302</a></p><p>一、代码质量的定义与重要性 1.1 代码质量的定义 代码质量是指代码的设计、实现、可维护性、可读性、性能、安全性等多个方面的综合评估。具体来说，代码质量包含以下几个维度：</p><p>可读性：代码易于理解，命名清晰，注释合理，结构简洁。 可维护性：代码易于修改和扩展，重构成本低，依赖性明确。 性能：代码执行效率高，资源利用率优化。 安全性：代码能够有效防止安全漏洞和恶意攻击。 可靠性：代码在各种条件下能够稳定运行，不易崩溃或出错。 提升代码质量，不仅是为了保证软件系统的健康发展，还能够在长时间内为团队节省大量的维护和修复成本。</p><p>1.2 代码质量的重要性 提高开发效率：高质量的代码容易理解和维护，开发人员能够快速上手和修改，减少了无谓的重复劳动和调试时间。 降低bug率：优良的代码规范和测试可以有效地减少bug的发生，避免在生产环境中出现问题。 提高系统性能和安全性：通过优化代码设计，可以提升系统的性能和安全性，避免性能瓶颈和安全漏洞。 可持续的代码维护：高质量的代码结构清晰，模块化程度高，有助于后期的扩展和维护，降低了技术债务。 二、提升代码质量的核心方法 2.1 代码规范与标准 代码规范是提升代码质量的基石。规范化的编码可以确保团队在开发过程中遵循统一的规则，避免了不必要的混乱，并确保代码风格的一致性。良好的代码规范能够提升代码的可读性和可维护性。</p><p>2.1.1 编写清晰且一致的命名规则 命名是代码规范中的重要部分。清晰且一致的命名可以帮助开发者快速理解代码的含义，减少理解的歧义和错误。</p><p>变量命名：命名要简洁明了，避免使用模糊的词汇。例如，user 比 data 更能准确表达一个用户对象。 函数命名：函数名要能准确描述函数的功能，如 calculateTotalAmount 比 doSomething 更具描述性。 类和模块命名：类和模块名应当能反映其功能和作用，例如，UserService 表示用户相关的服务。 2.1.2 遵循代码风格约定 无论是使用 Java、Python 还是 JavaScript，遵循语言的编码风格是提升代码质量的重要环节。例如，Java 中使用 Google Java Style Guide，Python 中使用 PEP 8 标准等。</p><p>缩进：统一使用空格或制表符，不要混用。 空格和空行：合理使用空格分隔代码块，确保代码清晰易懂。 注释：适量的注释帮助开发者理解复杂的逻辑和思路。每个方法或复杂的代码块需要有简短的注释，解释其目的和逻辑。 2.1.3 遵循设计原则 在编码过程中，遵循面向对象设计原则（如 SOLID 原则）、设计模式等，将使代码更加灵活和可扩展。</p><p>单一职责原则（SRP）：每个类应该只有一个职责。 开闭原则（OCP）：软件实体应当对扩展开放，对修改封闭。 依赖倒转原则（DIP）：高层模块不应依赖低层模块，二者都应依赖抽象。 接口隔离原则（ISP）：不应强迫客户依赖于它们不使用的接口。 2.2 自动化测试与单元测试 测试是确保代码质量的有效手段。通过自动化测试和单元测试，能够在代码实现阶段及时发现问题，保证系统的可靠性和稳定性。</p><p>2.2.1 单元测试 单元测试是指对软件中的最小单元（函数、方法或类）进行验证。它确保了每个模块按预期工作，并且能够及早发现潜在的bug。</p><p>使用测试框架：常用的测试框架如 JUnit、TestNG、pytest 等，能够帮助团队自动化测试过程，提高测试效率。 编写高质量的单元测试用例：单元测试应包括边界条件、异常处理、正向和反向测试等，确保覆盖尽可能多的场景。 2.2.2 集成测试 集成测试是测试模块之间的协作。单独的模块可以通过单元测试验证其功能，而多个模块的协作则需要通过集成测试来确保没有问题。</p><p>2.2.3 端到端测试 端到端测试（E2E）模拟用户操作，从整个系统的角度来验证系统的功能，确保各个部分的协作无误。</p><p>2.3 持续集成与持续交付 持续集成（CI）和持续交付（CD）是提升代码质量的重要方法，它们确保代码在整个开发过程中始终保持高质量。</p><p>2.3.1 持续集成（CI） 持续集成是指开发人员频繁地将代码提交到代码仓库，并通过自动化构建和测试来验证代码的正确性。</p><p>自动化构建：通过工具（如 Jenkins、GitLab CI）实现代码的自动化构建，确保每次提交都能自动进行编译和测试。 集成测试：每次提交后，CI 系统会自动运行集成测试，确保模块之间没有引入新问题。 及时反馈：CI 系统会在构建和测试后立即给出反馈，帮助开发者尽早发现并修复问题。 2.3.2 持续交付（CD） 持续交付是指将代码自动部署到生产环境之前的每个阶段，通过自动化的方式实现快速交付和发布。</p><p>自动化部署：通过自动化工具将代码部署到不同环境（如开发环境、测试环境和生产环境），减少人工操作带来的错误。 灰度发布：通过灰度发布等策略，逐步将新版本推送到生产环境，减少系统故障风险。 2.4 代码复审与同行评审 代码复审（Code Review）是提高代码质量的重要手段之一。通过同行评审，开发者可以相互检查代码，发现潜在的缺陷和优化点。</p><p>2.4.1 复审的好处 发现bug：通过代码审查，可以提早发现 bug，避免将问题带到生产环境。 知识共享：开发人员之间相互复审代码，有助于知识和经验的分享，提高团队整体的技术水平。 提高代码质量：同行评审能够提供不同的视角和建议，提升代码质量。 2.4.2 复审的最佳实践 确保全面性：审查时关注代码的所有方面，包括功能实现、性能优化、代码风格、测试覆盖等。 避免过度审查：代码审查应该是建设性的，避免只挑剔瑕疵，而忽略代码中的优点和亮点。 及时反馈：开发人员应及时给予反馈，确保开发进度不被影响。 2.5 架构设计与模块化 良好的架构设计是提升代码质量的关键。高内聚低耦合的模块化设计有助于提高代码的可维护性、可扩展性和稳定性。</p><p>2.5.1 设计模式的运用 设计模式是经过多次实践验证的解决特定问题的方案。常见的设计模式如单例模式、工厂模式、策略模式、观察者模式等，可以帮助开发人员在架构设计中找到合适的解决方案。</p><p>2.5.2 模块化与解耦 通过模块化设计，可以将复杂系统拆分成</p><p>若干个小模块，每个模块只负责单一职责，并与其他模块保持低耦合。模块化设计不仅有助于代码的可维护性，还能够提升系统的可扩展性。</p><p>2.5.3 架构的扩展性与灵活性 良好的架构设计要考虑系统的未来扩展性和灵活性。设计时应预留扩展接口，避免后期修改系统时带来巨大的变动。</p><p>三、总结与展望 提升代码工程质量是一个持续的过程，需要团队在开发的每个阶段都注重质量的把控。从编码规范到单元测试，从持续集成到代码复审，每一个环节的精细化管理都能够为提升代码质量做出贡献。</p><h1 id="jdk17-新特性梳理" tabindex="-1">JDK17 新特性梳理 <a class="header-anchor" href="#jdk17-新特性梳理" aria-label="Permalink to “JDK17 新特性梳理”">​</a></h1><ol><li>局部变量推断</li><li>swtich增强</li><li>instanceof</li><li>文本块</li><li>模块化和封装类。模块化，允许将代码模块化，自定义jre包，减少内存消耗</li><li>性能提升，重写底层NIO，性能提升10%</li><li>空指针异常增强，方便排查问题</li></ol><h1 id="springboot3比2的优点" tabindex="-1">SPringboot3比2的优点 <a class="header-anchor" href="#springboot3比2的优点" aria-label="Permalink to “SPringboot3比2的优点”">​</a></h1><p><a href="https://zhuanlan.zhihu.com/p/26690755673" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/26690755673</a></p><ol><li><p>基于framework6，性能和安全性都有了更大的提升</p></li><li><p>模块化支持升级</p></li><li><p>Web 框架新选择。2是基于mvc框架，同步堵塞，导致大量的IO操作，线程资源容易被耗尽。3引入了webflux，基于响应式编程模式和IO非阻塞</p></li><li><p>数据库访问变革，引入了SpringData R2DBC 利用了 NIO（非阻塞 I/O）技术，使得在等待数据库响应时，应用可以继续执行其他任务，从而大大提高了系统的吞吐量。</p></li><li><p>性能优化</p><ul><li>启动速度与内存优化 其中借助 <a href="https://zhida.zhihu.com/search?content_id=254360820&amp;content_type=Article&amp;match_order=1&amp;q=GraalVM&amp;zhida_source=entity" target="_blank" rel="noreferrer">GraalVM</a> 原生镜像支持</li><li>综和性能提升</li></ul></li><li><p>安全性增强</p><ul><li>密码存储与安全机制</li><li>OAuth 2.1 支持</li></ul></li></ol><h1 id="异步编排-completablefuture" tabindex="-1">异步编排 <strong>CompletableFuture</strong> <a class="header-anchor" href="#异步编排-completablefuture" aria-label="Permalink to “异步编排 CompletableFuture”">​</a></h1><p>线程任务编排指的是对多个线程任务按照一定的逻辑顺序或条件进行组织和安排，以实现协同工作、顺序执行或并行执行的一种机制。</p><h1 id="双亲委派" tabindex="-1">双亲委派 <a class="header-anchor" href="#双亲委派" aria-label="Permalink to “双亲委派”">​</a></h1><p>是JAVA类加载器的一种工作机制，当加载器要加载一个类时，首先它不会自己去加载这个类，而是委派给父级加载器去完成，每一个层次的加载器都是如此，因此，所有的加载请求最终都会传送给顶层启动类加载器，只有父类加载器反馈自己无法加载此类，才会尝试自己去加载。</p><p>优点：避免重复加载类、更安全，不能重写核心类。</p><h1 id="防重复提交" tabindex="-1">防重复提交 <a class="header-anchor" href="#防重复提交" aria-label="Permalink to “防重复提交”">​</a></h1><p>前端：按钮置灰、跳转到结果页</p><p>后端：token机制，比如下单，前端先去后端请求一个token，提交时带着token，如果存在并且未处理，则执行下面逻辑，如果不存在，则返回重复。</p><h1 id="接口的幂等性在项目中怎么做的" tabindex="-1">接口的幂等性在项目中怎么做的 <a class="header-anchor" href="#接口的幂等性在项目中怎么做的" aria-label="Permalink to “接口的幂等性在项目中怎么做的”">​</a></h1><ol><li>按钮置灰</li><li>token机制，进入页面后，请求后端生成token并存储，点击提交，判断token存在且未处理，执行业务逻辑，token销毁，再次提交时，因为token已销毁，从而拒绝重复提交。</li><li></li><li>防重表</li></ol><p>插入操作：</p><p>数据库层面：唯一ID或唯一索引。创建一个消息表，里面有一个消息内容的字段并且设置唯一索引，每次收到消息后生成MD5值插入到这个消息表里。一旦出现重复消息，就会抛异常，我们可以捕获这个异常来避免重复。</p><p>使用SetNX命令，可以把当前请求中带有唯一标识的信息存储到redis里面。</p><p>更新操作：乐观锁，使用版本号或时间戳</p><ol start="2"><li>状态机幂等，本质上也是乐观锁</li></ol><h1 id="如何快速定位某个服务出现问题" tabindex="-1">如何快速定位某个服务出现问题 <a class="header-anchor" href="#如何快速定位某个服务出现问题" aria-label="Permalink to “如何快速定位某个服务出现问题”">​</a></h1><ul><li>链路追踪skywalking，功能比较齐全，插件比较多</li><li>zipkin+Slthuth，轻量级</li></ul><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to “”">​</a></h1><h1 id="三个线程循环打印abc" tabindex="-1">三个线程循环打印ABC <a class="header-anchor" href="#三个线程循环打印abc" aria-label="Permalink to “三个线程循环打印ABC”">​</a></h1><ol><li>object的wait（）和notifal</li><li>循环栅栏。 当然，CyclicBarrier的实现其实还是基于lock+condition，多个线程在到达一定条件前await，到达条件后signalAll。</li></ol><h1 id="dubbo" tabindex="-1">Dubbo <a class="header-anchor" href="#dubbo" aria-label="Permalink to “Dubbo”">​</a></h1><p>高性能RPC框架，基于tcp或http的远程过程调用，支持负载均衡和容错，自动服务注册和发现。</p><h1 id="sentinel" tabindex="-1">Sentinel <a class="header-anchor" href="#sentinel" aria-label="Permalink to “Sentinel”">​</a></h1><p>Spring Cloud Alibaba Sentinel 是目前主流并开源的流量控制和系统保护组件，它提供了强大的限流、熔断、热点限流、授权限流和系统保护及监控等功能。使用它可以轻松的保护我们微服务，在高并发环境下的正常运行。</p><h1 id="常见的限流算法" tabindex="-1">常见的限流算法： <a class="header-anchor" href="#常见的限流算法" aria-label="Permalink to “常见的限流算法：”">​</a></h1><p>计数器：在一定的时间间隔内，记录请求的次数，当请求的次数到达限制时，就把计数器清零，然后重新计算，当请求次数超过限制，就拒绝访问。有突刺现象。</p><p>漏桶：固定容量的漏桶，请求可以以任意速率进入到漏桶里，但漏桶是以固定速率流出，当流入流量过大，超过漏桶的容量，则请求直接溢出。 漏桶算法提供了一种机制，通过它可以让突发流量被整形，以便为系统提供稳定的请求，比如 Sentinel 中流量整形（匀速排队功能）就是此算法实现的</p><p>令牌：通过控制桶中的令牌实现限流，可以处理一定的突发流量，比如处理一次洪峰。</p><h1 id="gateway" tabindex="-1">Gateway <a class="header-anchor" href="#gateway" aria-label="Permalink to “Gateway”">​</a></h1><p>网关（Gateway）是微服务中不可缺少的一部分，它是微服务中提供了统一访问地址的组件，充当了客户端和内部微服务之间的中介。网关主要负责流量路由和转发，将外部请求引导到相应的微服务实例上，同时提供一些功能，如身份认证、授权、限流、监控、日志记录等。</p><table tabindex="0"><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>redisson</td><td></td><td></td></tr><tr><td>redis部署模式</td><td></td><td></td></tr><tr><td>mysql索引</td><td>+1</td><td></td></tr><tr><td>kafka消息不丢失</td><td></td><td></td></tr><tr><td>docker</td><td></td><td></td></tr><tr><td>redis优化</td><td></td><td></td></tr><tr><td>B+树</td><td></td><td></td></tr><tr><td>手写饿汉，懒汉</td><td></td><td></td></tr><tr><td>voletile</td><td></td><td></td></tr></tbody></table><table tabindex="0"><thead><tr><th>含义：</th><th></th><th></th></tr></thead><tbody><tr><td>QPS</td><td></td><td></td></tr><tr><td>CAP理论</td><td></td><td></td></tr><tr><td>BASE理论</td><td></td><td></td></tr><tr><td>23设计模式</td><td></td><td></td></tr><tr><td>7个开发原则</td><td></td><td></td></tr><tr><td>2PC</td><td></td><td></td></tr><tr><td>3PC</td><td></td><td></td></tr><tr><td>总体平均 RT</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="拦截器和过滤器区别" tabindex="-1">拦截器和过滤器区别？ <a class="header-anchor" href="#拦截器和过滤器区别" aria-label="Permalink to “拦截器和过滤器区别？”">​</a></h2><ol><li>出身不同，过滤器基于servlet，拦截器是基于spring</li><li>触发时机不同，请求的执行顺序是进入容器-&gt;进入过滤器-》进入servlet-》进入拦截器-》执行控制器</li><li>底层实现不同，过滤器是基于方法回调，拦截器是基于动态代理（底层是基于反射）。</li><li>支持的项目类型不同，过滤器是基于servlet，只能用于web项目，而拦截器可以用Swing项目中</li><li>场景不同：拦截器更接近业务系统，所以拦截器主要来实现项目中的业务判断，比如：登录判断，权限判断、日志记录等。而过滤器通常是用来实现通用功能过滤的，比如敏感词过滤，字符集编码设置，相应数据压缩等。</li></ol><p><strong>Redis和mysql如何保持数据一致性</strong></p><p>极端情况下，采用最终一致性方案。基于MQ的可靠性消息通信，来实现最终一致性，写入失败的消息，写入MQ，异步重试，保证成功</p><p>通过Cannl组件，监控Mysql中binlog的日志，把更新后的数据，更新到redis里面。</p><h1 id="java基础" tabindex="-1">JAVA基础 <a class="header-anchor" href="#java基础" aria-label="Permalink to “JAVA基础”">​</a></h1><h2 id="hashmap和concurrenthashmap" tabindex="-1"><code>HashMap</code>和<code>ConcurrentHashMap</code> <a class="header-anchor" href="#hashmap和concurrenthashmap" aria-label="Permalink to “HashMap和ConcurrentHashMap”">​</a></h2><p>1.7基于哈希表实现，1.8基于数组+链表+红黑树。 在 Java8 中，用链表来解决哈希冲突，当链表中的元素达到了 8 个时，会将链表转换为红黑树，链表的查询时间复杂度是 O(n)，转为红黑树之后降低为 O(logN)，提高了查询效率。</p><p>JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，那么他们为什么要这样做呢？因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在JDK1.8之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。</p><p>2个重要的参数，加载因子默认是0.75，初始容量设置为16</p><p>当负载因子设置比较大的时候，扩容发生的频率比较低，占用的空间会比较小，发生 Hash 冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低。</p><ul><li><code>ConcurrentHashMap JDK1.7</code>: 使用分段锁机制实现;</li><li><code>ConcurrentHashMap JDK1.8</code>: 则使用数组+链表+红黑树数据结构和CAS原子操作实现;</li></ul><p>在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以其最大并发度受Segment的个数限制。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与HashMap类似的数组+链表+红黑树的方式实现，而加锁则采用CAS和synchronized实现。</p><h2 id="java是如何实现多线程的" tabindex="-1">JAVA是如何实现多线程的 <a class="header-anchor" href="#java是如何实现多线程的" aria-label="Permalink to “JAVA是如何实现多线程的”">​</a></h2><ol><li>继承Thread类，重新run方法</li><li>实现runnable，</li><li>实现callable和使用FutureTask</li><li>使用线程池</li></ol><h2 id="双向链表" tabindex="-1">双向链表 <a class="header-anchor" href="#双向链表" aria-label="Permalink to “双向链表”">​</a></h2><p>特点：有2个指针，一个指针指向前置节点，一个指针指向后置节点。可以支持O(1)时间复杂度的情况下找到前驱节点，基于这个特点，双向链表在插入和删除操作的时候，要比单向链表简单，高效。</p><p>滑动窗口算法</p><p>分布式和微服务的理解</p><p>回滚出现问题要怎么处理</p><p>SpringBoot启动时，加载流程</p><p>如何提高服务的负载能力</p><p>AQS 为什么要使用双向链表？</p><h2 id="基础常识" tabindex="-1">基础常识 <a class="header-anchor" href="#基础常识" aria-label="Permalink to “基础常识”">​</a></h2><p><strong>并发数（并发度）：</strong>系统同时处理请求的数量。同样反应了系统的负载能力， 这个数值可以分析机器1s内的访问日志数量来得到 。</p><p><strong>QPS：</strong>每秒查询数，单次查询，比如页面上所有的请求。优化方法：优化查询效率和响应时间，建立高效的索引、使用更快的查询算法、实时缓存机制。</p><p><strong>TPS（吞吐量）：</strong>事务每秒数，一个事务，包含了多个操作，完成一次请求。比QPS更适合描述系统的整体性能。优化方法：优化事务处理的效率。包括数据库优化、缓存策略，多线程并发处理等。</p><p>如果是对一个接口（单场景）压测，且这个接口内部不会再去请求其它接口，那么tps=qps，否则，tps≠qps</p><p>如果是对多个接口（混合场景）压测，不加事务控制器，jmeter会统计每个接口的tps，而混合场景是要测试这个场景的tps，显然这样得不到混合场景的tps，所以，要加了事物控制器，结果才是整个场景的tps。</p><p>jmeter聚合报告中，Throughput是用来衡量吞吐量，通常由tps来表示</p><p><strong>JMeter：</strong>性能测试工具。<a href="https://blog.csdn.net/MXB_1220/article/details/141025059" target="_blank" rel="noreferrer">https://blog.csdn.net/MXB_1220/article/details/141025059</a></p><p>短链：将长的网址转换成短的连接，达到同样的访问效果。优点：短（节省短信发送成本）、数据分析（统计效果）、提升用户体验。</p><p>Spring启动流程</p><p>Spring自动装配</p><p>SpringBean的生命周期</p><p>Mysql 主从集群同步延迟问题怎么解决</p><p>什么是聚集索引和非聚集索引</p><p>Redis 的内存淘汰算法和原理是什么？</p><p>new String(&quot;abc&quot;）到底创建了几个对象？</p><h1 id="docker" tabindex="-1">Docker <a class="header-anchor" href="#docker" aria-label="Permalink to “Docker”">​</a></h1><p><a href="https://blog.csdn.net/qq_47158964/article/details/143593610" target="_blank" rel="noreferrer">https://blog.csdn.net/qq_47158964/article/details/143593610</a></p><p>如何提升 RocketMQ顺序消费性能？</p></div></div></main><footer class="VPDocFooter" data-v-7011f0d8 data-v-e257564d><!--[--><!--]--><!----><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"01.后端技术栈_java基础.md\":\"QC5wiYMk\",\"01.后端技术栈_java基础2.md\":\"KdEV7wBO\",\"01.后端技术栈_jdk8-21.md\":\"QVyqOpOg\",\"01.后端技术栈_多线程_java并发-threadlocal.md\":\"jIJjlyCs\",\"01.后端技术栈_多线程_java并发-理论基础.md\":\"DjL0Ykzi\",\"01.后端技术栈_多线程_juc线程池-completablefuture.md\":\"2f3UTrcW\",\"01.后端技术栈_多线程_juc线程池-threadpoolexecutor.md\":\"BMXbVa0f\",\"01.后端技术栈_多线程_juc集合-blockingqueue.md\":\"BiVFYqeR\",\"01.后端技术栈_多线程_关键字final.md\":\"WwMbTa5r\",\"01.后端技术栈_多线程_关键字synchronized.md\":\"BmtMCKCN\",\"01.后端技术栈_多线程_关键字volatile.md\":\"DjIaiIau\",\"01.后端技术栈_算法.md\":\"C2jZqr12\",\"01.后端技术栈_网络io.md\":\"CbK-uhLH\",\"02.spring_spring-@transactional事务失效的场景.md\":\"CnC9ehpY\",\"02.spring_spring.md\":\"C9GQbSbE\",\"02.spring_springboot.md\":\"De9jTNfW\",\"02.spring_springcloud.md\":\"DSARoEIO\",\"02.前端技术栈_html.md\":\"CMfWgYXj\",\"02.前端技术栈_javascript.md\":\"De4l4jUj\",\"02.算法_算法基础和思想_数据结构基础_数据结构基础概述.md\":\"B_8s5pyR\",\"02.算法_算法基础和思想_数据结构基础_线性表-数组和矩阵.md\":\"B7qZ_6Wy\",\"02.算法_算法基础和思想_数据结构基础_线性表-链表.md\":\"B9a6smwE\",\"03.工具-部署_linux运维笔记.md\":\"B2GbAGTy\",\"03.工具-部署_window.md\":\"BIYzglmB\",\"03.工具-部署_工具-部署.md\":\"DsYv9u8n\",\"03.工具-部署_常见单词.md\":\"C8HuqWYi\",\"03.工具-部署_收藏目录.md\":\"ByVpw9Qb\",\"03.数据库_kafka.md\":\"BixfX6Ol\",\"03.数据库_mysql-sql优化.md\":\"BB6AlTys\",\"03.数据库_mysql-主从复制数据一致性.md\":\"DlKEROeg\",\"03.数据库_mysql-主从复制的原理.md\":\"gW_L-Vb1\",\"03.数据库_mysql-事务.md\":\"BiJRoRTP\",\"03.数据库_mysql-全局id.md\":\"CIx_qjLt\",\"03.数据库_mysql-大厂实践-美团mysql索引原理及慢查询优化.md\":\"C57gkC6R\",\"03.数据库_mysql-大厂实践-美团sql优化工具sqladvisor开源.md\":\"DRTrJthL\",\"03.数据库_mysql-深度分页.md\":\"Dbu2upTc\",\"03.数据库_mysql-索引.md\":\"JaoQi9o5\",\"03.数据库_mysql和redis数据一致性.md\":\"DOMqrS5l\",\"03.数据库_netty.md\":\"C-Y4GtZM\",\"03.数据库_redis.md\":\"CVraal22\",\"03.数据库_redis_性能调优.md\":\"BBaf_CMd\",\"03.数据库_redis_持久化rdb和aop.md\":\"CdQIriis\",\"03.数据库_redis_数据结构-对象与编码(底层结构).md\":\"DFeBrzVO\",\"03.数据库_redis_数据结构-对象机制.md\":\"CCMgM2xY\",\"03.数据库_redis_数据结构-底层数据结构.md\":\"CZjK2meg\",\"03.数据库_redis_概念和基础.md\":\"C0HsGHnY\",\"03.数据库_redis_高可用-主从复制.md\":\"DXpC-41k\",\"03.数据库_redis_高可用-哨兵机制.md\":\"_AzYX09P\",\"03.数据库_zookeeper.md\":\"DyjSpJbY\",\"04.中间件_kafka.md\":\"D-tI2eJk\",\"04.中间件_netty.md\":\"CFcZ2hw2\",\"04.中间件_zookeeper.md\":\"LMlbq6Tb\",\"04.方法论_代码规范.md\":\"Bzs_jHHs\",\"04.方法论_开发流程.md\":\"CVEDR5zS\",\"05.架构_常用技术点_jwt.md\":\"DvA3pYeG\",\"05.架构_常用技术点_数据库读写分离.md\":\"CsuSSDlg\",\"05.架构_架构300讲.md\":\"DZm2h1HD\",\"05.架构_架构900讲_01通用性架构.md\":\"DpuCOM-h\",\"05.架构_架构900讲_mq.md\":\"lI5JoVAY\",\"05.架构_架构900讲_redis.md\":\"DEP7N8f0\",\"05.架构_架构900讲_数据库-mysql.md\":\"BB3xfgRd\",\"05.架构_架构900讲_数据库.md\":\"DZp5n7ge\",\"05.架构_架构900讲_运维.md\":\"DCQHio2F\",\"06.设计模式_0-简介.md\":\"BlC2pYvN\",\"06.设计模式_1-单例模式.md\":\"u0nTY7eS\",\"06.设计模式_10-桥接模式.md\":\"Ccp8R_qu\",\"06.设计模式_11-组合模式.md\":\"B1GhxeEk\",\"06.设计模式_12-享元模式.md\":\"AkotPE6P\",\"06.设计模式_13-观察者模式.md\":\"CesAiKIl\",\"06.设计模式_14-策略模式.md\":\"BTzGx7bJ\",\"06.设计模式_15-命令模式.md\":\"BESWRTz3\",\"06.设计模式_16-中介者模式.md\":\"DpRlU-PE\",\"06.设计模式_17-备忘录模式.md\":\"BHES4fFW\",\"06.设计模式_18-模板方法模式.md\":\"Bgj6_eqg\",\"06.设计模式_19-迭代器模式.md\":\"CkhvDRNG\",\"06.设计模式_2-工厂方法模式.md\":\"VYv1ToD5\",\"06.设计模式_20-状态模式.md\":\"a63pDKRT\",\"06.设计模式_21-责任链模式.md\":\"CMKqSQ7m\",\"06.设计模式_22-解释器模式.md\":\"DuPqro7Z\",\"06.设计模式_23-访问者模式.md\":\"CJ_7w-59\",\"06.设计模式_3-抽象工厂模式.md\":\"IBk5BVVC\",\"06.设计模式_4-建造者模式.md\":\"CJQt_iiA\",\"06.设计模式_5-原型模式.md\":\"DEWNjmPE\",\"06.设计模式_6-适配器模式.md\":\"C9ggj-uA\",\"06.设计模式_7-代理模式.md\":\"CCQwGIOG\",\"06.设计模式_8-装饰模式.md\":\"EQl7yHX3\",\"06.设计模式_9-外观模式.md\":\"DEp9HNjN\",\"07.代码人生_三十而立之年.md\":\"51XTb1x3\",\"07.代码人生_人生教训.md\":\"CJXsnMc5\",\"07.代码人生_开发注意事项.md\":\"CEicDgAi\",\"07.代码人生_改变.md\":\"Bb5eb8fL\",\"07.代码人生_每日计划.md\":\"CDIu6ibS\",\"07.代码人生_生活小技巧.md\":\"B3KjbHrj\",\"api-examples.md\":\"C4MPM3ac\",\"index.md\":\"BS9NxHIm\",\"markdown-examples.md\":\"CEd4icy5\",\"后台管理系统脚手架.md\":\"C6hujDFy\",\"面试题.md\":\"vXECt2eo\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Java全栈知识体系\",\"description\":\"A VitePress site\",\"base\":\"/wiki/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/logo.svg\",\"outline\":\"deep\",\"nav\":[{\"text\":\"后台管理系统脚手架\",\"link\":\"/后台管理系统脚手架\"},{\"text\":\"JAVA\",\"items\":[{\"text\":\"JAVA基础\",\"link\":\"/01.后端技术栈/JAVA基础\"},{\"text\":\"多线程\",\"link\":\"/01.后端技术栈/多线程/JAVA并发-理论基础\"}]},{\"text\":\"Spring全家桶\",\"items\":[{\"text\":\"Spring\",\"link\":\"/02.Spring/Spring-@Transactional事务失效的场景\"},{\"text\":\"SpringBoot\",\"link\":\"/02.Spring/SpringBoot\"}]},{\"text\":\"数据库\",\"items\":[{\"text\":\"Mysql\",\"link\":\"/03.数据库/MySql-索引\"},{\"text\":\"Redis\",\"link\":\"/03.数据库/Redis/概念和基础\"}]},{\"text\":\"中间件\",\"items\":[{\"text\":\"Kafka\",\"link\":\"/04.中间件/Kafka.md\"},{\"text\":\"Zookeeper\",\"link\":\"/04.中间件/Zookeeper.md\"},{\"text\":\"Netty\",\"link\":\"/04.中间件/Netty.md\"}]},{\"text\":\"工具|部署\",\"link\":\"/03.工具-部署/linux运维笔记\"},{\"text\":\"设计模式\",\"link\":\"/06.设计模式/0-简介\"},{\"text\":\"方法论\",\"items\":[{\"text\":\"代码规范\",\"link\":\"/04.方法论/代码规范\"}]},{\"text\":\"架构\",\"items\":[{\"text\":\"常用技术点\",\"link\":\"/05.架构/常用技术点/JWT\"},{\"text\":\"架构300讲\",\"link\":\"/05.架构/架构300讲\"}]},{\"text\":\"代码人生\",\"link\":\"/07.代码人生/生活小技巧\"}],\"sidebar\":{\"/01.后端技术栈/\":[{\"text\":\"JAVA\",\"items\":[{\"text\":\"JAVA基础One\",\"link\":\"/01.后端技术栈/JAVA基础.md\"},{\"text\":\"JAVA基础Two\",\"link\":\"/01.后端技术栈/JAVA基础2\"},{\"text\":\"网络IO\",\"link\":\"/01.后端技术栈/网络IO\"},{\"text\":\"多线程\",\"items\":[{\"text\":\"JAVA并发-理论基础\",\"link\":\"/01.后端技术栈/多线程/JAVA并发-理论基础\"},{\"text\":\"关键字：synchronized\",\"link\":\"/01.后端技术栈/多线程/关键字synchronized\"},{\"text\":\"关键字：volatile\",\"link\":\"/01.后端技术栈/多线程/关键字volatile\"},{\"text\":\"关键字：final\",\"link\":\"/01.后端技术栈/多线程/关键字final\"},{\"text\":\"JUC集合-BlockingQueue\",\"link\":\"/01.后端技术栈/多线程/JUC集合-BlockingQueue\"},{\"text\":\"JUC线程池-CompletableFuture\",\"link\":\"/01.后端技术栈/多线程/JUC线程池-CompletableFuture\"},{\"text\":\"JUC线程池-ThreadPoolExecutor\",\"link\":\"/01.后端技术栈/多线程/JUC线程池-ThreadPoolExecutor\"},{\"text\":\"JAVA并发-ThreadLocal\",\"link\":\"/01.后端技术栈/多线程/JAVA并发-ThreadLocal\"}]}]}],\"/02.Spring/\":[{\"text\":\"Spring全家桶\",\"items\":[{\"text\":\"Spring\",\"items\":[{\"text\":\"@Transactional事务失效的场景\",\"link\":\"/02.Spring/Spring-@Transactional事务失效的场景\"}]},{\"text\":\"SpringBoot\",\"link\":\"/02.Spring/SpringBoot\"}]}],\"/03.数据库/\":[{\"text\":\"数据库\",\"items\":[{\"text\":\"Mysql\",\"items\":[{\"text\":\"索引\",\"link\":\"/03.数据库/MySql-索引.md\"},{\"text\":\"事务\",\"link\":\"/03.数据库/MySql-事务\"},{\"text\":\"SQL优化\",\"link\":\"/03.数据库/MySql-SQL优化\"},{\"text\":\"主从复制的原理\",\"link\":\"/03.数据库/MySql-主从复制的原理\"},{\"text\":\"主从复制数据一致性\",\"link\":\"/03.数据库/MySql-主从复制数据一致性\"},{\"text\":\"分库分表全局ID\",\"link\":\"/03.数据库/MySql-全局ID\"},{\"text\":\"深度分页limit\",\"link\":\"/03.数据库/MySql-深度分页\"},{\"text\":\"大厂实践:美团MySQL索引原理及慢查询优化\",\"link\":\"/03.数据库/MySql-大厂实践-美团MySQL索引原理及慢查询优化\"},{\"text\":\"大厂实践:美团SQL优化工具SQLAdvisor开源\",\"link\":\"/03.数据库/MySql-大厂实践-美团SQL优化工具SQLAdvisor开源\"}]},{\"text\":\"Redis\",\"items\":[{\"text\":\"概念和基础\",\"link\":\"/03.数据库/Redis/概念和基础\"},{\"text\":\"数据结构-对象机制\",\"link\":\"/03.数据库/Redis/数据结构-对象机制\"},{\"text\":\"数据结构-底层数据结构\",\"link\":\"/03.数据库/Redis/数据结构-底层数据结构\"},{\"text\":\"数据结构-对象与编码(底层结构)\",\"link\":\"/03.数据库/Redis/数据结构-对象与编码(底层结构)\"},{\"text\":\"持久化RDB和AOF\",\"link\":\"/03.数据库/Redis/持久化RDB和AOP\"},{\"text\":\"高可用-主从复制\",\"link\":\"/03.数据库/Redis/高可用-主从复制\"},{\"text\":\"高可用-哨兵机制\",\"link\":\"/03.数据库/Redis/高可用-哨兵机制\"},{\"text\":\"性能调优\",\"link\":\"/03.数据库/Redis/性能调优\"},{\"text\":\"Redis相关问题\",\"link\":\"/03.数据库/Redis\"}]},{\"text\":\"Mysql和Redis数据一致性\",\"link\":\"/03.数据库/Mysql和Redis数据一致性\"},{\"text\":\"Kafka\",\"link\":\"/03.数据库/Kafka.md\"},{\"text\":\"Zookeeper\",\"link\":\"/03.数据库/Zookeeper.md\"},{\"text\":\"Netty\",\"link\":\"/03.数据库/Netty.md\"}]}],\"/04.中间件/\":[{\"text\":\"中间件\",\"items\":[{\"text\":\"Kafka\",\"link\":\"/04.中间件/Kafka.md\"},{\"text\":\"Zookeeper\",\"link\":\"/04.中间件/Zookeeper.md\"},{\"text\":\"Netty\",\"link\":\"/04.中间件/Netty.md\"}]}],\"/02.算法/\":[{\"text\":\"算法基础和思想\",\"items\":[{\"text\":\"数据结构基础\",\"items\":[{\"text\":\"概述\",\"link\":\"/02.算法/算法基础和思想/数据结构基础/数据结构基础概述\"},{\"text\":\"线性表-数组和矩阵\",\"link\":\"/02.算法/算法基础和思想/数据结构基础/线性表-数组和矩阵\"},{\"text\":\"线性表-链表\",\"link\":\"/02.算法/算法基础和思想/数据结构基础/线性表-链表\"}]}]}],\"/06.设计模式/\":[{\"text\":\"设计模式\",\"items\":[{\"text\":\"0-简介\",\"link\":\"/06.设计模式/0-简介\"},{\"text\":\"1-单例模式\",\"link\":\"/06.设计模式/1-单例模式\"},{\"text\":\"2-工厂方法模式\",\"link\":\"/06.设计模式/2-工厂方法模式\"},{\"text\":\"3-抽象工厂模式\",\"link\":\"/06.设计模式/3-抽象工厂模式\"},{\"text\":\"4-建造者模式\",\"link\":\"/06.设计模式/4-建造者模式\"},{\"text\":\"5-原型模式\",\"link\":\"/06.设计模式/5-原型模式\"},{\"text\":\"6-适配器模式\",\"link\":\"/06.设计模式/6-适配器模式\"},{\"text\":\"7-代理模式\",\"link\":\"/06.设计模式/7-代理模式\"},{\"text\":\"8-装饰模式\",\"link\":\"/06.设计模式/8-装饰模式\"},{\"text\":\"*9-外观模式\",\"link\":\"/06.设计模式/9-外观模式\"},{\"text\":\"10-桥接模式\",\"link\":\"/06.设计模式/10-桥接模式\"},{\"text\":\"11-组合模式\",\"link\":\"/06.设计模式/11-组合模式\"},{\"text\":\"12-享元模式\",\"link\":\"/06.设计模式/12-享元模式\"},{\"text\":\"*13-观察者模式\",\"link\":\"/06.设计模式/13-观察者模式\"},{\"text\":\"*14-策略模式\",\"link\":\"/06.设计模式/14-策略模式\"},{\"text\":\"15-命令模式\",\"link\":\"/06.设计模式/15-命令模式\"},{\"text\":\"16-中介者模式\",\"link\":\"/06.设计模式/16-中介者模式\"},{\"text\":\"17-备忘录模式\",\"link\":\"/06.设计模式/17-备忘录模式\"},{\"text\":\"18-模板方法模式\",\"link\":\"/06.设计模式/18-模板方法模式\"},{\"text\":\"19-迭代器模式\",\"link\":\"/06.设计模式/19-迭代器模式\"},{\"text\":\"20-状态模式\",\"link\":\"/06.设计模式/20-状态模式\"},{\"text\":\"*21-责任链模式\",\"link\":\"/06.设计模式/21-责任链模式\"},{\"text\":\"22-解释器模式\",\"link\":\"/06.设计模式/22-解释器模式\"},{\"text\":\"23-访问者模式\",\"link\":\"/06.设计模式/23-访问者模式\"}]}],\"/02.前端技术栈/\":[{\"text\":\"前端\",\"items\":[{\"text\":\"JavaScript\",\"link\":\"/02.前端技术栈/JavaScript\"},{\"text\":\"Html\",\"link\":\"/02.前端技术栈/Html\"}]}],\"/03.工具-部署/\":[{\"text\":\"工具|部署\",\"items\":[{\"text\":\"linux运维笔记\",\"link\":\"/03.工具-部署/linux运维笔记\"},{\"text\":\"常见单词\",\"link\":\"/03.工具-部署/常见单词\"},{\"text\":\"收藏目录\",\"link\":\"/03.工具-部署/收藏目录\"},{\"text\":\"Html\",\"link\":\"/03.工具-部署/window\"},{\"text\":\"Markdown Examples\",\"link\":\"/markdown-examples\"},{\"text\":\"Runtime API Examples\",\"link\":\"/api-examples\"}]}],\"/04.方法论/\":[{\"text\":\"方法论\",\"items\":[{\"text\":\"代码规范\",\"link\":\"/04.方法论/代码规范\"}]}],\"/05.架构/\":[{\"text\":\"架构\",\"items\":[{\"text\":\"常用技术点\",\"items\":[{\"text\":\"JWT\",\"link\":\"/05.架构/常用技术点/JWT\"},{\"text\":\"数据库读写分离\",\"link\":\"/05.架构/常用技术点/数据库读写分离\"}]},{\"text\":\"架构900讲\",\"items\":[{\"text\":\"MQ\",\"link\":\"/05.架构/架构900讲/MQ\"},{\"text\":\"Redis\",\"link\":\"/05.架构/架构900讲/Redis\"},{\"text\":\"数据库\",\"link\":\"/05.架构/架构900讲/数据库\"},{\"text\":\"数据库-MySql\",\"link\":\"/05.架构/架构900讲/数据库-MySql\"},{\"text\":\"运维\",\"link\":\"/05.架构/架构900讲/运维\"}]},{\"text\":\"架构900讲\",\"link\":\"/05.架构/架构300讲\"}]}],\"/07.代码人生/\":[{\"text\":\"代码人生\",\"items\":[{\"text\":\"生活小技巧\",\"link\":\"/07.代码人生/生活小技巧\"},{\"text\":\"每日计划\",\"link\":\"/07.代码人生/每日计划\"}]}]},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/vuejs/vitepress\"}],\"search\":{\"provider\":\"local\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>